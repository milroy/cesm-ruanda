!===================================================
! DO NOT EDIT THIS FILE, it was generated using /glade/u/home/milroy/cesm/cesm1_3_beta11/tools/cprnc/genf90/genf90.pl 
! Any changes you make to this file may be lost
!===================================================
!>
!! @file 
!! $Revision: 894 $
!! $LastChangedDate: 2013-12-13 15:04:58 -0700 (Fri, 13 Dec 2013) $
!! @brief Decomposed Write interface to NetCDF
!<
module pionfwrite_mod
  use pio_kinds, only : r4, r8, i4, pio_offset
  implicit none
  private
!>
!! @private
!<
  public :: write_nf
  interface write_nf
     ! TYPE real,int,double
     module procedure write_nfdarray_real
     ! TYPE real,int,double
     module procedure write_nfdarray_int
     ! TYPE real,int,double
     module procedure write_nfdarray_double
  end interface

  character(len=*), parameter :: modName='pionfwrite_mod'


contains
  ! note: IOBUF may actually point to the original data
  ! array, and cannot be modified (which is why it is intent(in))

  ! TYPE real,int,double
!>
!! @private
!<
  integer function write_nfdarray_real (File,IOBUF,varDesc,iodesc,start,count, request) result(ierr)
    use nf_mod
    use pio_types, only : io_desc_t, var_desc_t, file_desc_t, iosystem_desc_t, pio_noerr, &
	pio_iotype_netcdf, pio_iotype_pnetcdf, pio_iotype_netcdf4p, pio_iotype_netcdf4c, pio_max_var_dims
    use pio_utils, only : check_netcdf, bad_iotype
    use alloc_mod, only: alloc_check
    use pio_support, only : Debug, DebugIO, piodie, checkmpireturn 



    use mpi !_EXTERNAL




    implicit none

    type (File_desc_t), intent(inout) :: File
    real(r4) , intent(in), target      :: IOBUF(:)
    type (var_desc_t), intent(in)     :: varDesc
    type (IO_desc_t), intent(in)      :: IODesc

    integer(pio_offset), intent(in) :: start(:), count(:)
    integer, intent(out) :: request


    character(len=*), parameter :: subName=modName//'::write_nfdarray_real'

    integer(i4) :: iotype, mpierr
    integer :: status(MPI_STATUS_SIZE)
    integer iobuf_size, max_iobuf_size
    real(r4) , pointer :: temp_iobuf(:)
    integer, dimension(PIO_MAX_VAR_DIMS) :: temp_start, temp_count
    integer i, ndims
    integer :: fh, vid, oldval

    request = MPI_REQUEST_NULL

    ierr = PIO_NOERR
    if(file%iosystem%ioproc) then
       iotype = File%iotype

       select case (iotype) 


       case default
          call bad_iotype(iotype,subname,241)

       end select
    endif  ! if (File%iosystem%IOproc)

    call check_netcdf(File, ierr,subname,246)
!  call mpi_barrier(file%iosystem%comp_comm, mpierr)
!  call CheckMPIReturn(subName,mpierr)

  end function WRITE_NFDARRAY_real
  ! TYPE real,int,double
!>
!! @private
!<
  integer function write_nfdarray_int (File,IOBUF,varDesc,iodesc,start,count, request) result(ierr)
    use nf_mod
    use pio_types, only : io_desc_t, var_desc_t, file_desc_t, iosystem_desc_t, pio_noerr, &
	pio_iotype_netcdf, pio_iotype_pnetcdf, pio_iotype_netcdf4p, pio_iotype_netcdf4c, pio_max_var_dims
    use pio_utils, only : check_netcdf, bad_iotype
    use alloc_mod, only: alloc_check
    use pio_support, only : Debug, DebugIO, piodie, checkmpireturn 

    use mpi !_EXTERNAL
    implicit none

    type (File_desc_t), intent(inout) :: File
    integer(i4) , intent(in), target      :: IOBUF(:)
    type (var_desc_t), intent(in)     :: varDesc
    type (IO_desc_t), intent(in)      :: IODesc

    integer(pio_offset), intent(in) :: start(:), count(:)
    integer, intent(out) :: request


    character(len=*), parameter :: subName=modName//'::write_nfdarray_int'

    integer(i4) :: iotype, mpierr
    integer :: status(MPI_STATUS_SIZE)
    integer iobuf_size, max_iobuf_size
    integer(i4) , pointer :: temp_iobuf(:)
    integer, dimension(PIO_MAX_VAR_DIMS) :: temp_start, temp_count
    integer i, ndims
    integer :: fh, vid, oldval

    request = MPI_REQUEST_NULL

    ierr = PIO_NOERR
    if(file%iosystem%ioproc) then
       iotype = File%iotype

       select case (iotype) 


       case default
          call bad_iotype(iotype,subname,241)

       end select
    endif  ! if (File%iosystem%IOproc)

    call check_netcdf(File, ierr,subname,246)
!  call mpi_barrier(file%iosystem%comp_comm, mpierr)
!  call CheckMPIReturn(subName,mpierr)

  end function WRITE_NFDARRAY_int
  ! TYPE real,int,double
!>
!! @private
!<
  integer function write_nfdarray_double (File,IOBUF,varDesc,iodesc,start,count, request) result(ierr)
    use nf_mod
    use pio_types, only : io_desc_t, var_desc_t, file_desc_t, iosystem_desc_t, pio_noerr, &
	pio_iotype_netcdf, pio_iotype_pnetcdf, pio_iotype_netcdf4p, pio_iotype_netcdf4c, pio_max_var_dims
    use pio_utils, only : check_netcdf, bad_iotype
    use alloc_mod, only: alloc_check
    use pio_support, only : Debug, DebugIO, piodie, checkmpireturn 

    use mpi !_EXTERNAL
    implicit none

    type (File_desc_t), intent(inout) :: File
    real(r8) , intent(in), target      :: IOBUF(:)
    type (var_desc_t), intent(in)     :: varDesc
    type (IO_desc_t), intent(in)      :: IODesc

    integer(pio_offset), intent(in) :: start(:), count(:)
    integer, intent(out) :: request


    character(len=*), parameter :: subName=modName//'::write_nfdarray_double'

    integer(i4) :: iotype, mpierr
    integer :: status(MPI_STATUS_SIZE)
    integer iobuf_size, max_iobuf_size
    real(r8) , pointer :: temp_iobuf(:)
    integer, dimension(PIO_MAX_VAR_DIMS) :: temp_start, temp_count
    integer i, ndims
    integer :: fh, vid, oldval

    request = MPI_REQUEST_NULL

    ierr = PIO_NOERR
    if(file%iosystem%ioproc) then
       iotype = File%iotype

       select case (iotype) 


       case default
          call bad_iotype(iotype,subname,241)

       end select
    endif  ! if (File%iosystem%IOproc)

    call check_netcdf(File, ierr,subname,246)
!  call mpi_barrier(file%iosystem%comp_comm, mpierr)
!  call CheckMPIReturn(subName,mpierr)

  end function WRITE_NFDARRAY_double



end module pionfwrite_mod
