
!===================================================
! DO NOT EDIT THIS FILE, it was generated using /home/santos/Utilities/genf90.pl 
! Any changes you make to this file may be lost
!===================================================

! Flag representing compiler support of Fortran 2003's
! ieee_arithmetic intrinsic module.




module shr_infnan_mod
!---------------------------------------------------------------------
! Module to test for IEEE Inf and NaN values, which also provides a
! method of setting +/-Inf and signaling or quiet NaN.
!
! All functions are elemental, and thus work on arrays.
!---------------------------------------------------------------------
! To test for these values, just call the corresponding function, e.g:
!
!   var_is_nan = shr_infnan_isnan(x)
!
! You can also use it on arrays:
!
!   array_contains_nan = any(shr_infnan_isnan(my_array))
!
!---------------------------------------------------------------------
! To generate these values, assign one of the provided derived-type
! variables to a real:
!
!   use shr_infnan_mod, only: nan => shr_infnan_nan, &
!                             inf => shr_infnan_inf, &
!                             assignment(=)
!   real(r4) :: my_nan
!   real(r8) :: my_inf_array(2,2)
!   my_nan = nan
!   my_inf_array = inf
!
! Keep in mind that "shr_infnan_nan" and "shr_infnan_inf" cannot be
! passed to functions that expect real arguments. To pass a real
! NaN, you will have to use shr_infnan_nan to set a local real of
! the correct kind.
!---------------------------------------------------------------------

use shr_kind_mod, only: &
     r4 => SHR_KIND_R4, &
     r8 => SHR_KIND_R8









! Integers of correct size for bit patterns below.
use shr_kind_mod, only: i4 => shr_kind_i4, i8 => shr_kind_i8



implicit none
private
save

! Test functions for NaN/Inf values.
public :: shr_infnan_isnan
public :: shr_infnan_isinf
public :: shr_infnan_isposinf
public :: shr_infnan_isneginf

! Locally defined isnan.
interface shr_infnan_isnan
   ! TYPE double,real
   module procedure shr_infnan_isnan_double
   ! TYPE double,real
   module procedure shr_infnan_isnan_real
end interface

interface shr_infnan_isinf
   ! TYPE double,real
   module procedure shr_infnan_isinf_double
   ! TYPE double,real
   module procedure shr_infnan_isinf_real
end interface

interface shr_infnan_isposinf
   ! TYPE double,real
   module procedure shr_infnan_isposinf_double
   ! TYPE double,real
   module procedure shr_infnan_isposinf_real
end interface

interface shr_infnan_isneginf
   ! TYPE double,real
   module procedure shr_infnan_isneginf_double
   ! TYPE double,real
   module procedure shr_infnan_isneginf_real
end interface

! Derived types for generation of NaN/Inf
! Even though there's no reason to "use" the types directly, some compilers
! might have trouble with an object being used without its type.
public :: shr_infnan_nan_type
public :: shr_infnan_inf_type
public :: assignment(=)
public :: shr_infnan_to_r4
public :: shr_infnan_to_r8

! Type representing Not A Number.
type :: shr_infnan_nan_type
   logical :: quiet = .false.
end type shr_infnan_nan_type

! Type representing +/-Infinity.
type :: shr_infnan_inf_type
   logical :: positive = .true.
end type shr_infnan_inf_type

! Allow assigning reals to NaN or Inf.
interface assignment(=)
   ! TYPE double,real
   ! DIMS 0,1,2,3,4,5,6,7
   module procedure set_nan_0d_double
   ! TYPE double,real
   ! DIMS 0,1,2,3,4,5,6,7
   module procedure set_nan_1d_double
   ! TYPE double,real
   ! DIMS 0,1,2,3,4,5,6,7
   module procedure set_nan_2d_double
   ! TYPE double,real
   ! DIMS 0,1,2,3,4,5,6,7
   module procedure set_nan_3d_double
   ! TYPE double,real
   ! DIMS 0,1,2,3,4,5,6,7
   module procedure set_nan_4d_double
   ! TYPE double,real
   ! DIMS 0,1,2,3,4,5,6,7
   module procedure set_nan_5d_double
   ! TYPE double,real
   ! DIMS 0,1,2,3,4,5,6,7
   module procedure set_nan_6d_double
   ! TYPE double,real
   ! DIMS 0,1,2,3,4,5,6,7
   module procedure set_nan_7d_double
   ! TYPE double,real
   ! DIMS 0,1,2,3,4,5,6,7
   module procedure set_nan_0d_real
   ! TYPE double,real
   ! DIMS 0,1,2,3,4,5,6,7
   module procedure set_nan_1d_real
   ! TYPE double,real
   ! DIMS 0,1,2,3,4,5,6,7
   module procedure set_nan_2d_real
   ! TYPE double,real
   ! DIMS 0,1,2,3,4,5,6,7
   module procedure set_nan_3d_real
   ! TYPE double,real
   ! DIMS 0,1,2,3,4,5,6,7
   module procedure set_nan_4d_real
   ! TYPE double,real
   ! DIMS 0,1,2,3,4,5,6,7
   module procedure set_nan_5d_real
   ! TYPE double,real
   ! DIMS 0,1,2,3,4,5,6,7
   module procedure set_nan_6d_real
   ! TYPE double,real
   ! DIMS 0,1,2,3,4,5,6,7
   module procedure set_nan_7d_real
   ! TYPE double,real
   ! DIMS 0,1,2,3,4,5,6,7
   module procedure set_inf_0d_double
   ! TYPE double,real
   ! DIMS 0,1,2,3,4,5,6,7
   module procedure set_inf_1d_double
   ! TYPE double,real
   ! DIMS 0,1,2,3,4,5,6,7
   module procedure set_inf_2d_double
   ! TYPE double,real
   ! DIMS 0,1,2,3,4,5,6,7
   module procedure set_inf_3d_double
   ! TYPE double,real
   ! DIMS 0,1,2,3,4,5,6,7
   module procedure set_inf_4d_double
   ! TYPE double,real
   ! DIMS 0,1,2,3,4,5,6,7
   module procedure set_inf_5d_double
   ! TYPE double,real
   ! DIMS 0,1,2,3,4,5,6,7
   module procedure set_inf_6d_double
   ! TYPE double,real
   ! DIMS 0,1,2,3,4,5,6,7
   module procedure set_inf_7d_double
   ! TYPE double,real
   ! DIMS 0,1,2,3,4,5,6,7
   module procedure set_inf_0d_real
   ! TYPE double,real
   ! DIMS 0,1,2,3,4,5,6,7
   module procedure set_inf_1d_real
   ! TYPE double,real
   ! DIMS 0,1,2,3,4,5,6,7
   module procedure set_inf_2d_real
   ! TYPE double,real
   ! DIMS 0,1,2,3,4,5,6,7
   module procedure set_inf_3d_real
   ! TYPE double,real
   ! DIMS 0,1,2,3,4,5,6,7
   module procedure set_inf_4d_real
   ! TYPE double,real
   ! DIMS 0,1,2,3,4,5,6,7
   module procedure set_inf_5d_real
   ! TYPE double,real
   ! DIMS 0,1,2,3,4,5,6,7
   module procedure set_inf_6d_real
   ! TYPE double,real
   ! DIMS 0,1,2,3,4,5,6,7
   module procedure set_inf_7d_real
end interface

! Conversion functions.
interface shr_infnan_to_r8
   module procedure nan_r8
   module procedure inf_r8
end interface

interface shr_infnan_to_r4
   module procedure nan_r4
   module procedure inf_r4
end interface

! Initialize objects of NaN/Inf type for other modules to use.

! Default NaN is signaling, but also provide snan and qnan to choose
! explicitly.
type(shr_infnan_nan_type), public, parameter :: shr_infnan_nan = &
     shr_infnan_nan_type(.false.)
type(shr_infnan_nan_type), public, parameter :: shr_infnan_snan = &
     shr_infnan_nan_type(.false.)
type(shr_infnan_nan_type), public, parameter :: shr_infnan_qnan = &
     shr_infnan_nan_type(.true.)

! Default Inf is positive, but provide posinf to go with neginf.
type(shr_infnan_inf_type), public, parameter :: shr_infnan_inf = &
     shr_infnan_inf_type(.true.)
type(shr_infnan_inf_type), public, parameter :: shr_infnan_posinf = &
     shr_infnan_inf_type(.true.)
type(shr_infnan_inf_type), public, parameter :: shr_infnan_neginf = &
     shr_infnan_inf_type(.false.)

! Bit patterns for implementation without ieee_arithmetic.
! Note that in order to satisfy gfortran's range check, we have to use
! ibset to set the sign bit from a BOZ pattern.
! Single precision.
integer(i4), parameter :: ssnan_pat = int(Z'7FA00000',i4)
integer(i4), parameter :: sqnan_pat = int(Z'7FC00000',i4)
integer(i4), parameter :: sposinf_pat = int(Z'7F800000',i4)
integer(i4), parameter :: sneginf_pat = ibset(sposinf_pat,bit_size(1_i4)-1)
! Double precision.
integer(i8), parameter :: dsnan_pat = int(Z'7FF4000000000000',i8)
integer(i8), parameter :: dqnan_pat = int(Z'7FF8000000000000',i8)
integer(i8), parameter :: dposinf_pat = int(Z'7FF0000000000000',i8)
integer(i8), parameter :: dneginf_pat = ibset(dposinf_pat,bit_size(1_i8)-1)

contains

!---------------------------------------------------------------------
! TEST FUNCTIONS
!---------------------------------------------------------------------
! The "isinf" function simply calls "isposinf" and "isneginf".
!---------------------------------------------------------------------

! TYPE double,real
elemental function shr_infnan_isinf_double(x) result(isinf)
  real(r8), intent(in) :: x
  logical :: isinf

  isinf = shr_infnan_isposinf(x) .or. shr_infnan_isneginf(x)

end function shr_infnan_isinf_double
! TYPE double,real
elemental function shr_infnan_isinf_real(x) result(isinf)
  real(r4), intent(in) :: x
  logical :: isinf

  isinf = shr_infnan_isposinf(x) .or. shr_infnan_isneginf(x)

end function shr_infnan_isinf_real

! Don't have ieee_arithmetic.


!---------------------------------------------------------------------
! The "isposinf" and "isneginf" functions just test against a known
! bit pattern if we don't have ieee_arithmetic.
!---------------------------------------------------------------------

! TYPE double,real
elemental function shr_infnan_isposinf_double(x) result(isposinf)
  real(r8), intent(in) :: x
  logical :: isposinf
  integer(i8), parameter :: posinf_pat = dposinf_pat

  isposinf = (x == transfer(posinf_pat,x))

end function shr_infnan_isposinf_double
! TYPE double,real
elemental function shr_infnan_isposinf_real(x) result(isposinf)
  real(r4), intent(in) :: x
  logical :: isposinf
  integer(i8), parameter :: posinf_pat = dposinf_pat

  isposinf = (x == transfer(posinf_pat,x))

end function shr_infnan_isposinf_real

! TYPE double,real
elemental function shr_infnan_isneginf_double(x) result(isneginf)
  real(r8), intent(in) :: x
  logical :: isneginf
  integer(i8), parameter :: neginf_pat = dneginf_pat

  isneginf = (x == transfer(neginf_pat,x))

end function shr_infnan_isneginf_double
! TYPE double,real
elemental function shr_infnan_isneginf_real(x) result(isneginf)
  real(r4), intent(in) :: x
  logical :: isneginf
  integer(i8), parameter :: neginf_pat = dneginf_pat

  isneginf = (x == transfer(neginf_pat,x))

end function shr_infnan_isneginf_real

! End ieee_arithmetic conditional.

!---------------------------------------------------------------------
! GENERATION FUNCTIONS
!---------------------------------------------------------------------
! Two approaches for generation of NaN and Inf values:
!   1. With Fortran 2003, use the ieee_value intrinsic to get a value
!      from the corresponding class. These are:
!       - ieee_signaling_nan
!       - ieee_quiet_nan
!       - ieee_positive_inf
!       - ieee_negative_inf
!   2. Without Fortran 2003, set the IEEE bit patterns directly.
!      Use BOZ literals to get an integer with the correct bit
!      pattern, then use "transfer" to transfer those bits into a
!      real.
!---------------------------------------------------------------------

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7
pure subroutine set_nan_0d_double(output, nan)
  integer(i8), parameter :: snan_pat = dsnan_pat
  integer(i8), parameter :: qnan_pat = dqnan_pat
  real(r8), intent(out) :: output
  type(shr_infnan_nan_type), intent(in) :: nan

  ! Use scalar temporary for performance reasons, to reduce the cost of
  ! the ieee_value call.
  real(r8) :: tmp

  if (nan%quiet) then
     tmp = transfer(qnan_pat, tmp)
  else
     tmp = transfer(snan_pat, tmp)
  end if

  output = tmp

end subroutine set_nan_0d_double
! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7
pure subroutine set_nan_1d_double(output, nan)
  integer(i8), parameter :: snan_pat = dsnan_pat
  integer(i8), parameter :: qnan_pat = dqnan_pat
  real(r8), intent(out) :: output(:)
  type(shr_infnan_nan_type), intent(in) :: nan

  ! Use scalar temporary for performance reasons, to reduce the cost of
  ! the ieee_value call.
  real(r8) :: tmp

  if (nan%quiet) then
     tmp = transfer(qnan_pat, tmp)
  else
     tmp = transfer(snan_pat, tmp)
  end if

  output = tmp

end subroutine set_nan_1d_double
! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7
pure subroutine set_nan_2d_double(output, nan)
  integer(i8), parameter :: snan_pat = dsnan_pat
  integer(i8), parameter :: qnan_pat = dqnan_pat
  real(r8), intent(out) :: output(:,:)
  type(shr_infnan_nan_type), intent(in) :: nan

  ! Use scalar temporary for performance reasons, to reduce the cost of
  ! the ieee_value call.
  real(r8) :: tmp

  if (nan%quiet) then
     tmp = transfer(qnan_pat, tmp)
  else
     tmp = transfer(snan_pat, tmp)
  end if

  output = tmp

end subroutine set_nan_2d_double
! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7
pure subroutine set_nan_3d_double(output, nan)
  integer(i8), parameter :: snan_pat = dsnan_pat
  integer(i8), parameter :: qnan_pat = dqnan_pat
  real(r8), intent(out) :: output(:,:,:)
  type(shr_infnan_nan_type), intent(in) :: nan

  ! Use scalar temporary for performance reasons, to reduce the cost of
  ! the ieee_value call.
  real(r8) :: tmp

  if (nan%quiet) then
     tmp = transfer(qnan_pat, tmp)
  else
     tmp = transfer(snan_pat, tmp)
  end if

  output = tmp

end subroutine set_nan_3d_double
! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7
pure subroutine set_nan_4d_double(output, nan)
  integer(i8), parameter :: snan_pat = dsnan_pat
  integer(i8), parameter :: qnan_pat = dqnan_pat
  real(r8), intent(out) :: output(:,:,:,:)
  type(shr_infnan_nan_type), intent(in) :: nan

  ! Use scalar temporary for performance reasons, to reduce the cost of
  ! the ieee_value call.
  real(r8) :: tmp

  if (nan%quiet) then
     tmp = transfer(qnan_pat, tmp)
  else
     tmp = transfer(snan_pat, tmp)
  end if

  output = tmp

end subroutine set_nan_4d_double
! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7
pure subroutine set_nan_5d_double(output, nan)
  integer(i8), parameter :: snan_pat = dsnan_pat
  integer(i8), parameter :: qnan_pat = dqnan_pat
  real(r8), intent(out) :: output(:,:,:,:,:)
  type(shr_infnan_nan_type), intent(in) :: nan

  ! Use scalar temporary for performance reasons, to reduce the cost of
  ! the ieee_value call.
  real(r8) :: tmp

  if (nan%quiet) then
     tmp = transfer(qnan_pat, tmp)
  else
     tmp = transfer(snan_pat, tmp)
  end if

  output = tmp

end subroutine set_nan_5d_double
! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7
pure subroutine set_nan_6d_double(output, nan)
  integer(i8), parameter :: snan_pat = dsnan_pat
  integer(i8), parameter :: qnan_pat = dqnan_pat
  real(r8), intent(out) :: output(:,:,:,:,:,:)
  type(shr_infnan_nan_type), intent(in) :: nan

  ! Use scalar temporary for performance reasons, to reduce the cost of
  ! the ieee_value call.
  real(r8) :: tmp

  if (nan%quiet) then
     tmp = transfer(qnan_pat, tmp)
  else
     tmp = transfer(snan_pat, tmp)
  end if

  output = tmp

end subroutine set_nan_6d_double
! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7
pure subroutine set_nan_7d_double(output, nan)
  integer(i8), parameter :: snan_pat = dsnan_pat
  integer(i8), parameter :: qnan_pat = dqnan_pat
  real(r8), intent(out) :: output(:,:,:,:,:,:,:)
  type(shr_infnan_nan_type), intent(in) :: nan

  ! Use scalar temporary for performance reasons, to reduce the cost of
  ! the ieee_value call.
  real(r8) :: tmp

  if (nan%quiet) then
     tmp = transfer(qnan_pat, tmp)
  else
     tmp = transfer(snan_pat, tmp)
  end if

  output = tmp

end subroutine set_nan_7d_double
! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7
pure subroutine set_nan_0d_real(output, nan)
  integer(i8), parameter :: snan_pat = dsnan_pat
  integer(i8), parameter :: qnan_pat = dqnan_pat
  real(r4), intent(out) :: output
  type(shr_infnan_nan_type), intent(in) :: nan

  ! Use scalar temporary for performance reasons, to reduce the cost of
  ! the ieee_value call.
  real(r4) :: tmp

  if (nan%quiet) then
     tmp = transfer(qnan_pat, tmp)
  else
     tmp = transfer(snan_pat, tmp)
  end if

  output = tmp

end subroutine set_nan_0d_real
! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7
pure subroutine set_nan_1d_real(output, nan)
  integer(i8), parameter :: snan_pat = dsnan_pat
  integer(i8), parameter :: qnan_pat = dqnan_pat
  real(r4), intent(out) :: output(:)
  type(shr_infnan_nan_type), intent(in) :: nan

  ! Use scalar temporary for performance reasons, to reduce the cost of
  ! the ieee_value call.
  real(r4) :: tmp

  if (nan%quiet) then
     tmp = transfer(qnan_pat, tmp)
  else
     tmp = transfer(snan_pat, tmp)
  end if

  output = tmp

end subroutine set_nan_1d_real
! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7
pure subroutine set_nan_2d_real(output, nan)
  integer(i8), parameter :: snan_pat = dsnan_pat
  integer(i8), parameter :: qnan_pat = dqnan_pat
  real(r4), intent(out) :: output(:,:)
  type(shr_infnan_nan_type), intent(in) :: nan

  ! Use scalar temporary for performance reasons, to reduce the cost of
  ! the ieee_value call.
  real(r4) :: tmp

  if (nan%quiet) then
     tmp = transfer(qnan_pat, tmp)
  else
     tmp = transfer(snan_pat, tmp)
  end if

  output = tmp

end subroutine set_nan_2d_real
! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7
pure subroutine set_nan_3d_real(output, nan)
  integer(i8), parameter :: snan_pat = dsnan_pat
  integer(i8), parameter :: qnan_pat = dqnan_pat
  real(r4), intent(out) :: output(:,:,:)
  type(shr_infnan_nan_type), intent(in) :: nan

  ! Use scalar temporary for performance reasons, to reduce the cost of
  ! the ieee_value call.
  real(r4) :: tmp

  if (nan%quiet) then
     tmp = transfer(qnan_pat, tmp)
  else
     tmp = transfer(snan_pat, tmp)
  end if

  output = tmp

end subroutine set_nan_3d_real
! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7
pure subroutine set_nan_4d_real(output, nan)
  integer(i8), parameter :: snan_pat = dsnan_pat
  integer(i8), parameter :: qnan_pat = dqnan_pat
  real(r4), intent(out) :: output(:,:,:,:)
  type(shr_infnan_nan_type), intent(in) :: nan

  ! Use scalar temporary for performance reasons, to reduce the cost of
  ! the ieee_value call.
  real(r4) :: tmp

  if (nan%quiet) then
     tmp = transfer(qnan_pat, tmp)
  else
     tmp = transfer(snan_pat, tmp)
  end if

  output = tmp

end subroutine set_nan_4d_real
! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7
pure subroutine set_nan_5d_real(output, nan)
  integer(i8), parameter :: snan_pat = dsnan_pat
  integer(i8), parameter :: qnan_pat = dqnan_pat
  real(r4), intent(out) :: output(:,:,:,:,:)
  type(shr_infnan_nan_type), intent(in) :: nan

  ! Use scalar temporary for performance reasons, to reduce the cost of
  ! the ieee_value call.
  real(r4) :: tmp

  if (nan%quiet) then
     tmp = transfer(qnan_pat, tmp)
  else
     tmp = transfer(snan_pat, tmp)
  end if

  output = tmp

end subroutine set_nan_5d_real
! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7
pure subroutine set_nan_6d_real(output, nan)
  integer(i8), parameter :: snan_pat = dsnan_pat
  integer(i8), parameter :: qnan_pat = dqnan_pat
  real(r4), intent(out) :: output(:,:,:,:,:,:)
  type(shr_infnan_nan_type), intent(in) :: nan

  ! Use scalar temporary for performance reasons, to reduce the cost of
  ! the ieee_value call.
  real(r4) :: tmp

  if (nan%quiet) then
     tmp = transfer(qnan_pat, tmp)
  else
     tmp = transfer(snan_pat, tmp)
  end if

  output = tmp

end subroutine set_nan_6d_real
! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7
pure subroutine set_nan_7d_real(output, nan)
  integer(i8), parameter :: snan_pat = dsnan_pat
  integer(i8), parameter :: qnan_pat = dqnan_pat
  real(r4), intent(out) :: output(:,:,:,:,:,:,:)
  type(shr_infnan_nan_type), intent(in) :: nan

  ! Use scalar temporary for performance reasons, to reduce the cost of
  ! the ieee_value call.
  real(r4) :: tmp

  if (nan%quiet) then
     tmp = transfer(qnan_pat, tmp)
  else
     tmp = transfer(snan_pat, tmp)
  end if

  output = tmp

end subroutine set_nan_7d_real

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7
pure subroutine set_inf_0d_double(output, inf)
  integer(i8), parameter :: posinf_pat = dposinf_pat
  integer(i8), parameter :: neginf_pat = dneginf_pat
  real(r8), intent(out) :: output
  type(shr_infnan_inf_type), intent(in) :: inf

  ! Use scalar temporary for performance reasons, to reduce the cost of
  ! the ieee_value call.
  real(r8) :: tmp

  if (inf%positive) then
     tmp = transfer(posinf_pat, tmp)
  else
     tmp = transfer(neginf_pat, tmp)
  end if

  output = tmp

end subroutine set_inf_0d_double
! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7
pure subroutine set_inf_1d_double(output, inf)
  integer(i8), parameter :: posinf_pat = dposinf_pat
  integer(i8), parameter :: neginf_pat = dneginf_pat
  real(r8), intent(out) :: output(:)
  type(shr_infnan_inf_type), intent(in) :: inf

  ! Use scalar temporary for performance reasons, to reduce the cost of
  ! the ieee_value call.
  real(r8) :: tmp

  if (inf%positive) then
     tmp = transfer(posinf_pat, tmp)
  else
     tmp = transfer(neginf_pat, tmp)
  end if

  output = tmp

end subroutine set_inf_1d_double
! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7
pure subroutine set_inf_2d_double(output, inf)
  integer(i8), parameter :: posinf_pat = dposinf_pat
  integer(i8), parameter :: neginf_pat = dneginf_pat
  real(r8), intent(out) :: output(:,:)
  type(shr_infnan_inf_type), intent(in) :: inf

  ! Use scalar temporary for performance reasons, to reduce the cost of
  ! the ieee_value call.
  real(r8) :: tmp

  if (inf%positive) then
     tmp = transfer(posinf_pat, tmp)
  else
     tmp = transfer(neginf_pat, tmp)
  end if

  output = tmp

end subroutine set_inf_2d_double
! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7
pure subroutine set_inf_3d_double(output, inf)
  integer(i8), parameter :: posinf_pat = dposinf_pat
  integer(i8), parameter :: neginf_pat = dneginf_pat
  real(r8), intent(out) :: output(:,:,:)
  type(shr_infnan_inf_type), intent(in) :: inf

  ! Use scalar temporary for performance reasons, to reduce the cost of
  ! the ieee_value call.
  real(r8) :: tmp

  if (inf%positive) then
     tmp = transfer(posinf_pat, tmp)
  else
     tmp = transfer(neginf_pat, tmp)
  end if

  output = tmp

end subroutine set_inf_3d_double
! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7
pure subroutine set_inf_4d_double(output, inf)
  integer(i8), parameter :: posinf_pat = dposinf_pat
  integer(i8), parameter :: neginf_pat = dneginf_pat
  real(r8), intent(out) :: output(:,:,:,:)
  type(shr_infnan_inf_type), intent(in) :: inf

  ! Use scalar temporary for performance reasons, to reduce the cost of
  ! the ieee_value call.
  real(r8) :: tmp

  if (inf%positive) then
     tmp = transfer(posinf_pat, tmp)
  else
     tmp = transfer(neginf_pat, tmp)
  end if

  output = tmp

end subroutine set_inf_4d_double
! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7
pure subroutine set_inf_5d_double(output, inf)
  integer(i8), parameter :: posinf_pat = dposinf_pat
  integer(i8), parameter :: neginf_pat = dneginf_pat
  real(r8), intent(out) :: output(:,:,:,:,:)
  type(shr_infnan_inf_type), intent(in) :: inf

  ! Use scalar temporary for performance reasons, to reduce the cost of
  ! the ieee_value call.
  real(r8) :: tmp

  if (inf%positive) then
     tmp = transfer(posinf_pat, tmp)
  else
     tmp = transfer(neginf_pat, tmp)
  end if

  output = tmp

end subroutine set_inf_5d_double
! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7
pure subroutine set_inf_6d_double(output, inf)
  integer(i8), parameter :: posinf_pat = dposinf_pat
  integer(i8), parameter :: neginf_pat = dneginf_pat
  real(r8), intent(out) :: output(:,:,:,:,:,:)
  type(shr_infnan_inf_type), intent(in) :: inf

  ! Use scalar temporary for performance reasons, to reduce the cost of
  ! the ieee_value call.
  real(r8) :: tmp

  if (inf%positive) then
     tmp = transfer(posinf_pat, tmp)
  else
     tmp = transfer(neginf_pat, tmp)
  end if

  output = tmp

end subroutine set_inf_6d_double
! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7
pure subroutine set_inf_7d_double(output, inf)
  integer(i8), parameter :: posinf_pat = dposinf_pat
  integer(i8), parameter :: neginf_pat = dneginf_pat
  real(r8), intent(out) :: output(:,:,:,:,:,:,:)
  type(shr_infnan_inf_type), intent(in) :: inf

  ! Use scalar temporary for performance reasons, to reduce the cost of
  ! the ieee_value call.
  real(r8) :: tmp

  if (inf%positive) then
     tmp = transfer(posinf_pat, tmp)
  else
     tmp = transfer(neginf_pat, tmp)
  end if

  output = tmp

end subroutine set_inf_7d_double
! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7
pure subroutine set_inf_0d_real(output, inf)
  integer(i8), parameter :: posinf_pat = dposinf_pat
  integer(i8), parameter :: neginf_pat = dneginf_pat
  real(r4), intent(out) :: output
  type(shr_infnan_inf_type), intent(in) :: inf

  ! Use scalar temporary for performance reasons, to reduce the cost of
  ! the ieee_value call.
  real(r4) :: tmp

  if (inf%positive) then
     tmp = transfer(posinf_pat, tmp)
  else
     tmp = transfer(neginf_pat, tmp)
  end if

  output = tmp

end subroutine set_inf_0d_real
! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7
pure subroutine set_inf_1d_real(output, inf)
  integer(i8), parameter :: posinf_pat = dposinf_pat
  integer(i8), parameter :: neginf_pat = dneginf_pat
  real(r4), intent(out) :: output(:)
  type(shr_infnan_inf_type), intent(in) :: inf

  ! Use scalar temporary for performance reasons, to reduce the cost of
  ! the ieee_value call.
  real(r4) :: tmp

  if (inf%positive) then
     tmp = transfer(posinf_pat, tmp)
  else
     tmp = transfer(neginf_pat, tmp)
  end if

  output = tmp

end subroutine set_inf_1d_real
! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7
pure subroutine set_inf_2d_real(output, inf)
  integer(i8), parameter :: posinf_pat = dposinf_pat
  integer(i8), parameter :: neginf_pat = dneginf_pat
  real(r4), intent(out) :: output(:,:)
  type(shr_infnan_inf_type), intent(in) :: inf

  ! Use scalar temporary for performance reasons, to reduce the cost of
  ! the ieee_value call.
  real(r4) :: tmp

  if (inf%positive) then
     tmp = transfer(posinf_pat, tmp)
  else
     tmp = transfer(neginf_pat, tmp)
  end if

  output = tmp

end subroutine set_inf_2d_real
! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7
pure subroutine set_inf_3d_real(output, inf)
  integer(i8), parameter :: posinf_pat = dposinf_pat
  integer(i8), parameter :: neginf_pat = dneginf_pat
  real(r4), intent(out) :: output(:,:,:)
  type(shr_infnan_inf_type), intent(in) :: inf

  ! Use scalar temporary for performance reasons, to reduce the cost of
  ! the ieee_value call.
  real(r4) :: tmp

  if (inf%positive) then
     tmp = transfer(posinf_pat, tmp)
  else
     tmp = transfer(neginf_pat, tmp)
  end if

  output = tmp

end subroutine set_inf_3d_real
! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7
pure subroutine set_inf_4d_real(output, inf)
  integer(i8), parameter :: posinf_pat = dposinf_pat
  integer(i8), parameter :: neginf_pat = dneginf_pat
  real(r4), intent(out) :: output(:,:,:,:)
  type(shr_infnan_inf_type), intent(in) :: inf

  ! Use scalar temporary for performance reasons, to reduce the cost of
  ! the ieee_value call.
  real(r4) :: tmp

  if (inf%positive) then
     tmp = transfer(posinf_pat, tmp)
  else
     tmp = transfer(neginf_pat, tmp)
  end if

  output = tmp

end subroutine set_inf_4d_real
! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7
pure subroutine set_inf_5d_real(output, inf)
  integer(i8), parameter :: posinf_pat = dposinf_pat
  integer(i8), parameter :: neginf_pat = dneginf_pat
  real(r4), intent(out) :: output(:,:,:,:,:)
  type(shr_infnan_inf_type), intent(in) :: inf

  ! Use scalar temporary for performance reasons, to reduce the cost of
  ! the ieee_value call.
  real(r4) :: tmp

  if (inf%positive) then
     tmp = transfer(posinf_pat, tmp)
  else
     tmp = transfer(neginf_pat, tmp)
  end if

  output = tmp

end subroutine set_inf_5d_real
! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7
pure subroutine set_inf_6d_real(output, inf)
  integer(i8), parameter :: posinf_pat = dposinf_pat
  integer(i8), parameter :: neginf_pat = dneginf_pat
  real(r4), intent(out) :: output(:,:,:,:,:,:)
  type(shr_infnan_inf_type), intent(in) :: inf

  ! Use scalar temporary for performance reasons, to reduce the cost of
  ! the ieee_value call.
  real(r4) :: tmp

  if (inf%positive) then
     tmp = transfer(posinf_pat, tmp)
  else
     tmp = transfer(neginf_pat, tmp)
  end if

  output = tmp

end subroutine set_inf_6d_real
! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7
pure subroutine set_inf_7d_real(output, inf)
  integer(i8), parameter :: posinf_pat = dposinf_pat
  integer(i8), parameter :: neginf_pat = dneginf_pat
  real(r4), intent(out) :: output(:,:,:,:,:,:,:)
  type(shr_infnan_inf_type), intent(in) :: inf

  ! Use scalar temporary for performance reasons, to reduce the cost of
  ! the ieee_value call.
  real(r4) :: tmp

  if (inf%positive) then
     tmp = transfer(posinf_pat, tmp)
  else
     tmp = transfer(neginf_pat, tmp)
  end if

  output = tmp

end subroutine set_inf_7d_real

!---------------------------------------------------------------------
! CONVERSION INTERFACES.
!---------------------------------------------------------------------
! Function methods to get reals from nan/inf types.
!---------------------------------------------------------------------

pure function nan_r8(nan) result(output)
  class(shr_infnan_nan_type), intent(in) :: nan
  real(r8) :: output

  output = nan

end function nan_r8

pure function nan_r4(nan) result(output)
  class(shr_infnan_nan_type), intent(in) :: nan
  real(r4) :: output

  output = nan

end function nan_r4

pure function inf_r8(inf) result(output)
  class(shr_infnan_inf_type), intent(in) :: inf
  real(r8) :: output

  output = inf

end function inf_r8

pure function inf_r4(inf) result(output)
  class(shr_infnan_inf_type), intent(in) :: inf
  real(r4) :: output

  output = inf

end function inf_r4

end module shr_infnan_mod
