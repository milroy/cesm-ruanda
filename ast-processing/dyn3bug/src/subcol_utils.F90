!===================================================
! DO NOT EDIT THIS FILE, it was generated using ../../../../../../tools/cprnc/genf90/genf90.pl 
! Any changes you make to this file may be lost
!===================================================
 module subcol_utils
   !---------------------------------------------------------------------------
   ! Purpose:
   !
   ! Provides utilities to support subcolumns
   !
   !---------------------------------------------------------------------------

   use shr_kind_mod,    only: r8=>shr_kind_r8, r4=>shr_kind_r4, i4=>shr_kind_i4
   use infnan,          only: nan, assignment(=)
   use physics_types,   only: physics_state, physics_ptend, physics_tend, physics_tend_alloc, physics_state_alloc
   use ppgrid,          only: pcols, psubcols, pver
   use constituents,    only: pcnst
   use abortutils,      only: endrun
   use pio,             only: var_desc_t

   implicit none

   private
   save

   !! Private variable to provide default packing and unpacking of fields
   !! for use in restart functionality. Allocated as (pcols, begchunk:endchunk)
   integer, target, allocatable :: nsubcol2d(:,:)
   integer, target, allocatable :: indcol2d(:,:)
   integer, target, allocatable :: filter2d(:,:)
   real(r8),target, allocatable :: weight2d(:,:)
   logical :: weight_set, filter_set

   !! The active subcolumn scheme
   character(len=16) :: subcol_scheme = 'off'

   !! Public interface functions which do not depend on the subcolumn scheme

   public :: subcol_utils_init       ! Initialize module data (e.g., nsubcol2d)
   public :: subcol_get_nsubcol      ! Copy chunk from nsubcol2d
   public :: subcol_set_nsubcol      ! Copy chunk to nsubcol2d
   public :: subcol_get_indcol       ! Copy chunk from indcol2d
   public :: subcol_get_filter       ! return the filter values
   public :: subcol_set_filter       ! set the filter values
   public :: subcol_get_weight       ! return the weight values
   public :: subcol_set_weight       ! set the weight values

   public :: subcol_field_copy       ! copy a physics buffer field into one with subcolumn dimensions
   public :: subcol_ptend_copy       ! copy a physics_ptend object into one with subcolumn dimensions
   public :: subcol_set_subcols      ! set nsubcols and copy state & tend objects into one with subcolumn dimensions

   public :: subcol_field_avg_shr    ! Average subcol fields back into GBA fields
   public :: subcol_ptend_avg_shr    ! average subcolumn ptend to grid ptend

   public :: subcol_field_get_firstsubcol  ! Retrieve the first subcolumn and assign to grid
   public :: subcol_ptend_get_firstsubcol  ! retrieve the first subcolumn from the ptend fields and assign to grid ptend

   public :: subcol_unpack           ! Unpack a subcolumn field
   public :: subcol_pack             ! Pack a subcolumn field

   public :: subcol_utils_init_restart     ! Initialize restart with subcolumn specific fields
   public :: subcol_utils_read_restart     ! Read subcolumn specific fields from restart
   public :: subcol_utils_write_restart    ! Write subcolumn specific fields for restart
   public :: is_filter_set           ! True if filters for averaging have been set
   public :: is_weight_set           ! True if weights for averaging have been set
   public :: is_subcol_on            ! true is any subcol_scheme other than "off" is set
   public :: subcol_get_scheme       ! Return the active subcolumn scheme name
   public :: subcol_utils_readnl     ! Set the active scheme based on namelist

   interface subcol_field_avg_shr
      ! TYPE int,double,real
      ! DIMS 1,2
      module procedure subcol_field_avg_shr_1dint
      ! TYPE int,double,real
      ! DIMS 1,2
      module procedure subcol_field_avg_shr_2dint
      ! TYPE int,double,real
      ! DIMS 1,2
      module procedure subcol_field_avg_shr_1ddouble
      ! TYPE int,double,real
      ! DIMS 1,2
      module procedure subcol_field_avg_shr_2ddouble
      ! TYPE int,double,real
      ! DIMS 1,2
      module procedure subcol_field_avg_shr_1dreal
      ! TYPE int,double,real
      ! DIMS 1,2
      module procedure subcol_field_avg_shr_2dreal
   end interface

   interface subcol_avg_inter
      ! TYPE int,double,real
      module procedure subcol_avg_inter_int
      ! TYPE int,double,real
      module procedure subcol_avg_inter_double
      ! TYPE int,double,real
      module procedure subcol_avg_inter_real
   end interface

   interface subcol_avg
      ! TYPE int,double,real
      module procedure subcol_avg_int
      ! TYPE int,double,real
      module procedure subcol_avg_double
      ! TYPE int,double,real
      module procedure subcol_avg_real
   end interface

   interface subcol_field_get_firstsubcol
      ! TYPE int,double,real
      ! DIMS 1,2
      module procedure subcol_field_get_firstsubcol_1dint
      ! TYPE int,double,real
      ! DIMS 1,2
      module procedure subcol_field_get_firstsubcol_2dint
      ! TYPE int,double,real
      ! DIMS 1,2
      module procedure subcol_field_get_firstsubcol_1ddouble
      ! TYPE int,double,real
      ! DIMS 1,2
      module procedure subcol_field_get_firstsubcol_2ddouble
      ! TYPE int,double,real
      ! DIMS 1,2
      module procedure subcol_field_get_firstsubcol_1dreal
      ! TYPE int,double,real
      ! DIMS 1,2
      module procedure subcol_field_get_firstsubcol_2dreal
   end interface

   interface subcol_state_field_copy
      ! TYPE double
      ! DIMS 1,2,3
      module procedure subcol_state_field_copy_1ddouble
      ! TYPE double
      ! DIMS 1,2,3
      module procedure subcol_state_field_copy_2ddouble
      ! TYPE double
      ! DIMS 1,2,3
      module procedure subcol_state_field_copy_3ddouble
   end interface

   interface subcol_field_copy
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5
      module procedure subcol_field_copy_1dint
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5
      module procedure subcol_field_copy_2dint
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5
      module procedure subcol_field_copy_3dint
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5
      module procedure subcol_field_copy_4dint
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5
      module procedure subcol_field_copy_5dint
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5
      module procedure subcol_field_copy_1ddouble
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5
      module procedure subcol_field_copy_2ddouble
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5
      module procedure subcol_field_copy_3ddouble
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5
      module procedure subcol_field_copy_4ddouble
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5
      module procedure subcol_field_copy_5ddouble
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5
      module procedure subcol_field_copy_1dreal
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5
      module procedure subcol_field_copy_2dreal
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5
      module procedure subcol_field_copy_3dreal
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5
      module procedure subcol_field_copy_4dreal
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5
      module procedure subcol_field_copy_5dreal
   end interface

   interface subcol_pack
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5,6
      module procedure subcol_pack_1d_int
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5,6
      module procedure subcol_pack_2d_int
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5,6
      module procedure subcol_pack_3d_int
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5,6
      module procedure subcol_pack_4d_int
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5,6
      module procedure subcol_pack_5d_int
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5,6
      module procedure subcol_pack_6d_int
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5,6
      module procedure subcol_pack_1d_double
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5,6
      module procedure subcol_pack_2d_double
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5,6
      module procedure subcol_pack_3d_double
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5,6
      module procedure subcol_pack_4d_double
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5,6
      module procedure subcol_pack_5d_double
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5,6
      module procedure subcol_pack_6d_double
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5,6
      module procedure subcol_pack_1d_real
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5,6
      module procedure subcol_pack_2d_real
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5,6
      module procedure subcol_pack_3d_real
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5,6
      module procedure subcol_pack_4d_real
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5,6
      module procedure subcol_pack_5d_real
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5,6
      module procedure subcol_pack_6d_real
   end interface

   interface subcol_unpack
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5,6
      module procedure subcol_unpack_1d_int
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5,6
      module procedure subcol_unpack_2d_int
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5,6
      module procedure subcol_unpack_3d_int
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5,6
      module procedure subcol_unpack_4d_int
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5,6
      module procedure subcol_unpack_5d_int
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5,6
      module procedure subcol_unpack_6d_int
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5,6
      module procedure subcol_unpack_1d_double
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5,6
      module procedure subcol_unpack_2d_double
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5,6
      module procedure subcol_unpack_3d_double
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5,6
      module procedure subcol_unpack_4d_double
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5,6
      module procedure subcol_unpack_5d_double
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5,6
      module procedure subcol_unpack_6d_double
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5,6
      module procedure subcol_unpack_1d_real
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5,6
      module procedure subcol_unpack_2d_real
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5,6
      module procedure subcol_unpack_3d_real
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5,6
      module procedure subcol_unpack_4d_real
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5,6
      module procedure subcol_unpack_5d_real
      ! TYPE int,double,real
      ! DIMS 1,2,3,4,5,6
      module procedure subcol_unpack_6d_real
   end interface

   type(var_desc_t) :: nsubcol_desc, weight2d_desc, filter2d_desc

   integer :: ret_nan_int
   real(r8):: ret_nan_double
   real(r4):: ret_nan_real

   integer :: fillval_int
   real(r8):: fillval_double
   real(r4):: fillval_real

contains

   subroutine subcol_allocate_internal()
      use ppgrid,         only: begchunk, endchunk
   !-----------------------------------------------------------------------
   ! Allocate nsubcol2d and indcol2d
   !-----------------------------------------------------------------------
      if (allocated(nsubcol2d)) then
         deallocate(nsubcol2d)
      end if
      allocate(nsubcol2d(pcols, begchunk:endchunk))
      nsubcol2d = 0

      if (allocated(indcol2d)) then
         deallocate(indcol2d)
      end if
      allocate(indcol2d(pcols*psubcols, begchunk:endchunk))
      indcol2d = 0

      if (allocated(filter2d)) then
         deallocate(filter2d)
      end if
      allocate(filter2d(pcols*psubcols, begchunk:endchunk))
      filter2d = 0

      if (allocated(weight2d)) then
         deallocate(weight2d)
      end if
      allocate(weight2d(pcols*psubcols, begchunk:endchunk))
      weight2d = 0._r8

    end subroutine subcol_allocate_internal

   subroutine subcol_utils_init(subcol_scheme_init)
   !-----------------------------------------------------------------------
   ! Initialize the nsubcol module variable
   !-----------------------------------------------------------------------
 
      character(len=*), optional, intent(in) :: subcol_scheme_init ! Name of subcolumn generator
      integer :: ierr

      call subcol_allocate_internal()

      ret_nan_int    = 0
      ret_nan_double = nan
      ret_nan_real   = nan

      fillval_int    = 0
      fillval_double = 0._r8
      fillval_real   = 0._r4
 
      weight_set = .false.
      filter_set = .false.

   end subroutine subcol_utils_init

! Subprogram not used    subroutine subcol_get_nsubcol(lchnk, nsubcol)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Retrieve a chunk from the nsubcol module variable
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used      integer,    intent(in)    :: lchnk
! Subprogram not used      integer,    intent(out)   :: nsubcol(:)
! Subprogram not used 
! Subprogram not used      if (.not. allocated(nsubcol2d)) then
! Subprogram not used        call endrun('subcol_get_nsubcol: nsubcol2d not allocated')
! Subprogram not used      end if
! Subprogram not used      nsubcol(:) = nsubcol2d(:,lchnk)
! Subprogram not used    end subroutine subcol_get_nsubcol

! Subprogram not used    subroutine subcol_get_indcol(lchnk, indcol)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Retrieve a chunk from the nsubcol module variable
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used      integer,    intent(in)    :: lchnk
! Subprogram not used      integer,    intent(out)   :: indcol(:)
! Subprogram not used 
! Subprogram not used      if (.not. allocated(indcol2d)) then
! Subprogram not used        call endrun('subcol_get_indcol: indcol2d not allocated')
! Subprogram not used      end if
! Subprogram not used      indcol(:) = indcol2d(:,lchnk)
! Subprogram not used   end subroutine subcol_get_indcol

! Subprogram not used    subroutine subcol_get_filter(lchnk, filter)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Retrieve the filter module variable
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used      integer,    intent(in)    :: lchnk
! Subprogram not used      integer,    intent(out)   :: filter(:)
! Subprogram not used 
! Subprogram not used      filter(:) = filter2d(:,lchnk)
! Subprogram not used    end subroutine subcol_get_filter

! Subprogram not used    subroutine subcol_get_weight(lchnk, weight)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Retrieve the weight module variable
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used      integer,    intent(in)    :: lchnk
! Subprogram not used      real(r8),   intent(out)   :: weight(:)
! Subprogram not used 
! Subprogram not used      weight(:) = weight2d(:,lchnk)
! Subprogram not used    end subroutine subcol_get_weight

! Subprogram not used    integer function subcol_get_ncol(lchnk) result(ncol)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Compute the number of (sub)columns for a chunk
! Subprogram not used    ! NB: This is considered an internal function so it can use nsubcol2d
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used      integer,    intent(in)    :: lchnk
! Subprogram not used 
! Subprogram not used      ncol = sum(nsubcol2d(:,lchnk))
! Subprogram not used 
! Subprogram not used    end function subcol_get_ncol

! Subprogram not used    subroutine subcol_set_nsubcol(lchnk, ngrdcol, nsubcol)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Set a chunk of the nsubcol module variable
! Subprogram not used    ! Also, recompute indcol for lchnk
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer,    intent(in)    :: lchnk
! Subprogram not used       integer,    intent(in)    :: ngrdcol
! Subprogram not used       integer,    intent(in)    :: nsubcol(:)
! Subprogram not used 
! Subprogram not used       integer                   :: i, j, indx
! Subprogram not used 
! Subprogram not used       if (any(nsubcol(:) > psubcols)) then
! Subprogram not used          call endrun('subcol_set_nsubcol: psubcols not set large enough to hold the number of subcolumns requested')
! Subprogram not used       end if
! Subprogram not used       if (any(nsubcol(:) < 0)) then
! Subprogram not used          call endrun('subcol_set_nsubcol: nsubcols must be non-negative')
! Subprogram not used       end if
! Subprogram not used       if (ngrdcol < pcols) then
! Subprogram not used          if (any(nsubcol(ngrdcol+1:) > 0)) then
! Subprogram not used             call endrun('subcol_set_nsubcol: Cannot set subcolumns for columns past ngrdcol')
! Subprogram not used          end if
! Subprogram not used       end if
! Subprogram not used       nsubcol2d(:, lchnk) = nsubcol(:)
! Subprogram not used       ! Recalculate indcol for the chunk
! Subprogram not used       indx = 1
! Subprogram not used       do i = 1, pcols
! Subprogram not used          do j = 1, nsubcol2d(i, lchnk)
! Subprogram not used             indcol2d(indx, lchnk) = i
! Subprogram not used             indx = indx + 1
! Subprogram not used          end do
! Subprogram not used       end do
! Subprogram not used       ! Fill with zeros
! Subprogram not used       if (indx <= pcols * psubcols) then
! Subprogram not used          indcol2d(indx:pcols*psubcols, lchnk) = 0
! Subprogram not used       end if
! Subprogram not used    end subroutine subcol_set_nsubcol

! Subprogram not used    subroutine subcol_set_filter(lchnk, filter)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Set the filter module variable
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used      integer,    intent(in)    :: lchnk
! Subprogram not used      integer,    intent(in)    :: filter(:)
! Subprogram not used 
! Subprogram not used      filter2d(:,lchnk) = filter(:)
! Subprogram not used      filter_set        = .true.
! Subprogram not used    end subroutine subcol_set_filter

! Subprogram not used    subroutine subcol_set_weight(lchnk, weight)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Set the weight module variable
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used      integer,    intent(in)    :: lchnk
! Subprogram not used      real(r8),   intent(in)    :: weight(:)
! Subprogram not used 
! Subprogram not used      weight2d(:,lchnk) = weight(:)
! Subprogram not used      weight_set        = .true.
! Subprogram not used    end subroutine subcol_set_weight

! Subprogram not used    logical function is_weight_set()
! Subprogram not used       is_weight_set=weight_set 
! Subprogram not used    end function is_weight_set

! Subprogram not used    logical function is_filter_set()
! Subprogram not used       is_filter_set=filter_set 
! Subprogram not used    end function is_filter_set

   logical function is_subcol_on()
      is_subcol_on = (trim(subcol_scheme) /= 'off')
   end function is_subcol_on

   character(len=16) function subcol_get_scheme()
      subcol_get_scheme = trim(subcol_scheme)
   end function subcol_get_scheme

   subroutine subcol_utils_readnl(nlfile)
      use namelist_utils,  only: find_group_name
      use units,           only: getunit, freeunit
      use spmd_utils,      only: masterproc, mpi_character, masterprocid, mpicom
      
      character(len=*), intent(in) :: nlfile  ! filepath for file containing namelist input

      ! Local variables
      integer :: unitn, ierr

      namelist /subcol_nl/ subcol_scheme

      if (masterproc) then
         unitn = getunit()
         open( unitn, file=trim(nlfile), status='old' )
         call find_group_name(unitn, 'subcol_nl', status=ierr)
         if (ierr == 0) then
            read(unitn, subcol_nl, iostat=ierr)
            if (ierr /= 0) then
               call endrun('subcol_readnl: ERROR reading namelist')
            end if
         end if
         close(unitn)
         call freeunit(unitn)
      end if

      ! Broadcast namelist variables
      call mpi_bcast(subcol_scheme, len(subcol_scheme), mpi_character, masterprocid, mpicom, ierr)

   end subroutine subcol_utils_readnl

   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5
! Subprogram not used    subroutine subcol_field_copy_1dint (field, lchnk, field_sc)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Copy a pbuf field dimensioned pcols to one with pcols*psubcols and fill appropriately
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer(i4),          intent(in)      :: field(:)
! Subprogram not used       integer,          intent(in)      :: lchnk
! Subprogram not used       integer(i4),          intent(out)     :: field_sc(:)   ! intent out
! Subprogram not used 
! Subprogram not used       ! Local Variables
! Subprogram not used       integer                           :: ncol
! Subprogram not used       integer                           :: indcol(pcols*psubcols)
! Subprogram not used       integer :: i, indx, j
! Subprogram not used 
! Subprogram not used       if (size(field,dim=1) .ne. pcols) then
! Subprogram not used          call endrun('subcol_field_copy error: only fields with first dimension pcols may use this routine')
! Subprogram not used       end if
! Subprogram not used 
! Subprogram not used       field_sc = fillval_int
! Subprogram not used       ncol = subcol_get_ncol(lchnk)
! Subprogram not used       call subcol_get_indcol(lchnk, indcol)
! Subprogram not used 
! Subprogram not used       field_sc(:ncol) = field(indcol(:ncol))
! Subprogram not used 
! Subprogram not used 
! Subprogram not used 
! Subprogram not used 
! Subprogram not used 
! Subprogram not used    end subroutine subcol_field_copy_1dint
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5
! Subprogram not used    subroutine subcol_field_copy_2dint (field, lchnk, field_sc)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Copy a pbuf field dimensioned pcols to one with pcols*psubcols and fill appropriately
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer(i4),          intent(in)      :: field(:,:)
! Subprogram not used       integer,          intent(in)      :: lchnk
! Subprogram not used       integer(i4),          intent(out)     :: field_sc(:,:)   ! intent out
! Subprogram not used 
! Subprogram not used       ! Local Variables
! Subprogram not used       integer                           :: ncol
! Subprogram not used       integer                           :: indcol(pcols*psubcols)
! Subprogram not used       integer :: i, indx, j
! Subprogram not used 
! Subprogram not used       if (size(field,dim=1) .ne. pcols) then
! Subprogram not used          call endrun('subcol_field_copy error: only fields with first dimension pcols may use this routine')
! Subprogram not used       end if
! Subprogram not used 
! Subprogram not used       field_sc = fillval_int
! Subprogram not used       ncol = subcol_get_ncol(lchnk)
! Subprogram not used       call subcol_get_indcol(lchnk, indcol)
! Subprogram not used 
! Subprogram not used 
! Subprogram not used       field_sc(:ncol,:) = field(indcol(:ncol),:)
! Subprogram not used 
! Subprogram not used 
! Subprogram not used 
! Subprogram not used 
! Subprogram not used    end subroutine subcol_field_copy_2dint
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5
! Subprogram not used    subroutine subcol_field_copy_3dint (field, lchnk, field_sc)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Copy a pbuf field dimensioned pcols to one with pcols*psubcols and fill appropriately
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer(i4),          intent(in)      :: field(:,:,:)
! Subprogram not used       integer,          intent(in)      :: lchnk
! Subprogram not used       integer(i4),          intent(out)     :: field_sc(:,:,:)   ! intent out
! Subprogram not used 
! Subprogram not used       ! Local Variables
! Subprogram not used       integer                           :: ncol
! Subprogram not used       integer                           :: indcol(pcols*psubcols)
! Subprogram not used       integer :: i, indx, j
! Subprogram not used 
! Subprogram not used       if (size(field,dim=1) .ne. pcols) then
! Subprogram not used          call endrun('subcol_field_copy error: only fields with first dimension pcols may use this routine')
! Subprogram not used       end if
! Subprogram not used 
! Subprogram not used       field_sc = fillval_int
! Subprogram not used       ncol = subcol_get_ncol(lchnk)
! Subprogram not used       call subcol_get_indcol(lchnk, indcol)
! Subprogram not used 
! Subprogram not used 
! Subprogram not used 
! Subprogram not used       field_sc(:ncol,:,:) = field(indcol(:ncol),:,:)
! Subprogram not used 
! Subprogram not used 
! Subprogram not used 
! Subprogram not used    end subroutine subcol_field_copy_3dint
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5
! Subprogram not used    subroutine subcol_field_copy_4dint (field, lchnk, field_sc)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Copy a pbuf field dimensioned pcols to one with pcols*psubcols and fill appropriately
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer(i4),          intent(in)      :: field(:,:,:,:)
! Subprogram not used       integer,          intent(in)      :: lchnk
! Subprogram not used       integer(i4),          intent(out)     :: field_sc(:,:,:,:)   ! intent out
! Subprogram not used 
! Subprogram not used       ! Local Variables
! Subprogram not used       integer                           :: ncol
! Subprogram not used       integer                           :: indcol(pcols*psubcols)
! Subprogram not used       integer :: i, indx, j
! Subprogram not used 
! Subprogram not used       if (size(field,dim=1) .ne. pcols) then
! Subprogram not used          call endrun('subcol_field_copy error: only fields with first dimension pcols may use this routine')
! Subprogram not used       end if
! Subprogram not used 
! Subprogram not used       field_sc = fillval_int
! Subprogram not used       ncol = subcol_get_ncol(lchnk)
! Subprogram not used       call subcol_get_indcol(lchnk, indcol)
! Subprogram not used 
! Subprogram not used 
! Subprogram not used 
! Subprogram not used 
! Subprogram not used       field_sc(:ncol,:,:,:) = field(indcol(:ncol),:,:,:)
! Subprogram not used 
! Subprogram not used 
! Subprogram not used    end subroutine subcol_field_copy_4dint
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5
! Subprogram not used    subroutine subcol_field_copy_5dint (field, lchnk, field_sc)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Copy a pbuf field dimensioned pcols to one with pcols*psubcols and fill appropriately
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer(i4),          intent(in)      :: field(:,:,:,:,:)
! Subprogram not used       integer,          intent(in)      :: lchnk
! Subprogram not used       integer(i4),          intent(out)     :: field_sc(:,:,:,:,:)   ! intent out
! Subprogram not used 
! Subprogram not used       ! Local Variables
! Subprogram not used       integer                           :: ncol
! Subprogram not used       integer                           :: indcol(pcols*psubcols)
! Subprogram not used       integer :: i, indx, j
! Subprogram not used 
! Subprogram not used       if (size(field,dim=1) .ne. pcols) then
! Subprogram not used          call endrun('subcol_field_copy error: only fields with first dimension pcols may use this routine')
! Subprogram not used       end if
! Subprogram not used 
! Subprogram not used       field_sc = fillval_int
! Subprogram not used       ncol = subcol_get_ncol(lchnk)
! Subprogram not used       call subcol_get_indcol(lchnk, indcol)
! Subprogram not used 
! Subprogram not used 
! Subprogram not used 
! Subprogram not used 
! Subprogram not used 
! Subprogram not used       field_sc(:ncol,:,:,:,:) = field(indcol(:ncol),:,:,:,:)
! Subprogram not used 
! Subprogram not used    end subroutine subcol_field_copy_5dint
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5
! Subprogram not used    subroutine subcol_field_copy_1ddouble (field, lchnk, field_sc)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Copy a pbuf field dimensioned pcols to one with pcols*psubcols and fill appropriately
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       real(r8),          intent(in)      :: field(:)
! Subprogram not used       integer,          intent(in)      :: lchnk
! Subprogram not used       real(r8),          intent(out)     :: field_sc(:)   ! intent out
! Subprogram not used 
! Subprogram not used       ! Local Variables
! Subprogram not used       integer                           :: ncol
! Subprogram not used       integer                           :: indcol(pcols*psubcols)
! Subprogram not used       integer :: i, indx, j
! Subprogram not used 
! Subprogram not used       if (size(field,dim=1) .ne. pcols) then
! Subprogram not used          call endrun('subcol_field_copy error: only fields with first dimension pcols may use this routine')
! Subprogram not used       end if
! Subprogram not used 
! Subprogram not used       field_sc = fillval_double
! Subprogram not used       ncol = subcol_get_ncol(lchnk)
! Subprogram not used       call subcol_get_indcol(lchnk, indcol)
! Subprogram not used 
! Subprogram not used       field_sc(:ncol) = field(indcol(:ncol))
! Subprogram not used 
! Subprogram not used 
! Subprogram not used 
! Subprogram not used 
! Subprogram not used 
! Subprogram not used    end subroutine subcol_field_copy_1ddouble
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5
! Subprogram not used    subroutine subcol_field_copy_2ddouble (field, lchnk, field_sc)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Copy a pbuf field dimensioned pcols to one with pcols*psubcols and fill appropriately
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       real(r8),          intent(in)      :: field(:,:)
! Subprogram not used       integer,          intent(in)      :: lchnk
! Subprogram not used       real(r8),          intent(out)     :: field_sc(:,:)   ! intent out
! Subprogram not used 
! Subprogram not used       ! Local Variables
! Subprogram not used       integer                           :: ncol
! Subprogram not used       integer                           :: indcol(pcols*psubcols)
! Subprogram not used       integer :: i, indx, j
! Subprogram not used 
! Subprogram not used       if (size(field,dim=1) .ne. pcols) then
! Subprogram not used          call endrun('subcol_field_copy error: only fields with first dimension pcols may use this routine')
! Subprogram not used       end if
! Subprogram not used 
! Subprogram not used       field_sc = fillval_double
! Subprogram not used       ncol = subcol_get_ncol(lchnk)
! Subprogram not used       call subcol_get_indcol(lchnk, indcol)
! Subprogram not used 
! Subprogram not used 
! Subprogram not used       field_sc(:ncol,:) = field(indcol(:ncol),:)
! Subprogram not used 
! Subprogram not used 
! Subprogram not used 
! Subprogram not used 
! Subprogram not used    end subroutine subcol_field_copy_2ddouble
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5
! Subprogram not used    subroutine subcol_field_copy_3ddouble (field, lchnk, field_sc)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Copy a pbuf field dimensioned pcols to one with pcols*psubcols and fill appropriately
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       real(r8),          intent(in)      :: field(:,:,:)
! Subprogram not used       integer,          intent(in)      :: lchnk
! Subprogram not used       real(r8),          intent(out)     :: field_sc(:,:,:)   ! intent out
! Subprogram not used 
! Subprogram not used       ! Local Variables
! Subprogram not used       integer                           :: ncol
! Subprogram not used       integer                           :: indcol(pcols*psubcols)
! Subprogram not used       integer :: i, indx, j
! Subprogram not used 
! Subprogram not used       if (size(field,dim=1) .ne. pcols) then
! Subprogram not used          call endrun('subcol_field_copy error: only fields with first dimension pcols may use this routine')
! Subprogram not used       end if
! Subprogram not used 
! Subprogram not used       field_sc = fillval_double
! Subprogram not used       ncol = subcol_get_ncol(lchnk)
! Subprogram not used       call subcol_get_indcol(lchnk, indcol)
! Subprogram not used 
! Subprogram not used 
! Subprogram not used 
! Subprogram not used       field_sc(:ncol,:,:) = field(indcol(:ncol),:,:)
! Subprogram not used 
! Subprogram not used 
! Subprogram not used 
! Subprogram not used    end subroutine subcol_field_copy_3ddouble
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5
! Subprogram not used    subroutine subcol_field_copy_4ddouble (field, lchnk, field_sc)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Copy a pbuf field dimensioned pcols to one with pcols*psubcols and fill appropriately
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       real(r8),          intent(in)      :: field(:,:,:,:)
! Subprogram not used       integer,          intent(in)      :: lchnk
! Subprogram not used       real(r8),          intent(out)     :: field_sc(:,:,:,:)   ! intent out
! Subprogram not used 
! Subprogram not used       ! Local Variables
! Subprogram not used       integer                           :: ncol
! Subprogram not used       integer                           :: indcol(pcols*psubcols)
! Subprogram not used       integer :: i, indx, j
! Subprogram not used 
! Subprogram not used       if (size(field,dim=1) .ne. pcols) then
! Subprogram not used          call endrun('subcol_field_copy error: only fields with first dimension pcols may use this routine')
! Subprogram not used       end if
! Subprogram not used 
! Subprogram not used       field_sc = fillval_double
! Subprogram not used       ncol = subcol_get_ncol(lchnk)
! Subprogram not used       call subcol_get_indcol(lchnk, indcol)
! Subprogram not used 
! Subprogram not used 
! Subprogram not used 
! Subprogram not used 
! Subprogram not used       field_sc(:ncol,:,:,:) = field(indcol(:ncol),:,:,:)
! Subprogram not used 
! Subprogram not used 
! Subprogram not used    end subroutine subcol_field_copy_4ddouble
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5
! Subprogram not used    subroutine subcol_field_copy_5ddouble (field, lchnk, field_sc)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Copy a pbuf field dimensioned pcols to one with pcols*psubcols and fill appropriately
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       real(r8),          intent(in)      :: field(:,:,:,:,:)
! Subprogram not used       integer,          intent(in)      :: lchnk
! Subprogram not used       real(r8),          intent(out)     :: field_sc(:,:,:,:,:)   ! intent out
! Subprogram not used 
! Subprogram not used       ! Local Variables
! Subprogram not used       integer                           :: ncol
! Subprogram not used       integer                           :: indcol(pcols*psubcols)
! Subprogram not used       integer :: i, indx, j
! Subprogram not used 
! Subprogram not used       if (size(field,dim=1) .ne. pcols) then
! Subprogram not used          call endrun('subcol_field_copy error: only fields with first dimension pcols may use this routine')
! Subprogram not used       end if
! Subprogram not used 
! Subprogram not used       field_sc = fillval_double
! Subprogram not used       ncol = subcol_get_ncol(lchnk)
! Subprogram not used       call subcol_get_indcol(lchnk, indcol)
! Subprogram not used 
! Subprogram not used 
! Subprogram not used 
! Subprogram not used 
! Subprogram not used 
! Subprogram not used       field_sc(:ncol,:,:,:,:) = field(indcol(:ncol),:,:,:,:)
! Subprogram not used 
! Subprogram not used    end subroutine subcol_field_copy_5ddouble
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5
! Subprogram not used    subroutine subcol_field_copy_1dreal (field, lchnk, field_sc)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Copy a pbuf field dimensioned pcols to one with pcols*psubcols and fill appropriately
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       real(r4),          intent(in)      :: field(:)
! Subprogram not used       integer,          intent(in)      :: lchnk
! Subprogram not used       real(r4),          intent(out)     :: field_sc(:)   ! intent out
! Subprogram not used 
! Subprogram not used       ! Local Variables
! Subprogram not used       integer                           :: ncol
! Subprogram not used       integer                           :: indcol(pcols*psubcols)
! Subprogram not used       integer :: i, indx, j
! Subprogram not used 
! Subprogram not used       if (size(field,dim=1) .ne. pcols) then
! Subprogram not used          call endrun('subcol_field_copy error: only fields with first dimension pcols may use this routine')
! Subprogram not used       end if
! Subprogram not used 
! Subprogram not used       field_sc = fillval_real
! Subprogram not used       ncol = subcol_get_ncol(lchnk)
! Subprogram not used       call subcol_get_indcol(lchnk, indcol)
! Subprogram not used 
! Subprogram not used       field_sc(:ncol) = field(indcol(:ncol))
! Subprogram not used 
! Subprogram not used 
! Subprogram not used 
! Subprogram not used 
! Subprogram not used 
! Subprogram not used    end subroutine subcol_field_copy_1dreal
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5
! Subprogram not used    subroutine subcol_field_copy_2dreal (field, lchnk, field_sc)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Copy a pbuf field dimensioned pcols to one with pcols*psubcols and fill appropriately
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       real(r4),          intent(in)      :: field(:,:)
! Subprogram not used       integer,          intent(in)      :: lchnk
! Subprogram not used       real(r4),          intent(out)     :: field_sc(:,:)   ! intent out
! Subprogram not used 
! Subprogram not used       ! Local Variables
! Subprogram not used       integer                           :: ncol
! Subprogram not used       integer                           :: indcol(pcols*psubcols)
! Subprogram not used       integer :: i, indx, j
! Subprogram not used 
! Subprogram not used       if (size(field,dim=1) .ne. pcols) then
! Subprogram not used          call endrun('subcol_field_copy error: only fields with first dimension pcols may use this routine')
! Subprogram not used       end if
! Subprogram not used 
! Subprogram not used       field_sc = fillval_real
! Subprogram not used       ncol = subcol_get_ncol(lchnk)
! Subprogram not used       call subcol_get_indcol(lchnk, indcol)
! Subprogram not used 
! Subprogram not used 
! Subprogram not used       field_sc(:ncol,:) = field(indcol(:ncol),:)
! Subprogram not used 
! Subprogram not used 
! Subprogram not used 
! Subprogram not used 
! Subprogram not used    end subroutine subcol_field_copy_2dreal
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5
! Subprogram not used    subroutine subcol_field_copy_3dreal (field, lchnk, field_sc)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Copy a pbuf field dimensioned pcols to one with pcols*psubcols and fill appropriately
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       real(r4),          intent(in)      :: field(:,:,:)
! Subprogram not used       integer,          intent(in)      :: lchnk
! Subprogram not used       real(r4),          intent(out)     :: field_sc(:,:,:)   ! intent out
! Subprogram not used 
! Subprogram not used       ! Local Variables
! Subprogram not used       integer                           :: ncol
! Subprogram not used       integer                           :: indcol(pcols*psubcols)
! Subprogram not used       integer :: i, indx, j
! Subprogram not used 
! Subprogram not used       if (size(field,dim=1) .ne. pcols) then
! Subprogram not used          call endrun('subcol_field_copy error: only fields with first dimension pcols may use this routine')
! Subprogram not used       end if
! Subprogram not used 
! Subprogram not used       field_sc = fillval_real
! Subprogram not used       ncol = subcol_get_ncol(lchnk)
! Subprogram not used       call subcol_get_indcol(lchnk, indcol)
! Subprogram not used 
! Subprogram not used 
! Subprogram not used 
! Subprogram not used       field_sc(:ncol,:,:) = field(indcol(:ncol),:,:)
! Subprogram not used 
! Subprogram not used 
! Subprogram not used 
! Subprogram not used    end subroutine subcol_field_copy_3dreal
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5
! Subprogram not used    subroutine subcol_field_copy_4dreal (field, lchnk, field_sc)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Copy a pbuf field dimensioned pcols to one with pcols*psubcols and fill appropriately
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       real(r4),          intent(in)      :: field(:,:,:,:)
! Subprogram not used       integer,          intent(in)      :: lchnk
! Subprogram not used       real(r4),          intent(out)     :: field_sc(:,:,:,:)   ! intent out
! Subprogram not used 
! Subprogram not used       ! Local Variables
! Subprogram not used       integer                           :: ncol
! Subprogram not used       integer                           :: indcol(pcols*psubcols)
! Subprogram not used       integer :: i, indx, j
! Subprogram not used 
! Subprogram not used       if (size(field,dim=1) .ne. pcols) then
! Subprogram not used          call endrun('subcol_field_copy error: only fields with first dimension pcols may use this routine')
! Subprogram not used       end if
! Subprogram not used 
! Subprogram not used       field_sc = fillval_real
! Subprogram not used       ncol = subcol_get_ncol(lchnk)
! Subprogram not used       call subcol_get_indcol(lchnk, indcol)
! Subprogram not used 
! Subprogram not used 
! Subprogram not used 
! Subprogram not used 
! Subprogram not used       field_sc(:ncol,:,:,:) = field(indcol(:ncol),:,:,:)
! Subprogram not used 
! Subprogram not used 
! Subprogram not used    end subroutine subcol_field_copy_4dreal
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5
! Subprogram not used    subroutine subcol_field_copy_5dreal (field, lchnk, field_sc)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Copy a pbuf field dimensioned pcols to one with pcols*psubcols and fill appropriately
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       real(r4),          intent(in)      :: field(:,:,:,:,:)
! Subprogram not used       integer,          intent(in)      :: lchnk
! Subprogram not used       real(r4),          intent(out)     :: field_sc(:,:,:,:,:)   ! intent out
! Subprogram not used 
! Subprogram not used       ! Local Variables
! Subprogram not used       integer                           :: ncol
! Subprogram not used       integer                           :: indcol(pcols*psubcols)
! Subprogram not used       integer :: i, indx, j
! Subprogram not used 
! Subprogram not used       if (size(field,dim=1) .ne. pcols) then
! Subprogram not used          call endrun('subcol_field_copy error: only fields with first dimension pcols may use this routine')
! Subprogram not used       end if
! Subprogram not used 
! Subprogram not used       field_sc = fillval_real
! Subprogram not used       ncol = subcol_get_ncol(lchnk)
! Subprogram not used       call subcol_get_indcol(lchnk, indcol)
! Subprogram not used 
! Subprogram not used 
! Subprogram not used 
! Subprogram not used 
! Subprogram not used 
! Subprogram not used       field_sc(:ncol,:,:,:,:) = field(indcol(:ncol),:,:,:,:)
! Subprogram not used 
! Subprogram not used    end subroutine subcol_field_copy_5dreal

   ! TYPE double
   ! DIMS 1,2,3
! Subprogram not used    subroutine subcol_state_field_copy_1ddouble (field, state, field_sc)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Copy a state field dimensioned with pcols to one with pcols*psubcols and fill appropriately
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       real(r8), intent(in)                     :: field(:)
! Subprogram not used       type(physics_state), intent(in)         :: state
! Subprogram not used       real(r8),          allocatable           :: field_sc(:)   ! intent out
! Subprogram not used 
! Subprogram not used       integer :: dim2, dim3
! Subprogram not used       integer :: indcol(pcols*psubcols)
! Subprogram not used 
! Subprogram not used       if (size(field,dim=1) .ne. pcols) then
! Subprogram not used          call endrun('subcol_state_field_copy error: only fields with first dimension pcols may use this routine')
! Subprogram not used       end if
! Subprogram not used 
! Subprogram not used       call subcol_get_indcol(state%lchnk, indcol)
! Subprogram not used 
! Subprogram not used       if (.not. allocated(field_sc)) then
! Subprogram not used          allocate(field_sc(pcols*psubcols))
! Subprogram not used       end if
! Subprogram not used 
! Subprogram not used       field_sc = 0._r8
! Subprogram not used       field_sc(:state%ncol) = field(indcol(:state%ncol))
! Subprogram not used 
! Subprogram not used 
! Subprogram not used 
! Subprogram not used    end subroutine subcol_state_field_copy_1ddouble
   ! TYPE double
   ! DIMS 1,2,3
! Subprogram not used    subroutine subcol_state_field_copy_2ddouble (field, state, field_sc)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Copy a state field dimensioned with pcols to one with pcols*psubcols and fill appropriately
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       real(r8), intent(in)                     :: field(:,:)
! Subprogram not used       type(physics_state), intent(in)         :: state
! Subprogram not used       real(r8),          allocatable           :: field_sc(:,:)   ! intent out
! Subprogram not used 
! Subprogram not used       integer :: dim2, dim3
! Subprogram not used       integer :: indcol(pcols*psubcols)
! Subprogram not used 
! Subprogram not used       if (size(field,dim=1) .ne. pcols) then
! Subprogram not used          call endrun('subcol_state_field_copy error: only fields with first dimension pcols may use this routine')
! Subprogram not used       end if
! Subprogram not used 
! Subprogram not used       call subcol_get_indcol(state%lchnk, indcol)
! Subprogram not used 
! Subprogram not used 
! Subprogram not used       if (.not. allocated(field_sc)) then
! Subprogram not used          dim2 = size(field,dim=2)
! Subprogram not used          allocate(field_sc(pcols*psubcols,dim2))
! Subprogram not used       end if
! Subprogram not used 
! Subprogram not used       field_sc = 0._r8
! Subprogram not used       field_sc(:state%ncol,:) = field(indcol(:state%ncol),:)
! Subprogram not used 
! Subprogram not used 
! Subprogram not used    end subroutine subcol_state_field_copy_2ddouble
   ! TYPE double
   ! DIMS 1,2,3
! Subprogram not used    subroutine subcol_state_field_copy_3ddouble (field, state, field_sc)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Copy a state field dimensioned with pcols to one with pcols*psubcols and fill appropriately
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       real(r8), intent(in)                     :: field(:,:,:)
! Subprogram not used       type(physics_state), intent(in)         :: state
! Subprogram not used       real(r8),          allocatable           :: field_sc(:,:,:)   ! intent out
! Subprogram not used 
! Subprogram not used       integer :: dim2, dim3
! Subprogram not used       integer :: indcol(pcols*psubcols)
! Subprogram not used 
! Subprogram not used       if (size(field,dim=1) .ne. pcols) then
! Subprogram not used          call endrun('subcol_state_field_copy error: only fields with first dimension pcols may use this routine')
! Subprogram not used       end if
! Subprogram not used 
! Subprogram not used       call subcol_get_indcol(state%lchnk, indcol)
! Subprogram not used 
! Subprogram not used 
! Subprogram not used 
! Subprogram not used       if (.not. allocated(field_sc)) then
! Subprogram not used          dim2 = size(field,dim=2)
! Subprogram not used          dim3 = size(field,dim=3)
! Subprogram not used          allocate(field_sc(pcols*psubcols,dim2,dim3))
! Subprogram not used       end if
! Subprogram not used 
! Subprogram not used       field_sc = 0._r8
! Subprogram not used       field_sc(:state%ncol,:,:) = field(indcol(:state%ncol),:,:)
! Subprogram not used 
! Subprogram not used    end subroutine subcol_state_field_copy_3ddouble

   subroutine subcol_tend_copy(tend, state_sc, tend_sc)
   !-----------------------------------------------------------------------
   ! Copy all of tend to subcolumns in tend_sc, allocating tend_sc if necessary
   !-----------------------------------------------------------------------
      type(physics_tend),  intent(inout) :: tend
      type(physics_state), intent(in)    :: state_sc        ! subcolumn state
      type(physics_tend),  intent(inout) :: tend_sc         ! subcolumn tend


      if (.not. allocated(tend%dtdt)) then
         call physics_tend_alloc(tend_sc, state_sc%psetcols)
      end if

      tend_sc%psetcols   = pcols*psubcols
      call subcol_state_field_copy(tend%dtdt,       state_sc, tend_sc%dtdt)
      call subcol_state_field_copy(tend%dudt,       state_sc, tend_sc%dudt)
      call subcol_state_field_copy(tend%dvdt,       state_sc, tend_sc%dvdt)
      call subcol_state_field_copy(tend%flx_net,    state_sc, tend_sc%flx_net)
      call subcol_state_field_copy(tend%te_tnd,     state_sc, tend_sc%te_tnd)
      call subcol_state_field_copy(tend%tw_tnd,     state_sc, tend_sc%tw_tnd)

   end subroutine subcol_tend_copy

! Subprogram not used    subroutine subcol_state_copy(state, state_sc)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Copy all of state to subcolumns in state_sc, allocating state_sc if necessary
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used       type(physics_state), intent(in)    :: state
! Subprogram not used       type(physics_state), intent(inout) :: state_sc        ! subcolumn state
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer :: i, j, k, m, ngrdcol, indx
! Subprogram not used 
! Subprogram not used       if (.not. allocated(state_sc%lat)) then
! Subprogram not used          call endrun('subcol_state_copy: user must allocate state_sc prior to calling this routine')
! Subprogram not used       end if
! Subprogram not used 
! Subprogram not used       ngrdcol       = state%ngrdcol
! Subprogram not used 
! Subprogram not used       call subcol_state_hdrinit(state, state_sc)
! Subprogram not used 
! Subprogram not used       call subcol_state_field_copy(state%lat,       state_sc, state_sc%lat)
! Subprogram not used       call subcol_state_field_copy(state%lon,       state_sc, state_sc%lon)
! Subprogram not used       call subcol_state_field_copy(state%ps,        state_sc, state_sc%ps)
! Subprogram not used       call subcol_state_field_copy(state%psdry,     state_sc, state_sc%psdry)
! Subprogram not used       call subcol_state_field_copy(state%phis,      state_sc, state_sc%phis)
! Subprogram not used       call subcol_state_field_copy(state%te_ini,    state_sc, state_sc%te_ini)
! Subprogram not used       call subcol_state_field_copy(state%te_cur,    state_sc, state_sc%te_cur)
! Subprogram not used       call subcol_state_field_copy(state%tw_ini,    state_sc, state_sc%tw_ini)
! Subprogram not used       call subcol_state_field_copy(state%tw_cur,    state_sc, state_sc%tw_cur)
! Subprogram not used       call subcol_state_field_copy(state%t,         state_sc, state_sc%t)
! Subprogram not used       call subcol_state_field_copy(state%u,         state_sc, state_sc%u)
! Subprogram not used       call subcol_state_field_copy(state%v,         state_sc, state_sc%v)
! Subprogram not used       call subcol_state_field_copy(state%s,         state_sc, state_sc%s)
! Subprogram not used       call subcol_state_field_copy(state%omega,     state_sc, state_sc%omega)
! Subprogram not used       call subcol_state_field_copy(state%pmid,      state_sc, state_sc%pmid)
! Subprogram not used       call subcol_state_field_copy(state%pdel,      state_sc, state_sc%pdel)
! Subprogram not used       call subcol_state_field_copy(state%rpdel,     state_sc, state_sc%rpdel)
! Subprogram not used       call subcol_state_field_copy(state%lnpmid,    state_sc, state_sc%lnpmid)
! Subprogram not used       call subcol_state_field_copy(state%exner,     state_sc, state_sc%exner)
! Subprogram not used       call subcol_state_field_copy(state%zm,        state_sc, state_sc%zm)
! Subprogram not used       call subcol_state_field_copy(state%pint,      state_sc, state_sc%pint)
! Subprogram not used       call subcol_state_field_copy(state%lnpint,    state_sc, state_sc%lnpint)
! Subprogram not used       call subcol_state_field_copy(state%zi,        state_sc, state_sc%zi)
! Subprogram not used       call subcol_state_field_copy(state%lnpmiddry, state_sc, state_sc%lnpmiddry)
! Subprogram not used       call subcol_state_field_copy(state%pmiddry,   state_sc, state_sc%pmiddry)
! Subprogram not used       call subcol_state_field_copy(state%pdeldry,   state_sc, state_sc%pdeldry)
! Subprogram not used       call subcol_state_field_copy(state%rpdeldry,  state_sc, state_sc%rpdeldry)
! Subprogram not used       call subcol_state_field_copy(state%pintdry,   state_sc, state_sc%pintdry)
! Subprogram not used       call subcol_state_field_copy(state%lnpintdry, state_sc, state_sc%lnpintdry)
! Subprogram not used       call subcol_state_field_copy(state%q,         state_sc, state_sc%q)
! Subprogram not used 
! Subprogram not used    end subroutine subcol_state_copy

   subroutine subcol_set_subcols(state, tend, nsubcol, state_sc, tend_sc)
   !-----------------------------------------------------------------------
   ! Propogate nsubcol information to common areas such as state, tend,
   ! nsubcol2d, and indcol2d
   !-----------------------------------------------------------------------
      type(physics_state), intent(in)    :: state
      type(physics_tend),  intent(inout) :: tend
      integer,             intent(in)    :: nsubcol(pcols)
      type(physics_state), intent(inout) :: state_sc        ! subcolumn state
      type(physics_tend),  intent(inout) :: tend_sc         ! subcolumn tend

      call subcol_set_nsubcol(state%lchnk, state%ngrdcol, nsubcol)
      call subcol_state_copy(state, state_sc)
      call subcol_tend_copy(tend, state_sc, tend_sc)
   end subroutine subcol_set_subcols


   subroutine subcol_ptend_copy(ptend, state, ptend_cp)
   !-----------------------------------------------------------------------
   ! Copy a physics_ptend object into one which has subcolumns
   !-----------------------------------------------------------------------
      use physics_types, only: physics_ptend_init

      type(physics_ptend), intent(in)    :: ptend    ! ptend source, dimensioned with grid columns
      type(physics_state), intent(in)    :: state    ! state with subcolumns
      type(physics_ptend), intent(out)   :: ptend_cp ! copy of ptend, dimensioned with subcolumns

      ! Local Variables
      integer                            :: ncol
      integer                            :: indcol(pcols*psubcols)

      !-----------------------------------------------------------------------

      if (ptend%psetcols .ne. pcols) then
         call endrun('subcol_ptend_copy: ptend must be dimensioned pcols to use this routine')
      end if

      call physics_ptend_init(ptend_cp,state%psetcols, ptend%name, ls=ptend%ls, lu=ptend%lu,  &
           lv=ptend%lv, lq=ptend%lq)

      ptend_cp%top_level = ptend%top_level
      ptend_cp%bot_level = ptend%bot_level

      ncol = subcol_get_ncol(state%lchnk)
      call subcol_get_indcol(state%lchnk, indcol)

      ! Copy the grid column data into each of the subcolumns - indcol contains the grid index for each subcolumn
      if (ptend_cp%ls) then
         ptend_cp%s(:ncol,:) = ptend%s(indcol(:ncol),:)
         ptend_cp%hflux_srf(:ncol) = ptend%hflux_srf(indcol(:ncol))
         ptend_cp%hflux_top(:ncol) = ptend%hflux_top(indcol(:ncol))
      end if

      if (ptend_cp%lu) then
         ptend_cp%u(:ncol,:) = ptend%u(indcol(:ncol),:)
         ptend_cp%taux_srf(:ncol)  = ptend%taux_srf(indcol(:ncol))
         ptend_cp%taux_top(:ncol)  = ptend%taux_top(indcol(:ncol))
      end if

      if (ptend_cp%lv) then
         ptend_cp%v(:ncol,:) = ptend%v(indcol(:ncol),:)
         ptend_cp%tauy_srf(:ncol)  = ptend%tauy_srf(indcol(:ncol))
         ptend_cp%tauy_top(:ncol)  = ptend%tauy_top(indcol(:ncol))
      end if

      if (any(ptend_cp%lq(:))) then
         ptend_cp%q(:ncol,:,:) = ptend%q(indcol(:ncol),:,:)
         ptend_cp%cflx_srf(:ncol,:)  = ptend%cflx_srf(indcol(:ncol),:)
         ptend_cp%cflx_top(:ncol,:)  = ptend%cflx_top(indcol(:ncol),:)
      end if

   end subroutine subcol_ptend_copy
  
! Subprogram not used    subroutine subcol_state_hdrinit(state, state_sc)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Initialize the subcolumn state header variables
! Subprogram not used    !----------------------------------------------------------------------
! Subprogram not used       type(physics_state), intent(in)    :: state
! Subprogram not used       type(physics_state), intent(inout) :: state_sc        ! subcolumn state
! Subprogram not used 
! Subprogram not used       integer :: i, j, indx, isize
! Subprogram not used       integer :: nsubcol(pcols)
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(state%lchnk, nsubcol)
! Subprogram not used       isize = state%ngrdcol
! Subprogram not used       if (size(nsubcol) < isize) then
! Subprogram not used          call endrun('subcol_state_hdrinit error: input nsubcol array must be dimensioned at least as large as state%ngrdcol')
! Subprogram not used       end if
! Subprogram not used 
! Subprogram not used       state_sc%ngrdcol    = state%ngrdcol
! Subprogram not used       state_sc%lchnk      = state%lchnk
! Subprogram not used 
! Subprogram not used       state_sc%psetcols   = pcols*psubcols
! Subprogram not used       ! Set count to a too-large value. It should be correctly initialized in check_energy_timestep_init
! Subprogram not used       state_sc%count      = pcols*psubcols*2
! Subprogram not used 
! Subprogram not used       ! Set the number of set subcolumns to the total count
! Subprogram not used       state_sc%ncol       = subcol_get_ncol(state%lchnk)
! Subprogram not used 
! Subprogram not used    end subroutine subcol_state_hdrinit

   ! TYPE int,double,real
   ! DIMS 1,2
! Subprogram not used    subroutine subcol_field_avg_shr_1dint(field_sc, ngrdcol, lchnk, field,  usefilter, useweight)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! This is the high level subcol field averaging routine which 
! Subprogram not used    ! averages a field dimensioned pcols*psubcols to a grid one dimensioned pcols 
! Subprogram not used    !  
! Subprogram not used    ! Its purpose is to check filter and weight settings and to subset the
! Subprogram not used    ! appropriate subsection of the field array to pass on the averaging routine
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer(i4),intent(in)                      :: field_sc(:) ! intent in
! Subprogram not used       integer, intent(in)                     :: ngrdcol          ! # grid cols
! Subprogram not used       integer, intent(in)                     :: lchnk            ! chunk index
! Subprogram not used       integer(i4), intent(out)                    :: field(:)
! Subprogram not used       logical, intent(in)                     :: usefilter
! Subprogram not used       logical, intent(in)                     :: useweight
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, nsubcol, i, j
! Subprogram not used       integer           :: nsubcols(pcols)
! Subprogram not used 
! Subprogram not used       field = ret_nan_int
! Subprogram not used      
! Subprogram not used       if (usefilter .and. .not. filter_set) then
! Subprogram not used         call endrun('subcol_field_avg_shr error: Cannot specify using filters when none set')
! Subprogram not used       end if
! Subprogram not used 
! Subprogram not used       if (useweight .and. .not. weight_set) then
! Subprogram not used         call endrun('subcol_field_avg_shr error: Cannot specify using weights when none set')
! Subprogram not used       end if
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcols)
! Subprogram not used       indx = 1
! Subprogram not used       do i = 1, ngrdcol
! Subprogram not used          if (nsubcols(i) .gt. 0) then
! Subprogram not used            nsubcol = nsubcols(i)
! Subprogram not used              field(i)=subcol_avg_inter(field_sc(indx:indx+nsubcol-1), lchnk, i, indx, indx+nsubcol-1, usefilter, useweight)
! Subprogram not used            indx = indx + nsubcol
! Subprogram not used          end if
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_field_avg_shr_1dint
   ! TYPE int,double,real
   ! DIMS 1,2
! Subprogram not used    subroutine subcol_field_avg_shr_2dint(field_sc, ngrdcol, lchnk, field,  usefilter, useweight)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! This is the high level subcol field averaging routine which 
! Subprogram not used    ! averages a field dimensioned pcols*psubcols to a grid one dimensioned pcols 
! Subprogram not used    !  
! Subprogram not used    ! Its purpose is to check filter and weight settings and to subset the
! Subprogram not used    ! appropriate subsection of the field array to pass on the averaging routine
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer(i4),intent(in)                      :: field_sc(:,:) ! intent in
! Subprogram not used       integer, intent(in)                     :: ngrdcol          ! # grid cols
! Subprogram not used       integer, intent(in)                     :: lchnk            ! chunk index
! Subprogram not used       integer(i4), intent(out)                    :: field(:,:)
! Subprogram not used       logical, intent(in)                     :: usefilter
! Subprogram not used       logical, intent(in)                     :: useweight
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, nsubcol, i, j
! Subprogram not used       integer           :: nsubcols(pcols)
! Subprogram not used 
! Subprogram not used       field = ret_nan_int
! Subprogram not used      
! Subprogram not used       if (usefilter .and. .not. filter_set) then
! Subprogram not used         call endrun('subcol_field_avg_shr error: Cannot specify using filters when none set')
! Subprogram not used       end if
! Subprogram not used 
! Subprogram not used       if (useweight .and. .not. weight_set) then
! Subprogram not used         call endrun('subcol_field_avg_shr error: Cannot specify using weights when none set')
! Subprogram not used       end if
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcols)
! Subprogram not used       indx = 1
! Subprogram not used       do i = 1, ngrdcol
! Subprogram not used          if (nsubcols(i) .gt. 0) then
! Subprogram not used            nsubcol = nsubcols(i)
! Subprogram not used            do j=1,size(field_sc,dim=2)
! Subprogram not used              field(i,j)=subcol_avg_inter(field_sc(indx:indx+nsubcol-1,j), lchnk, i, indx, indx+nsubcol-1, usefilter, useweight)
! Subprogram not used            end do
! Subprogram not used            indx = indx + nsubcol
! Subprogram not used          end if
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_field_avg_shr_2dint
   ! TYPE int,double,real
   ! DIMS 1,2
! Subprogram not used    subroutine subcol_field_avg_shr_1ddouble(field_sc, ngrdcol, lchnk, field,  usefilter, useweight)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! This is the high level subcol field averaging routine which 
! Subprogram not used    ! averages a field dimensioned pcols*psubcols to a grid one dimensioned pcols 
! Subprogram not used    !  
! Subprogram not used    ! Its purpose is to check filter and weight settings and to subset the
! Subprogram not used    ! appropriate subsection of the field array to pass on the averaging routine
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       real(r8),intent(in)                      :: field_sc(:) ! intent in
! Subprogram not used       integer, intent(in)                     :: ngrdcol          ! # grid cols
! Subprogram not used       integer, intent(in)                     :: lchnk            ! chunk index
! Subprogram not used       real(r8), intent(out)                    :: field(:)
! Subprogram not used       logical, intent(in)                     :: usefilter
! Subprogram not used       logical, intent(in)                     :: useweight
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, nsubcol, i, j
! Subprogram not used       integer           :: nsubcols(pcols)
! Subprogram not used 
! Subprogram not used       field = ret_nan_double
! Subprogram not used      
! Subprogram not used       if (usefilter .and. .not. filter_set) then
! Subprogram not used         call endrun('subcol_field_avg_shr error: Cannot specify using filters when none set')
! Subprogram not used       end if
! Subprogram not used 
! Subprogram not used       if (useweight .and. .not. weight_set) then
! Subprogram not used         call endrun('subcol_field_avg_shr error: Cannot specify using weights when none set')
! Subprogram not used       end if
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcols)
! Subprogram not used       indx = 1
! Subprogram not used       do i = 1, ngrdcol
! Subprogram not used          if (nsubcols(i) .gt. 0) then
! Subprogram not used            nsubcol = nsubcols(i)
! Subprogram not used              field(i)=subcol_avg_inter(field_sc(indx:indx+nsubcol-1), lchnk, i, indx, indx+nsubcol-1, usefilter, useweight)
! Subprogram not used            indx = indx + nsubcol
! Subprogram not used          end if
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_field_avg_shr_1ddouble
   ! TYPE int,double,real
   ! DIMS 1,2
! Subprogram not used    subroutine subcol_field_avg_shr_2ddouble(field_sc, ngrdcol, lchnk, field,  usefilter, useweight)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! This is the high level subcol field averaging routine which 
! Subprogram not used    ! averages a field dimensioned pcols*psubcols to a grid one dimensioned pcols 
! Subprogram not used    !  
! Subprogram not used    ! Its purpose is to check filter and weight settings and to subset the
! Subprogram not used    ! appropriate subsection of the field array to pass on the averaging routine
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       real(r8),intent(in)                      :: field_sc(:,:) ! intent in
! Subprogram not used       integer, intent(in)                     :: ngrdcol          ! # grid cols
! Subprogram not used       integer, intent(in)                     :: lchnk            ! chunk index
! Subprogram not used       real(r8), intent(out)                    :: field(:,:)
! Subprogram not used       logical, intent(in)                     :: usefilter
! Subprogram not used       logical, intent(in)                     :: useweight
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, nsubcol, i, j
! Subprogram not used       integer           :: nsubcols(pcols)
! Subprogram not used 
! Subprogram not used       field = ret_nan_double
! Subprogram not used      
! Subprogram not used       if (usefilter .and. .not. filter_set) then
! Subprogram not used         call endrun('subcol_field_avg_shr error: Cannot specify using filters when none set')
! Subprogram not used       end if
! Subprogram not used 
! Subprogram not used       if (useweight .and. .not. weight_set) then
! Subprogram not used         call endrun('subcol_field_avg_shr error: Cannot specify using weights when none set')
! Subprogram not used       end if
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcols)
! Subprogram not used       indx = 1
! Subprogram not used       do i = 1, ngrdcol
! Subprogram not used          if (nsubcols(i) .gt. 0) then
! Subprogram not used            nsubcol = nsubcols(i)
! Subprogram not used            do j=1,size(field_sc,dim=2)
! Subprogram not used              field(i,j)=subcol_avg_inter(field_sc(indx:indx+nsubcol-1,j), lchnk, i, indx, indx+nsubcol-1, usefilter, useweight)
! Subprogram not used            end do
! Subprogram not used            indx = indx + nsubcol
! Subprogram not used          end if
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_field_avg_shr_2ddouble
   ! TYPE int,double,real
   ! DIMS 1,2
! Subprogram not used    subroutine subcol_field_avg_shr_1dreal(field_sc, ngrdcol, lchnk, field,  usefilter, useweight)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! This is the high level subcol field averaging routine which 
! Subprogram not used    ! averages a field dimensioned pcols*psubcols to a grid one dimensioned pcols 
! Subprogram not used    !  
! Subprogram not used    ! Its purpose is to check filter and weight settings and to subset the
! Subprogram not used    ! appropriate subsection of the field array to pass on the averaging routine
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       real(r4),intent(in)                      :: field_sc(:) ! intent in
! Subprogram not used       integer, intent(in)                     :: ngrdcol          ! # grid cols
! Subprogram not used       integer, intent(in)                     :: lchnk            ! chunk index
! Subprogram not used       real(r4), intent(out)                    :: field(:)
! Subprogram not used       logical, intent(in)                     :: usefilter
! Subprogram not used       logical, intent(in)                     :: useweight
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, nsubcol, i, j
! Subprogram not used       integer           :: nsubcols(pcols)
! Subprogram not used 
! Subprogram not used       field = ret_nan_real
! Subprogram not used      
! Subprogram not used       if (usefilter .and. .not. filter_set) then
! Subprogram not used         call endrun('subcol_field_avg_shr error: Cannot specify using filters when none set')
! Subprogram not used       end if
! Subprogram not used 
! Subprogram not used       if (useweight .and. .not. weight_set) then
! Subprogram not used         call endrun('subcol_field_avg_shr error: Cannot specify using weights when none set')
! Subprogram not used       end if
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcols)
! Subprogram not used       indx = 1
! Subprogram not used       do i = 1, ngrdcol
! Subprogram not used          if (nsubcols(i) .gt. 0) then
! Subprogram not used            nsubcol = nsubcols(i)
! Subprogram not used              field(i)=subcol_avg_inter(field_sc(indx:indx+nsubcol-1), lchnk, i, indx, indx+nsubcol-1, usefilter, useweight)
! Subprogram not used            indx = indx + nsubcol
! Subprogram not used          end if
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_field_avg_shr_1dreal
   ! TYPE int,double,real
   ! DIMS 1,2
! Subprogram not used    subroutine subcol_field_avg_shr_2dreal(field_sc, ngrdcol, lchnk, field,  usefilter, useweight)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! This is the high level subcol field averaging routine which 
! Subprogram not used    ! averages a field dimensioned pcols*psubcols to a grid one dimensioned pcols 
! Subprogram not used    !  
! Subprogram not used    ! Its purpose is to check filter and weight settings and to subset the
! Subprogram not used    ! appropriate subsection of the field array to pass on the averaging routine
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       real(r4),intent(in)                      :: field_sc(:,:) ! intent in
! Subprogram not used       integer, intent(in)                     :: ngrdcol          ! # grid cols
! Subprogram not used       integer, intent(in)                     :: lchnk            ! chunk index
! Subprogram not used       real(r4), intent(out)                    :: field(:,:)
! Subprogram not used       logical, intent(in)                     :: usefilter
! Subprogram not used       logical, intent(in)                     :: useweight
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, nsubcol, i, j
! Subprogram not used       integer           :: nsubcols(pcols)
! Subprogram not used 
! Subprogram not used       field = ret_nan_real
! Subprogram not used      
! Subprogram not used       if (usefilter .and. .not. filter_set) then
! Subprogram not used         call endrun('subcol_field_avg_shr error: Cannot specify using filters when none set')
! Subprogram not used       end if
! Subprogram not used 
! Subprogram not used       if (useweight .and. .not. weight_set) then
! Subprogram not used         call endrun('subcol_field_avg_shr error: Cannot specify using weights when none set')
! Subprogram not used       end if
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcols)
! Subprogram not used       indx = 1
! Subprogram not used       do i = 1, ngrdcol
! Subprogram not used          if (nsubcols(i) .gt. 0) then
! Subprogram not used            nsubcol = nsubcols(i)
! Subprogram not used            do j=1,size(field_sc,dim=2)
! Subprogram not used              field(i,j)=subcol_avg_inter(field_sc(indx:indx+nsubcol-1,j), lchnk, i, indx, indx+nsubcol-1, usefilter, useweight)
! Subprogram not used            end do
! Subprogram not used            indx = indx + nsubcol
! Subprogram not used          end if
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_field_avg_shr_2dreal


   ! TYPE int,double,real
   ! DIMS 1,2
! Subprogram not used    subroutine subcol_field_get_firstsubcol_1dint(field_sc, docheck, ngrdcol, lchnk, field)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Retrieve the first subcolumn from a field dimensioned pcols*psubcols 
! Subprogram not used    ! and assign to one with pcols, performing optional checking that all other subcolumns are identical
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer(i4), intent(in)                     :: field_sc(:) ! intent in
! Subprogram not used       logical, intent(in)                     :: docheck          ! true=check, false=no check
! Subprogram not used       integer, intent(in)                     :: ngrdcol          ! # grid cols
! Subprogram not used       integer, intent(in)                     :: lchnk            ! chunk index
! Subprogram not used       integer(i4), intent(out)                    :: field(:)
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, nsubcol, i, j, l
! Subprogram not used       integer           :: nsubcols(pcols)
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcols)
! Subprogram not used       field = 0
! Subprogram not used       indx = 1
! Subprogram not used       do i = 1, ngrdcol
! Subprogram not used          if (nsubcols(i) .gt. 0) then
! Subprogram not used             nsubcol = nsubcols(i)
! Subprogram not used 
! Subprogram not used                field(i) = field_sc(indx)
! Subprogram not used                if (docheck) then
! Subprogram not used                   do l=1,nsubcol-1
! Subprogram not used                     if (field_sc(indx) /= field_sc(indx+l)) then
! Subprogram not used                       call endrun('subcol_field_get_firstsubcol error: Not all subcolumn fields are identical')
! Subprogram not used                     end if
! Subprogram not used                   end do
! Subprogram not used                end if
! Subprogram not used             indx = indx + nsubcol
! Subprogram not used          end if
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_field_get_firstsubcol_1dint
   ! TYPE int,double,real
   ! DIMS 1,2
! Subprogram not used    subroutine subcol_field_get_firstsubcol_2dint(field_sc, docheck, ngrdcol, lchnk, field)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Retrieve the first subcolumn from a field dimensioned pcols*psubcols 
! Subprogram not used    ! and assign to one with pcols, performing optional checking that all other subcolumns are identical
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer(i4), intent(in)                     :: field_sc(:,:) ! intent in
! Subprogram not used       logical, intent(in)                     :: docheck          ! true=check, false=no check
! Subprogram not used       integer, intent(in)                     :: ngrdcol          ! # grid cols
! Subprogram not used       integer, intent(in)                     :: lchnk            ! chunk index
! Subprogram not used       integer(i4), intent(out)                    :: field(:,:)
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, nsubcol, i, j, l
! Subprogram not used       integer           :: nsubcols(pcols)
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcols)
! Subprogram not used       field = 0
! Subprogram not used       indx = 1
! Subprogram not used       do i = 1, ngrdcol
! Subprogram not used          if (nsubcols(i) .gt. 0) then
! Subprogram not used             nsubcol = nsubcols(i)
! Subprogram not used             do j=1,size(field_sc,dim=2)
! Subprogram not used 
! Subprogram not used                field(i,j) = field_sc(indx,j)
! Subprogram not used                if (docheck) then
! Subprogram not used                   do l=1,nsubcol-1
! Subprogram not used                     if (field_sc(indx,j) /= field_sc(indx+l,j)) then
! Subprogram not used                       call endrun('subcol_field_get_firstsubcol error: Not all subcolumn fields are identical')
! Subprogram not used                     end if
! Subprogram not used                   end do
! Subprogram not used                end if
! Subprogram not used             end do
! Subprogram not used             indx = indx + nsubcol
! Subprogram not used          end if
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_field_get_firstsubcol_2dint
   ! TYPE int,double,real
   ! DIMS 1,2
! Subprogram not used    subroutine subcol_field_get_firstsubcol_1ddouble(field_sc, docheck, ngrdcol, lchnk, field)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Retrieve the first subcolumn from a field dimensioned pcols*psubcols 
! Subprogram not used    ! and assign to one with pcols, performing optional checking that all other subcolumns are identical
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       real(r8), intent(in)                     :: field_sc(:) ! intent in
! Subprogram not used       logical, intent(in)                     :: docheck          ! true=check, false=no check
! Subprogram not used       integer, intent(in)                     :: ngrdcol          ! # grid cols
! Subprogram not used       integer, intent(in)                     :: lchnk            ! chunk index
! Subprogram not used       real(r8), intent(out)                    :: field(:)
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, nsubcol, i, j, l
! Subprogram not used       integer           :: nsubcols(pcols)
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcols)
! Subprogram not used       field = 0
! Subprogram not used       indx = 1
! Subprogram not used       do i = 1, ngrdcol
! Subprogram not used          if (nsubcols(i) .gt. 0) then
! Subprogram not used             nsubcol = nsubcols(i)
! Subprogram not used 
! Subprogram not used                field(i) = field_sc(indx)
! Subprogram not used                if (docheck) then
! Subprogram not used                   do l=1,nsubcol-1
! Subprogram not used                     if (field_sc(indx) /= field_sc(indx+l)) then
! Subprogram not used                       call endrun('subcol_field_get_firstsubcol error: Not all subcolumn fields are identical')
! Subprogram not used                     end if
! Subprogram not used                   end do
! Subprogram not used                end if
! Subprogram not used             indx = indx + nsubcol
! Subprogram not used          end if
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_field_get_firstsubcol_1ddouble
   ! TYPE int,double,real
   ! DIMS 1,2
! Subprogram not used    subroutine subcol_field_get_firstsubcol_2ddouble(field_sc, docheck, ngrdcol, lchnk, field)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Retrieve the first subcolumn from a field dimensioned pcols*psubcols 
! Subprogram not used    ! and assign to one with pcols, performing optional checking that all other subcolumns are identical
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       real(r8), intent(in)                     :: field_sc(:,:) ! intent in
! Subprogram not used       logical, intent(in)                     :: docheck          ! true=check, false=no check
! Subprogram not used       integer, intent(in)                     :: ngrdcol          ! # grid cols
! Subprogram not used       integer, intent(in)                     :: lchnk            ! chunk index
! Subprogram not used       real(r8), intent(out)                    :: field(:,:)
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, nsubcol, i, j, l
! Subprogram not used       integer           :: nsubcols(pcols)
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcols)
! Subprogram not used       field = 0
! Subprogram not used       indx = 1
! Subprogram not used       do i = 1, ngrdcol
! Subprogram not used          if (nsubcols(i) .gt. 0) then
! Subprogram not used             nsubcol = nsubcols(i)
! Subprogram not used             do j=1,size(field_sc,dim=2)
! Subprogram not used 
! Subprogram not used                field(i,j) = field_sc(indx,j)
! Subprogram not used                if (docheck) then
! Subprogram not used                   do l=1,nsubcol-1
! Subprogram not used                     if (field_sc(indx,j) /= field_sc(indx+l,j)) then
! Subprogram not used                       call endrun('subcol_field_get_firstsubcol error: Not all subcolumn fields are identical')
! Subprogram not used                     end if
! Subprogram not used                   end do
! Subprogram not used                end if
! Subprogram not used             end do
! Subprogram not used             indx = indx + nsubcol
! Subprogram not used          end if
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_field_get_firstsubcol_2ddouble
   ! TYPE int,double,real
   ! DIMS 1,2
! Subprogram not used    subroutine subcol_field_get_firstsubcol_1dreal(field_sc, docheck, ngrdcol, lchnk, field)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Retrieve the first subcolumn from a field dimensioned pcols*psubcols 
! Subprogram not used    ! and assign to one with pcols, performing optional checking that all other subcolumns are identical
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       real(r4), intent(in)                     :: field_sc(:) ! intent in
! Subprogram not used       logical, intent(in)                     :: docheck          ! true=check, false=no check
! Subprogram not used       integer, intent(in)                     :: ngrdcol          ! # grid cols
! Subprogram not used       integer, intent(in)                     :: lchnk            ! chunk index
! Subprogram not used       real(r4), intent(out)                    :: field(:)
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, nsubcol, i, j, l
! Subprogram not used       integer           :: nsubcols(pcols)
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcols)
! Subprogram not used       field = 0
! Subprogram not used       indx = 1
! Subprogram not used       do i = 1, ngrdcol
! Subprogram not used          if (nsubcols(i) .gt. 0) then
! Subprogram not used             nsubcol = nsubcols(i)
! Subprogram not used 
! Subprogram not used                field(i) = field_sc(indx)
! Subprogram not used                if (docheck) then
! Subprogram not used                   do l=1,nsubcol-1
! Subprogram not used                     if (field_sc(indx) /= field_sc(indx+l)) then
! Subprogram not used                       call endrun('subcol_field_get_firstsubcol error: Not all subcolumn fields are identical')
! Subprogram not used                     end if
! Subprogram not used                   end do
! Subprogram not used                end if
! Subprogram not used             indx = indx + nsubcol
! Subprogram not used          end if
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_field_get_firstsubcol_1dreal
   ! TYPE int,double,real
   ! DIMS 1,2
! Subprogram not used    subroutine subcol_field_get_firstsubcol_2dreal(field_sc, docheck, ngrdcol, lchnk, field)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Retrieve the first subcolumn from a field dimensioned pcols*psubcols 
! Subprogram not used    ! and assign to one with pcols, performing optional checking that all other subcolumns are identical
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       real(r4), intent(in)                     :: field_sc(:,:) ! intent in
! Subprogram not used       logical, intent(in)                     :: docheck          ! true=check, false=no check
! Subprogram not used       integer, intent(in)                     :: ngrdcol          ! # grid cols
! Subprogram not used       integer, intent(in)                     :: lchnk            ! chunk index
! Subprogram not used       real(r4), intent(out)                    :: field(:,:)
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, nsubcol, i, j, l
! Subprogram not used       integer           :: nsubcols(pcols)
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcols)
! Subprogram not used       field = 0
! Subprogram not used       indx = 1
! Subprogram not used       do i = 1, ngrdcol
! Subprogram not used          if (nsubcols(i) .gt. 0) then
! Subprogram not used             nsubcol = nsubcols(i)
! Subprogram not used             do j=1,size(field_sc,dim=2)
! Subprogram not used 
! Subprogram not used                field(i,j) = field_sc(indx,j)
! Subprogram not used                if (docheck) then
! Subprogram not used                   do l=1,nsubcol-1
! Subprogram not used                     if (field_sc(indx,j) /= field_sc(indx+l,j)) then
! Subprogram not used                       call endrun('subcol_field_get_firstsubcol error: Not all subcolumn fields are identical')
! Subprogram not used                     end if
! Subprogram not used                   end do
! Subprogram not used                end if
! Subprogram not used             end do
! Subprogram not used             indx = indx + nsubcol
! Subprogram not used          end if
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_field_get_firstsubcol_2dreal

   subroutine subcol_ptend_avg_shr(ptend_sc, ngrdcol, lchnk, ptend, usefilter, useweight)
   !-----------------------------------------------------------------------
   ! Average a subcolumn ptend to a grid ptend
   !-----------------------------------------------------------------------

      type(physics_ptend),  intent(in)    :: ptend_sc      ! subcolumn ptend 
      integer,              intent(in)    :: ngrdcol       ! # grid cols
      integer,              intent(in)    :: lchnk         ! chunk index
      type(physics_ptend),  intent(inout) :: ptend         ! grid ptend
      logical,              intent(in)    :: usefilter
      logical,              intent(in)    :: useweight

      !
      ! Local variables
      !
      integer           :: indx, i, j, k, nsubcol
      integer           :: nsubcols(pcols)

      if (usefilter .and. .not. filter_set) then
         call endrun('subcol_ptend_avg_shr error: Cannot specify using filters when none set')
      end if

      if (useweight .and. .not. weight_set) then
         call endrun('subcol_ptend_avg_shr error: Cannot specify using weights when none set')
      end if

      call subcol_get_nsubcol(lchnk, nsubcols)
      ! physics_ptend_init has already been called by the master interface
      if (ptend%ls) then
         ptend%s(:,:)        = 0._r8
         ptend%hflux_srf(:)  = 0._r8
         ptend%hflux_top(:)  = 0._r8
         indx = 1
         do i = 1, ngrdcol
            if (nsubcols(i) > 0) then
               nsubcol = nsubcols(i)
               do j=1,pver
                  ptend%s(i,j)=subcol_avg_inter(ptend_sc%s(indx:indx+nsubcol-1,j), &
                       lchnk, i, indx, indx+nsubcol-1, usefilter, useweight)
               end do
               ptend%hflux_srf(i) = subcol_avg_inter(ptend_sc%hflux_srf(indx:indx+nsubcol-1), &
                    lchnk, i, indx, indx+nsubcol-1, usefilter, useweight)
               ptend%hflux_top(i) = subcol_avg_inter(ptend_sc%hflux_top(indx:indx+nsubcol-1), &
                    lchnk, i, indx, indx+nsubcol-1, usefilter, useweight)
               indx = indx + nsubcol
            end if
         end do
      end if
      if (ptend%lu) then
         ptend%u(:,:)       = 0._r8
         ptend%taux_srf(:)  = 0._r8
         ptend%taux_top(:)  = 0._r8
         indx = 1
         do i = 1, ngrdcol
            if (nsubcols(i) > 0) then
               nsubcol = nsubcols(i)
               do j=1,pver
                  ptend%u(i,j)=subcol_avg_inter(ptend_sc%u(indx:indx+nsubcol-1,j), &
                       lchnk, i, indx, indx+nsubcol-1, usefilter, useweight)
               end do
               ptend%taux_srf(i) = subcol_avg_inter(ptend_sc%taux_srf(indx:indx+nsubcol-1), &
                    lchnk, i, indx, indx+nsubcol-1, usefilter, useweight)
               ptend%taux_top(i) = subcol_avg_inter(ptend_sc%taux_top(indx:indx+nsubcol-1), &
                    lchnk, i, indx, indx+nsubcol-1, usefilter, useweight)
               indx = indx + nsubcol
            end if
         end do
      end if
      if (ptend%lv) then
         ptend%v(:,:)       = 0._r8
         ptend%tauy_srf(:)  = 0._r8
         ptend%tauy_top(:)  = 0._r8
         indx = 1
         do i = 1, ngrdcol
            if (nsubcols(i) > 0) then
               nsubcol = nsubcols(i)
               do j=1,pver
                  ptend%v(i,j)=subcol_avg_inter(ptend_sc%v(indx:indx+nsubcol-1,j), &
                       lchnk, i, indx, indx+nsubcol-1, usefilter, useweight)
               end do
               ptend%tauy_srf(i) = subcol_avg_inter(ptend_sc%tauy_srf(indx:indx+nsubcol-1), &
                    lchnk, i, indx, indx+nsubcol-1, usefilter, useweight)
               ptend%tauy_top(i) = subcol_avg_inter(ptend_sc%tauy_top(indx:indx+nsubcol-1), &
                    lchnk, i, indx, indx+nsubcol-1, usefilter, useweight)
               indx = indx + nsubcol
            end if
         end do
      end if
      if (any(ptend%lq(:))) then
         ptend%q(:,:,:)       = 0._r8
         ptend%cflx_srf(:,:)  = 0._r8
         ptend%cflx_top(:,:)  = 0._r8
         indx = 1
         do i = 1, ngrdcol
            if (nsubcols(i) > 0) then
               nsubcol = nsubcols(i)
               do j=1,pver
                  do k=1, pcnst
                     ptend%q(i,j,k)=subcol_avg_inter(ptend_sc%q(indx:indx+nsubcol-1,j,k), &
                          lchnk, i, indx, indx+nsubcol-1, usefilter, useweight)
                  end do
               end do
               do k=1,pcnst
                  ptend%cflx_srf(i,k) = subcol_avg_inter(ptend_sc%cflx_srf(indx:indx+nsubcol-1,k), &
                       lchnk, i, indx, indx+nsubcol-1, usefilter, useweight)
                  ptend%cflx_top(i,k) = subcol_avg_inter(ptend_sc%cflx_top(indx:indx+nsubcol-1,k), &
                       lchnk, i, indx, indx+nsubcol-1, usefilter, useweight)
               end do
               indx = indx + nsubcol
            end if
         end do
      end if

   end subroutine subcol_ptend_avg_shr

   subroutine subcol_ptend_get_firstsubcol(ptend_sc, docheck, ngrdcol, lchnk, ptend)
   !-----------------------------------------------------------------------
   ! Retrieve the first subcolumn from a ptend field dimensioned pcols*psubcols 
   ! and assign to one with pcols, performing optional check that all other subcolumns are identical
   !-----------------------------------------------------------------------

      type(physics_ptend),  intent(in)    :: ptend_sc      ! subcolumn ptend 
      logical,              intent(in)    :: docheck       ! perform check that all subcolumns match
      integer,              intent(in)    :: ngrdcol       ! # grid cols
      integer,              intent(in)    :: lchnk         ! chunk index
      type(physics_ptend),  intent(inout) :: ptend         ! grid ptend

      !
      ! Local variables
      !
      integer           :: indx, i, j, l
      integer           :: nsubcols(pcols)

      call subcol_get_nsubcol(lchnk, nsubcols)
      ! physics_ptend_init has already been called by the master interface
      if (ptend%ls) then
         ptend%s(:,:)       = 0._r8
         ptend%hflux_srf(:) = 0._r8
         ptend%hflux_top(:) = 0._r8
         indx = 1
         do i = 1, ngrdcol
            if (docheck) then
               do l=1,nsubcols(i)-1
                 if (any(ptend_sc%s(indx,:) /= ptend_sc%s(indx+l,:))) &
                    call endrun('subcol_ptend_get_firstsubcol error: Not all subcolumn fields are identical for ptend%s')
                 if (ptend_sc%hflux_srf(indx) /= ptend_sc%hflux_srf(indx+l)) &
                    call endrun('subcol_ptend_get_firstsubcol error: Not all subcolumn fields are identical for ptend%hflux_srf')
                 if (ptend_sc%hflux_top(indx) /= ptend_sc%hflux_top(indx+l)) &
                    call endrun('subcol_ptend_get_firstsubcol error: Not all subcolumn fields are identical for ptend%hflux_top')
               end do
            end if
            ptend%s(i,:)          = ptend_sc%s(indx,:)
            ptend%hflux_srf(i)    = ptend_sc%hflux_srf(indx)
            ptend%hflux_top(i)    = ptend_sc%hflux_top(indx)
            indx = indx + nsubcols(i)
         end do
      end if
      if (ptend%lu) then
         ptend%u(:,:)       = 0._r8
         ptend%taux_srf(:)  = 0._r8
         ptend%taux_top(:)  = 0._r8
         indx = 1
         do i = 1, ngrdcol
            do l=1,nsubcols(i)-1
              if (any(ptend_sc%u(indx,:) /= ptend_sc%u(indx+l,:))) &
                   call endrun('subcol_ptend_get_firstsubcol error: Not all subcolumn fields are identical for ptend%u')
              if (ptend_sc%taux_srf(indx) /= ptend_sc%taux_srf(indx+l)) &
                   call endrun('subcol_ptend_get_firstsubcol error: Not all subcolumn fields are identical for ptend%taux_srf')
              if (ptend_sc%taux_top(indx) /= ptend_sc%taux_top(indx+l)) &
                   call endrun('subcol_ptend_get_firstsubcol error: Not all subcolumn fields are identical for ptend%taux_top')
            end do
            ptend%u(i,:)      = ptend_sc%u(indx,:)
            ptend%taux_srf(i) = ptend_sc%taux_srf(indx)
            ptend%taux_top(i) = ptend_sc%taux_top(indx)
            indx = indx + nsubcols(i)
         end do
      end if
      if (ptend%lv) then
         ptend%v(:,:)       = 0._r8
         ptend%tauy_srf(:)  = 0._r8
         ptend%tauy_top(:)  = 0._r8
         indx = 1
         do i = 1, ngrdcol
            do l=1,nsubcols(i)-1
              if (any(ptend_sc%v(indx,:) /= ptend_sc%v(indx+l,:))) &
                   call endrun('subcol_ptend_get_firstsubcol error: Not all subcolumn fields are identical for ptend%v')
              if (ptend_sc%tauy_srf(indx) /= ptend_sc%tauy_srf(indx+l)) &
                   call endrun('subcol_ptend_get_firstsubcol error: Not all subcolumn fields are identical for ptend%tauy_srf')
              if (ptend_sc%tauy_top(indx) /= ptend_sc%tauy_top(indx+l)) &
                   call endrun('subcol_ptend_get_firstsubcol error: Not all subcolumn fields are identical for ptend%tauy_top')
            end do
            ptend%v(i,:)         = ptend_sc%v(indx,:)
            ptend%tauy_srf(i)    = ptend_sc%tauy_srf(indx)
            ptend%tauy_top(i)    = ptend_sc%tauy_top(indx)
            indx = indx + nsubcols(i)
         end do
      end if
      if (any(ptend%lq(:))) then
         ptend%q(:,:,:)       = 0._r8
         ptend%cflx_srf(:,:)  = 0._r8
         ptend%cflx_top(:,:)  = 0._r8
         indx = 1
         do i = 1, ngrdcol
            do l=1,nsubcols(i)-1
              if (any(ptend_sc%q(indx,:,:) /= ptend_sc%q(indx+l,:,:))) &
                   call endrun('subcol_ptend_get_firstsubcol error: Not all subcolumn fields are identical for ptend%q')
              if (any(ptend_sc%cflx_srf(indx,:) /= ptend_sc%cflx_srf(indx+l,:))) &
                   call endrun('subcol_ptend_get_firstsubcol error: Not all subcolumn fields are identical for ptend%cflx_srf')
              if (any(ptend_sc%cflx_top(indx,:) /= ptend_sc%cflx_top(indx+l,:))) &
                   call endrun('subcol_ptend_get_firstsubcol error: Not all subcolumn fields are identical for ptend%cflx_top')
            end do
            ptend%q(i,:,:)         = ptend_sc%q(indx,:,:)
            ptend%cflx_srf(i,:)    = ptend_sc%cflx_srf(indx,:)
            ptend%cflx_top(i,:)    = ptend_sc%cflx_top(indx,:)
            indx = indx + nsubcols(i)
         end do
      end if

   end subroutine subcol_ptend_get_firstsubcol


   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5,6
! Subprogram not used    subroutine subcol_pack_1d_int(lchnk, field, field_sc)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Pack the field defined on (pcols, psubcols, *) into (pcols*psubcols, *)
! Subprogram not used    ! Packing is done accoding to the values in the proper chunk from nsubcol2d
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer, intent(in)                     :: lchnk            ! Chunk index
! Subprogram not used       integer(i4), intent(in)                     :: field(:,:)           ! grid
! Subprogram not used       integer(i4), intent(out)                    :: field_sc(:)     ! subcols
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, i, j
! Subprogram not used       integer           :: nsubcol(pcols)
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcol)
! Subprogram not used       indx = 1
! Subprogram not used       do i=1, pcols
! Subprogram not used          do j = 1, nsubcol(i)
! Subprogram not used             field_sc(indx) = field(i, j)
! Subprogram not used             indx = indx + 1
! Subprogram not used          end do
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_pack_1d_int
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5,6
! Subprogram not used    subroutine subcol_pack_2d_int(lchnk, field, field_sc)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Pack the field defined on (pcols, psubcols, *) into (pcols*psubcols, *)
! Subprogram not used    ! Packing is done accoding to the values in the proper chunk from nsubcol2d
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer, intent(in)                     :: lchnk            ! Chunk index
! Subprogram not used       integer(i4), intent(in)                     :: field(:,:,:)         ! grid
! Subprogram not used       integer(i4), intent(out)                    :: field_sc(:,:)     ! subcols
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, i, j
! Subprogram not used       integer           :: nsubcol(pcols)
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcol)
! Subprogram not used       indx = 1
! Subprogram not used       do i=1, pcols
! Subprogram not used          do j = 1, nsubcol(i)
! Subprogram not used             field_sc(indx, :) = field(i, j, :)
! Subprogram not used             indx = indx + 1
! Subprogram not used          end do
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_pack_2d_int
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5,6
! Subprogram not used    subroutine subcol_pack_3d_int(lchnk, field, field_sc)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Pack the field defined on (pcols, psubcols, *) into (pcols*psubcols, *)
! Subprogram not used    ! Packing is done accoding to the values in the proper chunk from nsubcol2d
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer, intent(in)                     :: lchnk            ! Chunk index
! Subprogram not used       integer(i4), intent(in)                     :: field(:,:,:,:)       ! grid
! Subprogram not used       integer(i4), intent(out)                    :: field_sc(:,:,:)     ! subcols
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, i, j
! Subprogram not used       integer           :: nsubcol(pcols)
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcol)
! Subprogram not used       indx = 1
! Subprogram not used       do i=1, pcols
! Subprogram not used          do j = 1, nsubcol(i)
! Subprogram not used             field_sc(indx, :, :) = field(i, j, :, :)
! Subprogram not used             indx = indx + 1
! Subprogram not used          end do
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_pack_3d_int
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5,6
! Subprogram not used    subroutine subcol_pack_4d_int(lchnk, field, field_sc)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Pack the field defined on (pcols, psubcols, *) into (pcols*psubcols, *)
! Subprogram not used    ! Packing is done accoding to the values in the proper chunk from nsubcol2d
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer, intent(in)                     :: lchnk            ! Chunk index
! Subprogram not used       integer(i4), intent(in)                     :: field(:,:,:,:,:)     ! grid
! Subprogram not used       integer(i4), intent(out)                    :: field_sc(:,:,:,:)     ! subcols
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, i, j
! Subprogram not used       integer           :: nsubcol(pcols)
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcol)
! Subprogram not used       indx = 1
! Subprogram not used       do i=1, pcols
! Subprogram not used          do j = 1, nsubcol(i)
! Subprogram not used             field_sc(indx, :, :, :) = field(i, j, :, :, :)
! Subprogram not used             indx = indx + 1
! Subprogram not used          end do
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_pack_4d_int
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5,6
! Subprogram not used    subroutine subcol_pack_5d_int(lchnk, field, field_sc)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Pack the field defined on (pcols, psubcols, *) into (pcols*psubcols, *)
! Subprogram not used    ! Packing is done accoding to the values in the proper chunk from nsubcol2d
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer, intent(in)                     :: lchnk            ! Chunk index
! Subprogram not used       integer(i4), intent(in)                     :: field(:,:,:,:,:,:)   ! grid
! Subprogram not used       integer(i4), intent(out)                    :: field_sc(:,:,:,:,:)     ! subcols
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, i, j
! Subprogram not used       integer           :: nsubcol(pcols)
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcol)
! Subprogram not used       indx = 1
! Subprogram not used       do i=1, pcols
! Subprogram not used          do j = 1, nsubcol(i)
! Subprogram not used             field_sc(indx, :, :, :, :) = field(i, j, :, :, :, :)
! Subprogram not used             indx = indx + 1
! Subprogram not used          end do
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_pack_5d_int
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5,6
! Subprogram not used    subroutine subcol_pack_6d_int(lchnk, field, field_sc)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Pack the field defined on (pcols, psubcols, *) into (pcols*psubcols, *)
! Subprogram not used    ! Packing is done accoding to the values in the proper chunk from nsubcol2d
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer, intent(in)                     :: lchnk            ! Chunk index
! Subprogram not used       integer(i4), intent(in)                     :: field(:,:,:,:,:,:,:) ! grid
! Subprogram not used       integer(i4), intent(out)                    :: field_sc(:,:,:,:,:,:)     ! subcols
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, i, j
! Subprogram not used       integer           :: nsubcol(pcols)
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcol)
! Subprogram not used       indx = 1
! Subprogram not used       do i=1, pcols
! Subprogram not used          do j = 1, nsubcol(i)
! Subprogram not used             field_sc(indx, :, :, :, :, :) = field(i, j, :, :, :, :, :)
! Subprogram not used             indx = indx + 1
! Subprogram not used          end do
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_pack_6d_int
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5,6
! Subprogram not used    subroutine subcol_pack_1d_double(lchnk, field, field_sc)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Pack the field defined on (pcols, psubcols, *) into (pcols*psubcols, *)
! Subprogram not used    ! Packing is done accoding to the values in the proper chunk from nsubcol2d
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer, intent(in)                     :: lchnk            ! Chunk index
! Subprogram not used       real(r8), intent(in)                     :: field(:,:)           ! grid
! Subprogram not used       real(r8), intent(out)                    :: field_sc(:)     ! subcols
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, i, j
! Subprogram not used       integer           :: nsubcol(pcols)
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcol)
! Subprogram not used       indx = 1
! Subprogram not used       do i=1, pcols
! Subprogram not used          do j = 1, nsubcol(i)
! Subprogram not used             field_sc(indx) = field(i, j)
! Subprogram not used             indx = indx + 1
! Subprogram not used          end do
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_pack_1d_double
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5,6
! Subprogram not used    subroutine subcol_pack_2d_double(lchnk, field, field_sc)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Pack the field defined on (pcols, psubcols, *) into (pcols*psubcols, *)
! Subprogram not used    ! Packing is done accoding to the values in the proper chunk from nsubcol2d
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer, intent(in)                     :: lchnk            ! Chunk index
! Subprogram not used       real(r8), intent(in)                     :: field(:,:,:)         ! grid
! Subprogram not used       real(r8), intent(out)                    :: field_sc(:,:)     ! subcols
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, i, j
! Subprogram not used       integer           :: nsubcol(pcols)
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcol)
! Subprogram not used       indx = 1
! Subprogram not used       do i=1, pcols
! Subprogram not used          do j = 1, nsubcol(i)
! Subprogram not used             field_sc(indx, :) = field(i, j, :)
! Subprogram not used             indx = indx + 1
! Subprogram not used          end do
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_pack_2d_double
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5,6
! Subprogram not used    subroutine subcol_pack_3d_double(lchnk, field, field_sc)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Pack the field defined on (pcols, psubcols, *) into (pcols*psubcols, *)
! Subprogram not used    ! Packing is done accoding to the values in the proper chunk from nsubcol2d
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer, intent(in)                     :: lchnk            ! Chunk index
! Subprogram not used       real(r8), intent(in)                     :: field(:,:,:,:)       ! grid
! Subprogram not used       real(r8), intent(out)                    :: field_sc(:,:,:)     ! subcols
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, i, j
! Subprogram not used       integer           :: nsubcol(pcols)
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcol)
! Subprogram not used       indx = 1
! Subprogram not used       do i=1, pcols
! Subprogram not used          do j = 1, nsubcol(i)
! Subprogram not used             field_sc(indx, :, :) = field(i, j, :, :)
! Subprogram not used             indx = indx + 1
! Subprogram not used          end do
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_pack_3d_double
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5,6
! Subprogram not used    subroutine subcol_pack_4d_double(lchnk, field, field_sc)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Pack the field defined on (pcols, psubcols, *) into (pcols*psubcols, *)
! Subprogram not used    ! Packing is done accoding to the values in the proper chunk from nsubcol2d
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer, intent(in)                     :: lchnk            ! Chunk index
! Subprogram not used       real(r8), intent(in)                     :: field(:,:,:,:,:)     ! grid
! Subprogram not used       real(r8), intent(out)                    :: field_sc(:,:,:,:)     ! subcols
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, i, j
! Subprogram not used       integer           :: nsubcol(pcols)
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcol)
! Subprogram not used       indx = 1
! Subprogram not used       do i=1, pcols
! Subprogram not used          do j = 1, nsubcol(i)
! Subprogram not used             field_sc(indx, :, :, :) = field(i, j, :, :, :)
! Subprogram not used             indx = indx + 1
! Subprogram not used          end do
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_pack_4d_double
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5,6
! Subprogram not used    subroutine subcol_pack_5d_double(lchnk, field, field_sc)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Pack the field defined on (pcols, psubcols, *) into (pcols*psubcols, *)
! Subprogram not used    ! Packing is done accoding to the values in the proper chunk from nsubcol2d
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer, intent(in)                     :: lchnk            ! Chunk index
! Subprogram not used       real(r8), intent(in)                     :: field(:,:,:,:,:,:)   ! grid
! Subprogram not used       real(r8), intent(out)                    :: field_sc(:,:,:,:,:)     ! subcols
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, i, j
! Subprogram not used       integer           :: nsubcol(pcols)
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcol)
! Subprogram not used       indx = 1
! Subprogram not used       do i=1, pcols
! Subprogram not used          do j = 1, nsubcol(i)
! Subprogram not used             field_sc(indx, :, :, :, :) = field(i, j, :, :, :, :)
! Subprogram not used             indx = indx + 1
! Subprogram not used          end do
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_pack_5d_double
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5,6
! Subprogram not used    subroutine subcol_pack_6d_double(lchnk, field, field_sc)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Pack the field defined on (pcols, psubcols, *) into (pcols*psubcols, *)
! Subprogram not used    ! Packing is done accoding to the values in the proper chunk from nsubcol2d
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer, intent(in)                     :: lchnk            ! Chunk index
! Subprogram not used       real(r8), intent(in)                     :: field(:,:,:,:,:,:,:) ! grid
! Subprogram not used       real(r8), intent(out)                    :: field_sc(:,:,:,:,:,:)     ! subcols
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, i, j
! Subprogram not used       integer           :: nsubcol(pcols)
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcol)
! Subprogram not used       indx = 1
! Subprogram not used       do i=1, pcols
! Subprogram not used          do j = 1, nsubcol(i)
! Subprogram not used             field_sc(indx, :, :, :, :, :) = field(i, j, :, :, :, :, :)
! Subprogram not used             indx = indx + 1
! Subprogram not used          end do
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_pack_6d_double
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5,6
! Subprogram not used    subroutine subcol_pack_1d_real(lchnk, field, field_sc)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Pack the field defined on (pcols, psubcols, *) into (pcols*psubcols, *)
! Subprogram not used    ! Packing is done accoding to the values in the proper chunk from nsubcol2d
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer, intent(in)                     :: lchnk            ! Chunk index
! Subprogram not used       real(r4), intent(in)                     :: field(:,:)           ! grid
! Subprogram not used       real(r4), intent(out)                    :: field_sc(:)     ! subcols
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, i, j
! Subprogram not used       integer           :: nsubcol(pcols)
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcol)
! Subprogram not used       indx = 1
! Subprogram not used       do i=1, pcols
! Subprogram not used          do j = 1, nsubcol(i)
! Subprogram not used             field_sc(indx) = field(i, j)
! Subprogram not used             indx = indx + 1
! Subprogram not used          end do
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_pack_1d_real
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5,6
! Subprogram not used    subroutine subcol_pack_2d_real(lchnk, field, field_sc)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Pack the field defined on (pcols, psubcols, *) into (pcols*psubcols, *)
! Subprogram not used    ! Packing is done accoding to the values in the proper chunk from nsubcol2d
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer, intent(in)                     :: lchnk            ! Chunk index
! Subprogram not used       real(r4), intent(in)                     :: field(:,:,:)         ! grid
! Subprogram not used       real(r4), intent(out)                    :: field_sc(:,:)     ! subcols
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, i, j
! Subprogram not used       integer           :: nsubcol(pcols)
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcol)
! Subprogram not used       indx = 1
! Subprogram not used       do i=1, pcols
! Subprogram not used          do j = 1, nsubcol(i)
! Subprogram not used             field_sc(indx, :) = field(i, j, :)
! Subprogram not used             indx = indx + 1
! Subprogram not used          end do
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_pack_2d_real
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5,6
! Subprogram not used    subroutine subcol_pack_3d_real(lchnk, field, field_sc)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Pack the field defined on (pcols, psubcols, *) into (pcols*psubcols, *)
! Subprogram not used    ! Packing is done accoding to the values in the proper chunk from nsubcol2d
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer, intent(in)                     :: lchnk            ! Chunk index
! Subprogram not used       real(r4), intent(in)                     :: field(:,:,:,:)       ! grid
! Subprogram not used       real(r4), intent(out)                    :: field_sc(:,:,:)     ! subcols
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, i, j
! Subprogram not used       integer           :: nsubcol(pcols)
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcol)
! Subprogram not used       indx = 1
! Subprogram not used       do i=1, pcols
! Subprogram not used          do j = 1, nsubcol(i)
! Subprogram not used             field_sc(indx, :, :) = field(i, j, :, :)
! Subprogram not used             indx = indx + 1
! Subprogram not used          end do
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_pack_3d_real
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5,6
! Subprogram not used    subroutine subcol_pack_4d_real(lchnk, field, field_sc)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Pack the field defined on (pcols, psubcols, *) into (pcols*psubcols, *)
! Subprogram not used    ! Packing is done accoding to the values in the proper chunk from nsubcol2d
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer, intent(in)                     :: lchnk            ! Chunk index
! Subprogram not used       real(r4), intent(in)                     :: field(:,:,:,:,:)     ! grid
! Subprogram not used       real(r4), intent(out)                    :: field_sc(:,:,:,:)     ! subcols
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, i, j
! Subprogram not used       integer           :: nsubcol(pcols)
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcol)
! Subprogram not used       indx = 1
! Subprogram not used       do i=1, pcols
! Subprogram not used          do j = 1, nsubcol(i)
! Subprogram not used             field_sc(indx, :, :, :) = field(i, j, :, :, :)
! Subprogram not used             indx = indx + 1
! Subprogram not used          end do
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_pack_4d_real
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5,6
! Subprogram not used    subroutine subcol_pack_5d_real(lchnk, field, field_sc)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Pack the field defined on (pcols, psubcols, *) into (pcols*psubcols, *)
! Subprogram not used    ! Packing is done accoding to the values in the proper chunk from nsubcol2d
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer, intent(in)                     :: lchnk            ! Chunk index
! Subprogram not used       real(r4), intent(in)                     :: field(:,:,:,:,:,:)   ! grid
! Subprogram not used       real(r4), intent(out)                    :: field_sc(:,:,:,:,:)     ! subcols
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, i, j
! Subprogram not used       integer           :: nsubcol(pcols)
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcol)
! Subprogram not used       indx = 1
! Subprogram not used       do i=1, pcols
! Subprogram not used          do j = 1, nsubcol(i)
! Subprogram not used             field_sc(indx, :, :, :, :) = field(i, j, :, :, :, :)
! Subprogram not used             indx = indx + 1
! Subprogram not used          end do
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_pack_5d_real
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5,6
! Subprogram not used    subroutine subcol_pack_6d_real(lchnk, field, field_sc)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! Pack the field defined on (pcols, psubcols, *) into (pcols*psubcols, *)
! Subprogram not used    ! Packing is done accoding to the values in the proper chunk from nsubcol2d
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer, intent(in)                     :: lchnk            ! Chunk index
! Subprogram not used       real(r4), intent(in)                     :: field(:,:,:,:,:,:,:) ! grid
! Subprogram not used       real(r4), intent(out)                    :: field_sc(:,:,:,:,:,:)     ! subcols
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, i, j
! Subprogram not used       integer           :: nsubcol(pcols)
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcol)
! Subprogram not used       indx = 1
! Subprogram not used       do i=1, pcols
! Subprogram not used          do j = 1, nsubcol(i)
! Subprogram not used             field_sc(indx, :, :, :, :, :) = field(i, j, :, :, :, :, :)
! Subprogram not used             indx = indx + 1
! Subprogram not used          end do
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_pack_6d_real

   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5,6
! Subprogram not used    subroutine subcol_unpack_1d_int(lchnk, field_sc, field, fillvalue)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! UnPack the field defined on (pcols*psubcols, *) into (pcols, psubcols, *)
! Subprogram not used    ! Unpacking is done accoding to the values in the proper chunk from nsubcol2d
! Subprogram not used    ! If fillvalue is present, unused entries in field are set.
! Subprogram not used    ! NB: The output field is not initialized, if fillvalue is not passed, it
! Subprogram not used    !     will end up with undefined values for columns where nsubcol < psubcols
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer, intent(in)                     :: lchnk            ! Chunk index
! Subprogram not used       integer(i4), intent(in)                     :: field_sc(:)     ! subcols
! Subprogram not used       integer(i4), intent(out)                    :: field(:,:)           ! grid
! Subprogram not used       integer(i4), intent(in), optional           :: fillvalue            ! fil
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, i, j
! Subprogram not used       integer           :: nsubcol(pcols)
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcol)
! Subprogram not used       indx = 1
! Subprogram not used       do i=1, pcols
! Subprogram not used          do j = 1, nsubcol(i)
! Subprogram not used             field(i, j) = field_sc(indx)
! Subprogram not used             indx = indx + 1
! Subprogram not used          end do
! Subprogram not used          if (present(fillvalue)) then
! Subprogram not used             do j = nsubcol(i) + 1, psubcols
! Subprogram not used                field(i, j) = fillvalue
! Subprogram not used             end do
! Subprogram not used          end if
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_unpack_1d_int
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5,6
! Subprogram not used    subroutine subcol_unpack_2d_int(lchnk, field_sc, field, fillvalue)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! UnPack the field defined on (pcols*psubcols, *) into (pcols, psubcols, *)
! Subprogram not used    ! Unpacking is done accoding to the values in the proper chunk from nsubcol2d
! Subprogram not used    ! If fillvalue is present, unused entries in field are set.
! Subprogram not used    ! NB: The output field is not initialized, if fillvalue is not passed, it
! Subprogram not used    !     will end up with undefined values for columns where nsubcol < psubcols
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer, intent(in)                     :: lchnk            ! Chunk index
! Subprogram not used       integer(i4), intent(in)                     :: field_sc(:,:)     ! subcols
! Subprogram not used       integer(i4), intent(out)                    :: field(:,:,:)         ! grid
! Subprogram not used       integer(i4), intent(in), optional           :: fillvalue            ! fil
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, i, j
! Subprogram not used       integer           :: nsubcol(pcols)
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcol)
! Subprogram not used       indx = 1
! Subprogram not used       do i=1, pcols
! Subprogram not used          do j = 1, nsubcol(i)
! Subprogram not used             field(i, j, :) = field_sc(indx, :)
! Subprogram not used             indx = indx + 1
! Subprogram not used          end do
! Subprogram not used          if (present(fillvalue)) then
! Subprogram not used             do j = nsubcol(i) + 1, psubcols
! Subprogram not used                field(i, j, :) = fillvalue
! Subprogram not used             end do
! Subprogram not used          end if
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_unpack_2d_int
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5,6
! Subprogram not used    subroutine subcol_unpack_3d_int(lchnk, field_sc, field, fillvalue)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! UnPack the field defined on (pcols*psubcols, *) into (pcols, psubcols, *)
! Subprogram not used    ! Unpacking is done accoding to the values in the proper chunk from nsubcol2d
! Subprogram not used    ! If fillvalue is present, unused entries in field are set.
! Subprogram not used    ! NB: The output field is not initialized, if fillvalue is not passed, it
! Subprogram not used    !     will end up with undefined values for columns where nsubcol < psubcols
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer, intent(in)                     :: lchnk            ! Chunk index
! Subprogram not used       integer(i4), intent(in)                     :: field_sc(:,:,:)     ! subcols
! Subprogram not used       integer(i4), intent(out)                    :: field(:,:,:,:)       ! grid
! Subprogram not used       integer(i4), intent(in), optional           :: fillvalue            ! fil
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, i, j
! Subprogram not used       integer           :: nsubcol(pcols)
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcol)
! Subprogram not used       indx = 1
! Subprogram not used       do i=1, pcols
! Subprogram not used          do j = 1, nsubcol(i)
! Subprogram not used             field(i, j, :, :) = field_sc(indx, :, :)
! Subprogram not used             indx = indx + 1
! Subprogram not used          end do
! Subprogram not used          if (present(fillvalue)) then
! Subprogram not used             do j = nsubcol(i) + 1, psubcols
! Subprogram not used                field(i, j, :, :) = fillvalue
! Subprogram not used             end do
! Subprogram not used          end if
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_unpack_3d_int
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5,6
! Subprogram not used    subroutine subcol_unpack_4d_int(lchnk, field_sc, field, fillvalue)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! UnPack the field defined on (pcols*psubcols, *) into (pcols, psubcols, *)
! Subprogram not used    ! Unpacking is done accoding to the values in the proper chunk from nsubcol2d
! Subprogram not used    ! If fillvalue is present, unused entries in field are set.
! Subprogram not used    ! NB: The output field is not initialized, if fillvalue is not passed, it
! Subprogram not used    !     will end up with undefined values for columns where nsubcol < psubcols
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer, intent(in)                     :: lchnk            ! Chunk index
! Subprogram not used       integer(i4), intent(in)                     :: field_sc(:,:,:,:)     ! subcols
! Subprogram not used       integer(i4), intent(out)                    :: field(:,:,:,:,:)     ! grid
! Subprogram not used       integer(i4), intent(in), optional           :: fillvalue            ! fil
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, i, j
! Subprogram not used       integer           :: nsubcol(pcols)
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcol)
! Subprogram not used       indx = 1
! Subprogram not used       do i=1, pcols
! Subprogram not used          do j = 1, nsubcol(i)
! Subprogram not used             field(i, j, :, :, :) = field_sc(indx, :, :, :)
! Subprogram not used             indx = indx + 1
! Subprogram not used          end do
! Subprogram not used          if (present(fillvalue)) then
! Subprogram not used             do j = nsubcol(i) + 1, psubcols
! Subprogram not used                field(i, j, :, :, :) = fillvalue
! Subprogram not used             end do
! Subprogram not used          end if
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_unpack_4d_int
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5,6
! Subprogram not used    subroutine subcol_unpack_5d_int(lchnk, field_sc, field, fillvalue)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! UnPack the field defined on (pcols*psubcols, *) into (pcols, psubcols, *)
! Subprogram not used    ! Unpacking is done accoding to the values in the proper chunk from nsubcol2d
! Subprogram not used    ! If fillvalue is present, unused entries in field are set.
! Subprogram not used    ! NB: The output field is not initialized, if fillvalue is not passed, it
! Subprogram not used    !     will end up with undefined values for columns where nsubcol < psubcols
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer, intent(in)                     :: lchnk            ! Chunk index
! Subprogram not used       integer(i4), intent(in)                     :: field_sc(:,:,:,:,:)     ! subcols
! Subprogram not used       integer(i4), intent(out)                    :: field(:,:,:,:,:,:)   ! grid
! Subprogram not used       integer(i4), intent(in), optional           :: fillvalue            ! fil
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, i, j
! Subprogram not used       integer           :: nsubcol(pcols)
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcol)
! Subprogram not used       indx = 1
! Subprogram not used       do i=1, pcols
! Subprogram not used          do j = 1, nsubcol(i)
! Subprogram not used             field(i, j, :, :, :, :) = field_sc(indx, :, :, :, :)
! Subprogram not used             indx = indx + 1
! Subprogram not used          end do
! Subprogram not used          if (present(fillvalue)) then
! Subprogram not used             do j = nsubcol(i) + 1, psubcols
! Subprogram not used                field(i, j, :, :, :, :) = fillvalue
! Subprogram not used             end do
! Subprogram not used          end if
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_unpack_5d_int
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5,6
! Subprogram not used    subroutine subcol_unpack_6d_int(lchnk, field_sc, field, fillvalue)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! UnPack the field defined on (pcols*psubcols, *) into (pcols, psubcols, *)
! Subprogram not used    ! Unpacking is done accoding to the values in the proper chunk from nsubcol2d
! Subprogram not used    ! If fillvalue is present, unused entries in field are set.
! Subprogram not used    ! NB: The output field is not initialized, if fillvalue is not passed, it
! Subprogram not used    !     will end up with undefined values for columns where nsubcol < psubcols
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer, intent(in)                     :: lchnk            ! Chunk index
! Subprogram not used       integer(i4), intent(in)                     :: field_sc(:,:,:,:,:,:)     ! subcols
! Subprogram not used       integer(i4), intent(out)                    :: field(:,:,:,:,:,:,:) ! grid
! Subprogram not used       integer(i4), intent(in), optional           :: fillvalue            ! fil
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, i, j
! Subprogram not used       integer           :: nsubcol(pcols)
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcol)
! Subprogram not used       indx = 1
! Subprogram not used       do i=1, pcols
! Subprogram not used          do j = 1, nsubcol(i)
! Subprogram not used             field(i, j, :, :, :, :, :) = field_sc(indx, :, :, :, :, :)
! Subprogram not used             indx = indx + 1
! Subprogram not used          end do
! Subprogram not used          if (present(fillvalue)) then
! Subprogram not used             do j = nsubcol(i) + 1, psubcols
! Subprogram not used                field(i, j, :, :, :, :, :) = fillvalue
! Subprogram not used             end do
! Subprogram not used          end if
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_unpack_6d_int
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5,6
! Subprogram not used    subroutine subcol_unpack_1d_double(lchnk, field_sc, field, fillvalue)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! UnPack the field defined on (pcols*psubcols, *) into (pcols, psubcols, *)
! Subprogram not used    ! Unpacking is done accoding to the values in the proper chunk from nsubcol2d
! Subprogram not used    ! If fillvalue is present, unused entries in field are set.
! Subprogram not used    ! NB: The output field is not initialized, if fillvalue is not passed, it
! Subprogram not used    !     will end up with undefined values for columns where nsubcol < psubcols
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer, intent(in)                     :: lchnk            ! Chunk index
! Subprogram not used       real(r8), intent(in)                     :: field_sc(:)     ! subcols
! Subprogram not used       real(r8), intent(out)                    :: field(:,:)           ! grid
! Subprogram not used       real(r8), intent(in), optional           :: fillvalue            ! fil
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, i, j
! Subprogram not used       integer           :: nsubcol(pcols)
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcol)
! Subprogram not used       indx = 1
! Subprogram not used       do i=1, pcols
! Subprogram not used          do j = 1, nsubcol(i)
! Subprogram not used             field(i, j) = field_sc(indx)
! Subprogram not used             indx = indx + 1
! Subprogram not used          end do
! Subprogram not used          if (present(fillvalue)) then
! Subprogram not used             do j = nsubcol(i) + 1, psubcols
! Subprogram not used                field(i, j) = fillvalue
! Subprogram not used             end do
! Subprogram not used          end if
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_unpack_1d_double
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5,6
! Subprogram not used    subroutine subcol_unpack_2d_double(lchnk, field_sc, field, fillvalue)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! UnPack the field defined on (pcols*psubcols, *) into (pcols, psubcols, *)
! Subprogram not used    ! Unpacking is done accoding to the values in the proper chunk from nsubcol2d
! Subprogram not used    ! If fillvalue is present, unused entries in field are set.
! Subprogram not used    ! NB: The output field is not initialized, if fillvalue is not passed, it
! Subprogram not used    !     will end up with undefined values for columns where nsubcol < psubcols
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer, intent(in)                     :: lchnk            ! Chunk index
! Subprogram not used       real(r8), intent(in)                     :: field_sc(:,:)     ! subcols
! Subprogram not used       real(r8), intent(out)                    :: field(:,:,:)         ! grid
! Subprogram not used       real(r8), intent(in), optional           :: fillvalue            ! fil
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, i, j
! Subprogram not used       integer           :: nsubcol(pcols)
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcol)
! Subprogram not used       indx = 1
! Subprogram not used       do i=1, pcols
! Subprogram not used          do j = 1, nsubcol(i)
! Subprogram not used             field(i, j, :) = field_sc(indx, :)
! Subprogram not used             indx = indx + 1
! Subprogram not used          end do
! Subprogram not used          if (present(fillvalue)) then
! Subprogram not used             do j = nsubcol(i) + 1, psubcols
! Subprogram not used                field(i, j, :) = fillvalue
! Subprogram not used             end do
! Subprogram not used          end if
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_unpack_2d_double
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5,6
! Subprogram not used    subroutine subcol_unpack_3d_double(lchnk, field_sc, field, fillvalue)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! UnPack the field defined on (pcols*psubcols, *) into (pcols, psubcols, *)
! Subprogram not used    ! Unpacking is done accoding to the values in the proper chunk from nsubcol2d
! Subprogram not used    ! If fillvalue is present, unused entries in field are set.
! Subprogram not used    ! NB: The output field is not initialized, if fillvalue is not passed, it
! Subprogram not used    !     will end up with undefined values for columns where nsubcol < psubcols
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer, intent(in)                     :: lchnk            ! Chunk index
! Subprogram not used       real(r8), intent(in)                     :: field_sc(:,:,:)     ! subcols
! Subprogram not used       real(r8), intent(out)                    :: field(:,:,:,:)       ! grid
! Subprogram not used       real(r8), intent(in), optional           :: fillvalue            ! fil
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, i, j
! Subprogram not used       integer           :: nsubcol(pcols)
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcol)
! Subprogram not used       indx = 1
! Subprogram not used       do i=1, pcols
! Subprogram not used          do j = 1, nsubcol(i)
! Subprogram not used             field(i, j, :, :) = field_sc(indx, :, :)
! Subprogram not used             indx = indx + 1
! Subprogram not used          end do
! Subprogram not used          if (present(fillvalue)) then
! Subprogram not used             do j = nsubcol(i) + 1, psubcols
! Subprogram not used                field(i, j, :, :) = fillvalue
! Subprogram not used             end do
! Subprogram not used          end if
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_unpack_3d_double
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5,6
! Subprogram not used    subroutine subcol_unpack_4d_double(lchnk, field_sc, field, fillvalue)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! UnPack the field defined on (pcols*psubcols, *) into (pcols, psubcols, *)
! Subprogram not used    ! Unpacking is done accoding to the values in the proper chunk from nsubcol2d
! Subprogram not used    ! If fillvalue is present, unused entries in field are set.
! Subprogram not used    ! NB: The output field is not initialized, if fillvalue is not passed, it
! Subprogram not used    !     will end up with undefined values for columns where nsubcol < psubcols
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer, intent(in)                     :: lchnk            ! Chunk index
! Subprogram not used       real(r8), intent(in)                     :: field_sc(:,:,:,:)     ! subcols
! Subprogram not used       real(r8), intent(out)                    :: field(:,:,:,:,:)     ! grid
! Subprogram not used       real(r8), intent(in), optional           :: fillvalue            ! fil
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, i, j
! Subprogram not used       integer           :: nsubcol(pcols)
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcol)
! Subprogram not used       indx = 1
! Subprogram not used       do i=1, pcols
! Subprogram not used          do j = 1, nsubcol(i)
! Subprogram not used             field(i, j, :, :, :) = field_sc(indx, :, :, :)
! Subprogram not used             indx = indx + 1
! Subprogram not used          end do
! Subprogram not used          if (present(fillvalue)) then
! Subprogram not used             do j = nsubcol(i) + 1, psubcols
! Subprogram not used                field(i, j, :, :, :) = fillvalue
! Subprogram not used             end do
! Subprogram not used          end if
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_unpack_4d_double
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5,6
! Subprogram not used    subroutine subcol_unpack_5d_double(lchnk, field_sc, field, fillvalue)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! UnPack the field defined on (pcols*psubcols, *) into (pcols, psubcols, *)
! Subprogram not used    ! Unpacking is done accoding to the values in the proper chunk from nsubcol2d
! Subprogram not used    ! If fillvalue is present, unused entries in field are set.
! Subprogram not used    ! NB: The output field is not initialized, if fillvalue is not passed, it
! Subprogram not used    !     will end up with undefined values for columns where nsubcol < psubcols
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer, intent(in)                     :: lchnk            ! Chunk index
! Subprogram not used       real(r8), intent(in)                     :: field_sc(:,:,:,:,:)     ! subcols
! Subprogram not used       real(r8), intent(out)                    :: field(:,:,:,:,:,:)   ! grid
! Subprogram not used       real(r8), intent(in), optional           :: fillvalue            ! fil
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, i, j
! Subprogram not used       integer           :: nsubcol(pcols)
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcol)
! Subprogram not used       indx = 1
! Subprogram not used       do i=1, pcols
! Subprogram not used          do j = 1, nsubcol(i)
! Subprogram not used             field(i, j, :, :, :, :) = field_sc(indx, :, :, :, :)
! Subprogram not used             indx = indx + 1
! Subprogram not used          end do
! Subprogram not used          if (present(fillvalue)) then
! Subprogram not used             do j = nsubcol(i) + 1, psubcols
! Subprogram not used                field(i, j, :, :, :, :) = fillvalue
! Subprogram not used             end do
! Subprogram not used          end if
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_unpack_5d_double
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5,6
! Subprogram not used    subroutine subcol_unpack_6d_double(lchnk, field_sc, field, fillvalue)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! UnPack the field defined on (pcols*psubcols, *) into (pcols, psubcols, *)
! Subprogram not used    ! Unpacking is done accoding to the values in the proper chunk from nsubcol2d
! Subprogram not used    ! If fillvalue is present, unused entries in field are set.
! Subprogram not used    ! NB: The output field is not initialized, if fillvalue is not passed, it
! Subprogram not used    !     will end up with undefined values for columns where nsubcol < psubcols
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer, intent(in)                     :: lchnk            ! Chunk index
! Subprogram not used       real(r8), intent(in)                     :: field_sc(:,:,:,:,:,:)     ! subcols
! Subprogram not used       real(r8), intent(out)                    :: field(:,:,:,:,:,:,:) ! grid
! Subprogram not used       real(r8), intent(in), optional           :: fillvalue            ! fil
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, i, j
! Subprogram not used       integer           :: nsubcol(pcols)
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcol)
! Subprogram not used       indx = 1
! Subprogram not used       do i=1, pcols
! Subprogram not used          do j = 1, nsubcol(i)
! Subprogram not used             field(i, j, :, :, :, :, :) = field_sc(indx, :, :, :, :, :)
! Subprogram not used             indx = indx + 1
! Subprogram not used          end do
! Subprogram not used          if (present(fillvalue)) then
! Subprogram not used             do j = nsubcol(i) + 1, psubcols
! Subprogram not used                field(i, j, :, :, :, :, :) = fillvalue
! Subprogram not used             end do
! Subprogram not used          end if
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_unpack_6d_double
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5,6
! Subprogram not used    subroutine subcol_unpack_1d_real(lchnk, field_sc, field, fillvalue)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! UnPack the field defined on (pcols*psubcols, *) into (pcols, psubcols, *)
! Subprogram not used    ! Unpacking is done accoding to the values in the proper chunk from nsubcol2d
! Subprogram not used    ! If fillvalue is present, unused entries in field are set.
! Subprogram not used    ! NB: The output field is not initialized, if fillvalue is not passed, it
! Subprogram not used    !     will end up with undefined values for columns where nsubcol < psubcols
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer, intent(in)                     :: lchnk            ! Chunk index
! Subprogram not used       real(r4), intent(in)                     :: field_sc(:)     ! subcols
! Subprogram not used       real(r4), intent(out)                    :: field(:,:)           ! grid
! Subprogram not used       real(r4), intent(in), optional           :: fillvalue            ! fil
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, i, j
! Subprogram not used       integer           :: nsubcol(pcols)
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcol)
! Subprogram not used       indx = 1
! Subprogram not used       do i=1, pcols
! Subprogram not used          do j = 1, nsubcol(i)
! Subprogram not used             field(i, j) = field_sc(indx)
! Subprogram not used             indx = indx + 1
! Subprogram not used          end do
! Subprogram not used          if (present(fillvalue)) then
! Subprogram not used             do j = nsubcol(i) + 1, psubcols
! Subprogram not used                field(i, j) = fillvalue
! Subprogram not used             end do
! Subprogram not used          end if
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_unpack_1d_real
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5,6
! Subprogram not used    subroutine subcol_unpack_2d_real(lchnk, field_sc, field, fillvalue)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! UnPack the field defined on (pcols*psubcols, *) into (pcols, psubcols, *)
! Subprogram not used    ! Unpacking is done accoding to the values in the proper chunk from nsubcol2d
! Subprogram not used    ! If fillvalue is present, unused entries in field are set.
! Subprogram not used    ! NB: The output field is not initialized, if fillvalue is not passed, it
! Subprogram not used    !     will end up with undefined values for columns where nsubcol < psubcols
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer, intent(in)                     :: lchnk            ! Chunk index
! Subprogram not used       real(r4), intent(in)                     :: field_sc(:,:)     ! subcols
! Subprogram not used       real(r4), intent(out)                    :: field(:,:,:)         ! grid
! Subprogram not used       real(r4), intent(in), optional           :: fillvalue            ! fil
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, i, j
! Subprogram not used       integer           :: nsubcol(pcols)
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcol)
! Subprogram not used       indx = 1
! Subprogram not used       do i=1, pcols
! Subprogram not used          do j = 1, nsubcol(i)
! Subprogram not used             field(i, j, :) = field_sc(indx, :)
! Subprogram not used             indx = indx + 1
! Subprogram not used          end do
! Subprogram not used          if (present(fillvalue)) then
! Subprogram not used             do j = nsubcol(i) + 1, psubcols
! Subprogram not used                field(i, j, :) = fillvalue
! Subprogram not used             end do
! Subprogram not used          end if
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_unpack_2d_real
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5,6
! Subprogram not used    subroutine subcol_unpack_3d_real(lchnk, field_sc, field, fillvalue)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! UnPack the field defined on (pcols*psubcols, *) into (pcols, psubcols, *)
! Subprogram not used    ! Unpacking is done accoding to the values in the proper chunk from nsubcol2d
! Subprogram not used    ! If fillvalue is present, unused entries in field are set.
! Subprogram not used    ! NB: The output field is not initialized, if fillvalue is not passed, it
! Subprogram not used    !     will end up with undefined values for columns where nsubcol < psubcols
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer, intent(in)                     :: lchnk            ! Chunk index
! Subprogram not used       real(r4), intent(in)                     :: field_sc(:,:,:)     ! subcols
! Subprogram not used       real(r4), intent(out)                    :: field(:,:,:,:)       ! grid
! Subprogram not used       real(r4), intent(in), optional           :: fillvalue            ! fil
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, i, j
! Subprogram not used       integer           :: nsubcol(pcols)
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcol)
! Subprogram not used       indx = 1
! Subprogram not used       do i=1, pcols
! Subprogram not used          do j = 1, nsubcol(i)
! Subprogram not used             field(i, j, :, :) = field_sc(indx, :, :)
! Subprogram not used             indx = indx + 1
! Subprogram not used          end do
! Subprogram not used          if (present(fillvalue)) then
! Subprogram not used             do j = nsubcol(i) + 1, psubcols
! Subprogram not used                field(i, j, :, :) = fillvalue
! Subprogram not used             end do
! Subprogram not used          end if
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_unpack_3d_real
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5,6
! Subprogram not used    subroutine subcol_unpack_4d_real(lchnk, field_sc, field, fillvalue)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! UnPack the field defined on (pcols*psubcols, *) into (pcols, psubcols, *)
! Subprogram not used    ! Unpacking is done accoding to the values in the proper chunk from nsubcol2d
! Subprogram not used    ! If fillvalue is present, unused entries in field are set.
! Subprogram not used    ! NB: The output field is not initialized, if fillvalue is not passed, it
! Subprogram not used    !     will end up with undefined values for columns where nsubcol < psubcols
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer, intent(in)                     :: lchnk            ! Chunk index
! Subprogram not used       real(r4), intent(in)                     :: field_sc(:,:,:,:)     ! subcols
! Subprogram not used       real(r4), intent(out)                    :: field(:,:,:,:,:)     ! grid
! Subprogram not used       real(r4), intent(in), optional           :: fillvalue            ! fil
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, i, j
! Subprogram not used       integer           :: nsubcol(pcols)
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcol)
! Subprogram not used       indx = 1
! Subprogram not used       do i=1, pcols
! Subprogram not used          do j = 1, nsubcol(i)
! Subprogram not used             field(i, j, :, :, :) = field_sc(indx, :, :, :)
! Subprogram not used             indx = indx + 1
! Subprogram not used          end do
! Subprogram not used          if (present(fillvalue)) then
! Subprogram not used             do j = nsubcol(i) + 1, psubcols
! Subprogram not used                field(i, j, :, :, :) = fillvalue
! Subprogram not used             end do
! Subprogram not used          end if
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_unpack_4d_real
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5,6
! Subprogram not used    subroutine subcol_unpack_5d_real(lchnk, field_sc, field, fillvalue)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! UnPack the field defined on (pcols*psubcols, *) into (pcols, psubcols, *)
! Subprogram not used    ! Unpacking is done accoding to the values in the proper chunk from nsubcol2d
! Subprogram not used    ! If fillvalue is present, unused entries in field are set.
! Subprogram not used    ! NB: The output field is not initialized, if fillvalue is not passed, it
! Subprogram not used    !     will end up with undefined values for columns where nsubcol < psubcols
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer, intent(in)                     :: lchnk            ! Chunk index
! Subprogram not used       real(r4), intent(in)                     :: field_sc(:,:,:,:,:)     ! subcols
! Subprogram not used       real(r4), intent(out)                    :: field(:,:,:,:,:,:)   ! grid
! Subprogram not used       real(r4), intent(in), optional           :: fillvalue            ! fil
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, i, j
! Subprogram not used       integer           :: nsubcol(pcols)
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcol)
! Subprogram not used       indx = 1
! Subprogram not used       do i=1, pcols
! Subprogram not used          do j = 1, nsubcol(i)
! Subprogram not used             field(i, j, :, :, :, :) = field_sc(indx, :, :, :, :)
! Subprogram not used             indx = indx + 1
! Subprogram not used          end do
! Subprogram not used          if (present(fillvalue)) then
! Subprogram not used             do j = nsubcol(i) + 1, psubcols
! Subprogram not used                field(i, j, :, :, :, :) = fillvalue
! Subprogram not used             end do
! Subprogram not used          end if
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_unpack_5d_real
   ! TYPE int,double,real
   ! DIMS 1,2,3,4,5,6
! Subprogram not used    subroutine subcol_unpack_6d_real(lchnk, field_sc, field, fillvalue)
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used    ! UnPack the field defined on (pcols*psubcols, *) into (pcols, psubcols, *)
! Subprogram not used    ! Unpacking is done accoding to the values in the proper chunk from nsubcol2d
! Subprogram not used    ! If fillvalue is present, unused entries in field are set.
! Subprogram not used    ! NB: The output field is not initialized, if fillvalue is not passed, it
! Subprogram not used    !     will end up with undefined values for columns where nsubcol < psubcols
! Subprogram not used    !-----------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer, intent(in)                     :: lchnk            ! Chunk index
! Subprogram not used       real(r4), intent(in)                     :: field_sc(:,:,:,:,:,:)     ! subcols
! Subprogram not used       real(r4), intent(out)                    :: field(:,:,:,:,:,:,:) ! grid
! Subprogram not used       real(r4), intent(in), optional           :: fillvalue            ! fil
! Subprogram not used 
! Subprogram not used       !
! Subprogram not used       ! Local variables
! Subprogram not used       !
! Subprogram not used       integer           :: indx, i, j
! Subprogram not used       integer           :: nsubcol(pcols)
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcol)
! Subprogram not used       indx = 1
! Subprogram not used       do i=1, pcols
! Subprogram not used          do j = 1, nsubcol(i)
! Subprogram not used             field(i, j, :, :, :, :, :) = field_sc(indx, :, :, :, :, :)
! Subprogram not used             indx = indx + 1
! Subprogram not used          end do
! Subprogram not used          if (present(fillvalue)) then
! Subprogram not used             do j = nsubcol(i) + 1, psubcols
! Subprogram not used                field(i, j, :, :, :, :, :) = fillvalue
! Subprogram not used             end do
! Subprogram not used          end if
! Subprogram not used       end do
! Subprogram not used    end subroutine subcol_unpack_6d_real

   ! TYPE int,double,real
! Subprogram not used    integer(i4) function subcol_avg_inter_int(vals, lchnk, icol, indx1, indx2, usefilter, useweight) result(avgs)
! Subprogram not used    !------------------------------------------------------------------
! Subprogram not used    ! This function handles the transformation of the usefilter and useweight logicals to passing the
! Subprogram not used    ! actual fields which subcol_avg requires based on the values of the logicals
! Subprogram not used    !------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       integer(i4),intent(in)  :: vals(:)
! Subprogram not used       integer, intent(in) :: lchnk
! Subprogram not used       integer, intent(in) :: icol
! Subprogram not used       integer, intent(in) :: indx1
! Subprogram not used       integer, intent(in) :: indx2
! Subprogram not used       logical, intent(in) :: usefilter
! Subprogram not used       logical, intent(in) :: useweight
! Subprogram not used 
! Subprogram not used       integer :: icnt
! Subprogram not used       integer :: nsubcol(pcols)
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcol)
! Subprogram not used       if (usefilter .and. useweight) then
! Subprogram not used          avgs = subcol_avg(vals,nsubcol(icol),filter=filter2d(indx1:indx2,lchnk),weight=weight2d(indx1:indx2,lchnk))
! Subprogram not used       else if (useweight) then 
! Subprogram not used          avgs = subcol_avg(vals,nsubcol(icol),weight=weight2d(indx1:indx2,lchnk))
! Subprogram not used       else if (usefilter) then
! Subprogram not used          avgs = subcol_avg(vals, nsubcol(icol),filter=filter2d(indx1:indx2,lchnk))
! Subprogram not used       else 
! Subprogram not used          avgs = subcol_avg(vals,nsubcol(icol))
! Subprogram not used       end if
! Subprogram not used 
! Subprogram not used    end function subcol_avg_inter_int
   ! TYPE int,double,real
! Subprogram not used    real(r8) function subcol_avg_inter_double(vals, lchnk, icol, indx1, indx2, usefilter, useweight) result(avgs)
! Subprogram not used    !------------------------------------------------------------------
! Subprogram not used    ! This function handles the transformation of the usefilter and useweight logicals to passing the
! Subprogram not used    ! actual fields which subcol_avg requires based on the values of the logicals
! Subprogram not used    !------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       real(r8),intent(in)  :: vals(:)
! Subprogram not used       integer, intent(in) :: lchnk
! Subprogram not used       integer, intent(in) :: icol
! Subprogram not used       integer, intent(in) :: indx1
! Subprogram not used       integer, intent(in) :: indx2
! Subprogram not used       logical, intent(in) :: usefilter
! Subprogram not used       logical, intent(in) :: useweight
! Subprogram not used 
! Subprogram not used       integer :: icnt
! Subprogram not used       integer :: nsubcol(pcols)
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcol)
! Subprogram not used       if (usefilter .and. useweight) then
! Subprogram not used          avgs = subcol_avg(vals,nsubcol(icol),filter=filter2d(indx1:indx2,lchnk),weight=weight2d(indx1:indx2,lchnk))
! Subprogram not used       else if (useweight) then 
! Subprogram not used          avgs = subcol_avg(vals,nsubcol(icol),weight=weight2d(indx1:indx2,lchnk))
! Subprogram not used       else if (usefilter) then
! Subprogram not used          avgs = subcol_avg(vals, nsubcol(icol),filter=filter2d(indx1:indx2,lchnk))
! Subprogram not used       else 
! Subprogram not used          avgs = subcol_avg(vals,nsubcol(icol))
! Subprogram not used       end if
! Subprogram not used 
! Subprogram not used    end function subcol_avg_inter_double
   ! TYPE int,double,real
! Subprogram not used    real(r4) function subcol_avg_inter_real(vals, lchnk, icol, indx1, indx2, usefilter, useweight) result(avgs)
! Subprogram not used    !------------------------------------------------------------------
! Subprogram not used    ! This function handles the transformation of the usefilter and useweight logicals to passing the
! Subprogram not used    ! actual fields which subcol_avg requires based on the values of the logicals
! Subprogram not used    !------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used       real(r4),intent(in)  :: vals(:)
! Subprogram not used       integer, intent(in) :: lchnk
! Subprogram not used       integer, intent(in) :: icol
! Subprogram not used       integer, intent(in) :: indx1
! Subprogram not used       integer, intent(in) :: indx2
! Subprogram not used       logical, intent(in) :: usefilter
! Subprogram not used       logical, intent(in) :: useweight
! Subprogram not used 
! Subprogram not used       integer :: icnt
! Subprogram not used       integer :: nsubcol(pcols)
! Subprogram not used 
! Subprogram not used       call subcol_get_nsubcol(lchnk, nsubcol)
! Subprogram not used       if (usefilter .and. useweight) then
! Subprogram not used          avgs = subcol_avg(vals,nsubcol(icol),filter=filter2d(indx1:indx2,lchnk),weight=weight2d(indx1:indx2,lchnk))
! Subprogram not used       else if (useweight) then 
! Subprogram not used          avgs = subcol_avg(vals,nsubcol(icol),weight=weight2d(indx1:indx2,lchnk))
! Subprogram not used       else if (usefilter) then
! Subprogram not used          avgs = subcol_avg(vals, nsubcol(icol),filter=filter2d(indx1:indx2,lchnk))
! Subprogram not used       else 
! Subprogram not used          avgs = subcol_avg(vals,nsubcol(icol))
! Subprogram not used       end if
! Subprogram not used 
! Subprogram not used    end function subcol_avg_inter_real

   ! TYPE int,double,real
! Subprogram not used    integer(i4) function subcol_avg_int(vals, nsubcol, filter, weight) result(avgs)
! Subprogram not used    !------------------------------------------------------------------
! Subprogram not used    ! This function performs the averaging of subcolumn fields, using the optional &
! Subprogram not used    ! filters and weights appropriately
! Subprogram not used    !------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used      integer(i4),  intent(in)           :: vals(:)
! Subprogram not used      integer,  intent(in)           :: nsubcol
! Subprogram not used      integer,  intent(in), optional :: filter(:)
! Subprogram not used      real(r8), intent(in), optional :: weight(:)
! Subprogram not used 
! Subprogram not used      integer :: icnt
! Subprogram not used      integer(i4) :: fillval
! Subprogram not used 
! Subprogram not used      fillval = fillval_int
! Subprogram not used 
! Subprogram not used      if (present(filter) .and. present(weight)) then
! Subprogram not used         if (any(filter==1).and. sum(weight,mask=(filter==1)) /=0 ) then
! Subprogram not used            avgs = sum(vals*weight, mask=(filter==1)) /  sum(weight, mask=(filter==1))
! Subprogram not used         else
! Subprogram not used            avgs = fillval
! Subprogram not used         end if
! Subprogram not used      else if (present(weight)) then 
! Subprogram not used         if (sum(weight) /=0 ) then
! Subprogram not used            avgs = sum(vals*weight) / sum(weight)
! Subprogram not used         else
! Subprogram not used            avgs = fillval
! Subprogram not used         end if
! Subprogram not used      else if (present(filter)) then
! Subprogram not used         if (any(filter==1)) then
! Subprogram not used            icnt = count(filter==1)
! Subprogram not used            avgs = sum(vals, mask=(filter==1)) / icnt
! Subprogram not used         else
! Subprogram not used            avgs = fillval
! Subprogram not used         end if
! Subprogram not used      else if (nsubcol /= 0) then
! Subprogram not used         avgs = sum(vals) / nsubcol
! Subprogram not used      else
! Subprogram not used         avgs = fillval
! Subprogram not used      end if
! Subprogram not used 
! Subprogram not used    end function subcol_avg_int
   ! TYPE int,double,real
! Subprogram not used    real(r8) function subcol_avg_double(vals, nsubcol, filter, weight) result(avgs)
! Subprogram not used    !------------------------------------------------------------------
! Subprogram not used    ! This function performs the averaging of subcolumn fields, using the optional &
! Subprogram not used    ! filters and weights appropriately
! Subprogram not used    !------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used      real(r8),  intent(in)           :: vals(:)
! Subprogram not used      integer,  intent(in)           :: nsubcol
! Subprogram not used      integer,  intent(in), optional :: filter(:)
! Subprogram not used      real(r8), intent(in), optional :: weight(:)
! Subprogram not used 
! Subprogram not used      integer :: icnt
! Subprogram not used      real(r8) :: fillval
! Subprogram not used 
! Subprogram not used      fillval = fillval_double
! Subprogram not used 
! Subprogram not used      if (present(filter) .and. present(weight)) then
! Subprogram not used         if (any(filter==1).and. sum(weight,mask=(filter==1)) /=0 ) then
! Subprogram not used            avgs = sum(vals*weight, mask=(filter==1)) /  sum(weight, mask=(filter==1))
! Subprogram not used         else
! Subprogram not used            avgs = fillval
! Subprogram not used         end if
! Subprogram not used      else if (present(weight)) then 
! Subprogram not used         if (sum(weight) /=0 ) then
! Subprogram not used            avgs = sum(vals*weight) / sum(weight)
! Subprogram not used         else
! Subprogram not used            avgs = fillval
! Subprogram not used         end if
! Subprogram not used      else if (present(filter)) then
! Subprogram not used         if (any(filter==1)) then
! Subprogram not used            icnt = count(filter==1)
! Subprogram not used            avgs = sum(vals, mask=(filter==1)) / icnt
! Subprogram not used         else
! Subprogram not used            avgs = fillval
! Subprogram not used         end if
! Subprogram not used      else if (nsubcol /= 0) then
! Subprogram not used         avgs = sum(vals) / nsubcol
! Subprogram not used      else
! Subprogram not used         avgs = fillval
! Subprogram not used      end if
! Subprogram not used 
! Subprogram not used    end function subcol_avg_double
   ! TYPE int,double,real
! Subprogram not used    real(r4) function subcol_avg_real(vals, nsubcol, filter, weight) result(avgs)
! Subprogram not used    !------------------------------------------------------------------
! Subprogram not used    ! This function performs the averaging of subcolumn fields, using the optional &
! Subprogram not used    ! filters and weights appropriately
! Subprogram not used    !------------------------------------------------------------------
! Subprogram not used 
! Subprogram not used      real(r4),  intent(in)           :: vals(:)
! Subprogram not used      integer,  intent(in)           :: nsubcol
! Subprogram not used      integer,  intent(in), optional :: filter(:)
! Subprogram not used      real(r8), intent(in), optional :: weight(:)
! Subprogram not used 
! Subprogram not used      integer :: icnt
! Subprogram not used      real(r4) :: fillval
! Subprogram not used 
! Subprogram not used      fillval = fillval_real
! Subprogram not used 
! Subprogram not used      if (present(filter) .and. present(weight)) then
! Subprogram not used         if (any(filter==1).and. sum(weight,mask=(filter==1)) /=0 ) then
! Subprogram not used            avgs = sum(vals*weight, mask=(filter==1)) /  sum(weight, mask=(filter==1))
! Subprogram not used         else
! Subprogram not used            avgs = fillval
! Subprogram not used         end if
! Subprogram not used      else if (present(weight)) then 
! Subprogram not used         if (sum(weight) /=0 ) then
! Subprogram not used            avgs = sum(vals*weight) / sum(weight)
! Subprogram not used         else
! Subprogram not used            avgs = fillval
! Subprogram not used         end if
! Subprogram not used      else if (present(filter)) then
! Subprogram not used         if (any(filter==1)) then
! Subprogram not used            icnt = count(filter==1)
! Subprogram not used            avgs = sum(vals, mask=(filter==1)) / icnt
! Subprogram not used         else
! Subprogram not used            avgs = fillval
! Subprogram not used         end if
! Subprogram not used      else if (nsubcol /= 0) then
! Subprogram not used         avgs = sum(vals) / nsubcol
! Subprogram not used      else
! Subprogram not used         avgs = fillval
! Subprogram not used      end if
! Subprogram not used 
! Subprogram not used    end function subcol_avg_real

! Subprogram not used    subroutine subcol_utils_init_restart(File, hdimids)
! Subprogram not used 
! Subprogram not used      use pio,    only: file_desc_t, pio_def_var, pio_int, pio_double
! Subprogram not used      type(file_desc_t),intent(in) :: File
! Subprogram not used      integer ,intent(in)          :: hdimids(:)
! Subprogram not used 
! Subprogram not used      integer :: ierr
! Subprogram not used 
! Subprogram not used      ierr = pio_def_var(File, 'NSUBCOL2D', pio_int, hdimids, nsubcol_desc)
! Subprogram not used ! storing filter and weight data even if not being filled by subcolumn generator
! Subprogram not used      ierr = pio_def_var(File, 'FILTER2D', pio_int, hdimids, filter2d_desc)
! Subprogram not used      ierr = pio_def_var(File, 'WEIGHT2D', pio_double, hdimids, weight2d_desc)
! Subprogram not used 
! Subprogram not used    end subroutine subcol_utils_init_restart

! Subprogram not used    subroutine subcol_utils_write_restart(File)
! Subprogram not used      use pio,             only: file_desc_t, pio_write_darray
! Subprogram not used      use cam_pio_utils,   only: get_phys_decomp
! Subprogram not used      use pio,             only: io_desc_t
! Subprogram not used 
! Subprogram not used 
! Subprogram not used      type(file_desc_t), intent(inout) :: File
! Subprogram not used 
! Subprogram not used      integer :: ierr
! Subprogram not used      type(io_desc_t), pointer           :: iodesc => null()
! Subprogram not used 
! Subprogram not used      call get_phys_decomp(iodesc, 1, 1, 1, nsubcol_desc%type)
! Subprogram not used      call pio_write_darray(File, nsubcol_desc, iodesc, nsubcol2d, ierr)
! Subprogram not used 
! Subprogram not used      call get_phys_decomp(iodesc, 1, 1, 1, filter2d_desc%type)
! Subprogram not used      call pio_write_darray(File, filter2d_desc, iodesc, filter2d, ierr)
! Subprogram not used 
! Subprogram not used      call get_phys_decomp(iodesc, 1, 1, 1, weight2d_desc%type)
! Subprogram not used      call pio_write_darray(File, weight2d_desc, iodesc, weight2d, ierr)
! Subprogram not used 
! Subprogram not used    end subroutine subcol_utils_write_restart

! Subprogram not used    subroutine subcol_utils_read_restart(File)
! Subprogram not used      use pio,           only: file_desc_t, pio_read_darray, pio_inq_varid, pio_int, pio_double
! Subprogram not used      use cam_pio_utils, only: get_phys_decomp
! Subprogram not used      use ppgrid,        only: begchunk, endchunk
! Subprogram not used      use pio,           only: io_desc_t
! Subprogram not used 
! Subprogram not used      type(file_desc_t), intent(inout) :: File
! Subprogram not used 
! Subprogram not used      integer                  :: ierr, isize, c
! Subprogram not used      type(io_desc_t), pointer :: iodesc => null()
! Subprogram not used 
! Subprogram not used      call subcol_allocate_internal()
! Subprogram not used 
! Subprogram not used      ierr = pio_inq_varid(File, 'NSUBCOL2D', nsubcol_desc)
! Subprogram not used      call get_phys_decomp(iodesc, 1, 1, 1, pio_int)
! Subprogram not used      call pio_read_darray(File, nsubcol_desc, iodesc, nsubcol2d, ierr)
! Subprogram not used 
! Subprogram not used      ! We need to update indcol2d so set nsubcol2d to itself
! Subprogram not used      do c = begchunk, endchunk
! Subprogram not used        call subcol_set_nsubcol(c, pcols, nsubcol2d(:, c))
! Subprogram not used      end do
! Subprogram not used 
! Subprogram not used      ierr = pio_inq_varid(File, 'FILTER2D', filter2d_desc)
! Subprogram not used      call get_phys_decomp(iodesc, 1, 1, 1, pio_int)
! Subprogram not used      call pio_read_darray(File, filter2d_desc, iodesc, filter2d, ierr)
! Subprogram not used 
! Subprogram not used      ierr = pio_inq_varid(File, 'WEIGHT2D', weight2d_desc)
! Subprogram not used      call get_phys_decomp(iodesc, 1, 1, 1, pio_double)
! Subprogram not used      call pio_read_darray(File, weight2d_desc, iodesc, weight2d, ierr)
! Subprogram not used 
! Subprogram not used    end subroutine subcol_utils_read_restart

end module subcol_utils
