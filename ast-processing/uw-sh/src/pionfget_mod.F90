
!===================================================
! DO NOT EDIT THIS FILE, it was generated using /glade/u/home/milroy/cesm/cesm1_3_beta11/tools/cprnc/genf90/genf90.pl 
! Any changes you make to this file may be lost
!===================================================

!>
!! @file 
!! $Revision: 925 $
!! $LastChangedDate: 2014-01-24 13:55:17 -0700 (Fri, 24 Jan 2014) $
!! @brief Read Routines for non-decomposed NetCDF data.
!<
module pionfget_mod



  use pio_msg_mod
  use pio_kinds, only: i4,r4,r8,pio_offset
  use pio_types, only : file_desc_t, iosystem_desc_t, var_desc_t, &
	pio_iotype_pbinary, pio_iotype_binary, pio_iotype_direct_pbinary, &
	pio_iotype_netcdf, pio_iotype_pnetcdf, pio_iotype_netcdf4p, pio_iotype_netcdf4c, &
	pio_noerr
  use pio_utils, only : check_netcdf
  use pio_support, only : Debug, DebugIO, piodie, CheckMPIReturn




  use mpi ! _EXTERNAL




  implicit none
  private
!>
!! @defgroup PIO_get_var PIO_get_var
!! @brief Reads non-decomposed data from a NetCDF file
!! @details The get_var interface is provided as a simplified interface to
!!  read variables from a NetCDF format file.   The variable is read on the 
!!  root IO task and broadcast in its entirety to all tasks.  
!<
  public :: get_var



  interface get_var
     module procedure get_var_0d_text, get_var_vdesc_0d_text
     module procedure get_var_1d_text, get_var_vdesc_1d_text
     module procedure get_var_2d_text, get_var_vdesc_2d_text
     module procedure get_var_3d_text, get_var_vdesc_3d_text
     module procedure get_var_4d_text, get_var_vdesc_4d_text
     module procedure get_var_5d_text, get_var_vdesc_5d_text
     module procedure get_var_0d_real, get_var_vdesc_0d_real
     module procedure get_var_1d_real, get_var_vdesc_1d_real
     module procedure get_var_2d_real, get_var_vdesc_2d_real
     module procedure get_var_3d_real, get_var_vdesc_3d_real
     module procedure get_var_4d_real, get_var_vdesc_4d_real
     module procedure get_var_5d_real, get_var_vdesc_5d_real
     module procedure get_var_0d_double, get_var_vdesc_0d_double
     module procedure get_var_1d_double, get_var_vdesc_1d_double
     module procedure get_var_2d_double, get_var_vdesc_2d_double
     module procedure get_var_3d_double, get_var_vdesc_3d_double
     module procedure get_var_4d_double, get_var_vdesc_4d_double
     module procedure get_var_5d_double, get_var_vdesc_5d_double
     module procedure get_var_0d_int, get_var_vdesc_0d_int
     module procedure get_var_1d_int, get_var_vdesc_1d_int
     module procedure get_var_2d_int, get_var_vdesc_2d_int
     module procedure get_var_3d_int, get_var_vdesc_3d_int
     module procedure get_var_4d_int, get_var_vdesc_4d_int
     module procedure get_var_5d_int, get_var_vdesc_5d_int
     !  DIMS 1,2,3,4,5
     module procedure get_vara_1d_text, get_vara_vdesc_1d_text
     !  DIMS 1,2,3,4,5
     module procedure get_vara_2d_text, get_vara_vdesc_2d_text
     !  DIMS 1,2,3,4,5
     module procedure get_vara_3d_text, get_vara_vdesc_3d_text
     !  DIMS 1,2,3,4,5
     module procedure get_vara_4d_text, get_vara_vdesc_4d_text
     !  DIMS 1,2,3,4,5
     module procedure get_vara_5d_text, get_vara_vdesc_5d_text
     !  DIMS 1,2,3,4,5
     module procedure get_vara_1d_real, get_vara_vdesc_1d_real
     !  DIMS 1,2,3,4,5
     module procedure get_vara_2d_real, get_vara_vdesc_2d_real
     !  DIMS 1,2,3,4,5
     module procedure get_vara_3d_real, get_vara_vdesc_3d_real
     !  DIMS 1,2,3,4,5
     module procedure get_vara_4d_real, get_vara_vdesc_4d_real
     !  DIMS 1,2,3,4,5
     module procedure get_vara_5d_real, get_vara_vdesc_5d_real
     !  DIMS 1,2,3,4,5
     module procedure get_vara_1d_double, get_vara_vdesc_1d_double
     !  DIMS 1,2,3,4,5
     module procedure get_vara_2d_double, get_vara_vdesc_2d_double
     !  DIMS 1,2,3,4,5
     module procedure get_vara_3d_double, get_vara_vdesc_3d_double
     !  DIMS 1,2,3,4,5
     module procedure get_vara_4d_double, get_vara_vdesc_4d_double
     !  DIMS 1,2,3,4,5
     module procedure get_vara_5d_double, get_vara_vdesc_5d_double
     !  DIMS 1,2,3,4,5
     module procedure get_vara_1d_int, get_vara_vdesc_1d_int
     !  DIMS 1,2,3,4,5
     module procedure get_vara_2d_int, get_vara_vdesc_2d_int
     !  DIMS 1,2,3,4,5
     module procedure get_vara_3d_int, get_vara_vdesc_3d_int
     !  DIMS 1,2,3,4,5
     module procedure get_vara_4d_int, get_vara_vdesc_4d_int
     !  DIMS 1,2,3,4,5
     module procedure get_vara_5d_int, get_vara_vdesc_5d_int
     module procedure get_var1_text, get_var1_vdesc_text
     module procedure get_var1_real, get_var1_vdesc_real
     module procedure get_var1_double, get_var1_vdesc_double
     module procedure get_var1_int, get_var1_vdesc_int
  end interface

 character(len=*), parameter :: modName='pionfget_mod'

CONTAINS

!>
!! @public
!! @ingroup PIO_get_var
!! @brief Reads non-decomposed fields from a NetCDF file
!! @details
!! @param File @ref file_desc_t
!! @param varid : The netcdf variable identifier
!! @param index :  a multidimensional index that specifies which value to get
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_var1_text (File,varid, index, ival) result(ierr)
    use pio_msg_mod, only : pio_msg_getvar1
    use pio_types, only : pio_max_var_dims
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid, index(:)
    character(len=*), intent(out) :: ival
    type(iosystem_desc_t), pointer :: ios
    character(len=*), parameter :: subName=modName//'::get_var1_text'
    integer :: iotype, mpierr, ilen, msg, sofindex, itype
    integer(kind=pio_offset) :: kount(PIO_MAX_VAR_DIMS)
    ierr=0
    iotype = File%iotype 
    ios => File%iosystem
    sofindex = size(index)

    ilen=1
    if(Debug) print *,"pionfget_mod.F90",93,index, ilen
    
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVAR1
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(sofindex,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(index,sofindex,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 100
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       if(100 == TYPETEXT) then
          call MPI_BCAST(ilen,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       end if
    endif


    if(File%iosystem%IOProc) then
       select case (iotype) 

       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",143)
    ilen=1

    call MPI_Bcast(ival, ilen, MPI_CHARACTER , File%iosystem%IOMaster, File%iosystem%MY_comm, mpierr)
    call CheckMPIReturn(subName, mpierr)

  end function get_var1_text
  integer function get_var1_real (File,varid, index, ival) result(ierr)
    use pio_msg_mod, only : pio_msg_getvar1
    use pio_types, only : pio_max_var_dims
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid, index(:)
    real(r4), intent(out) :: ival
    type(iosystem_desc_t), pointer :: ios
    character(len=*), parameter :: subName=modName//'::get_var1_real'
    integer :: iotype, mpierr, ilen, msg, sofindex, itype
    integer(kind=pio_offset) :: kount(PIO_MAX_VAR_DIMS)
    ierr=0
    iotype = File%iotype 
    ios => File%iosystem
    sofindex = size(index)

    ilen=1
    if(Debug) print *,"pionfget_mod.F90",93,index, ilen
    
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVAR1
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(sofindex,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(index,sofindex,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 101
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       if(101 == TYPETEXT) then
          call MPI_BCAST(ilen,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       end if
    endif


    if(File%iosystem%IOProc) then
       select case (iotype) 

       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",143)
    ilen=1

    call MPI_Bcast(ival, ilen, MPI_REAL4 , File%iosystem%IOMaster, File%iosystem%MY_comm, mpierr)
    call CheckMPIReturn(subName, mpierr)

  end function get_var1_real
  integer function get_var1_double (File,varid, index, ival) result(ierr)
    use pio_msg_mod, only : pio_msg_getvar1
    use pio_types, only : pio_max_var_dims
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid, index(:)
    real(r8), intent(out) :: ival
    type(iosystem_desc_t), pointer :: ios
    character(len=*), parameter :: subName=modName//'::get_var1_double'
    integer :: iotype, mpierr, ilen, msg, sofindex, itype
    integer(kind=pio_offset) :: kount(PIO_MAX_VAR_DIMS)
    ierr=0
    iotype = File%iotype 
    ios => File%iosystem
    sofindex = size(index)

    ilen=1
    if(Debug) print *,"pionfget_mod.F90",93,index, ilen
    
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVAR1
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(sofindex,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(index,sofindex,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 102
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       if(102 == TYPETEXT) then
          call MPI_BCAST(ilen,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       end if
    endif


    if(File%iosystem%IOProc) then
       select case (iotype) 

       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",143)
    ilen=1

    call MPI_Bcast(ival, ilen, MPI_REAL8 , File%iosystem%IOMaster, File%iosystem%MY_comm, mpierr)
    call CheckMPIReturn(subName, mpierr)

  end function get_var1_double
  integer function get_var1_int (File,varid, index, ival) result(ierr)
    use pio_msg_mod, only : pio_msg_getvar1
    use pio_types, only : pio_max_var_dims
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid, index(:)
    integer(i4), intent(out) :: ival
    type(iosystem_desc_t), pointer :: ios
    character(len=*), parameter :: subName=modName//'::get_var1_int'
    integer :: iotype, mpierr, ilen, msg, sofindex, itype
    integer(kind=pio_offset) :: kount(PIO_MAX_VAR_DIMS)
    ierr=0
    iotype = File%iotype 
    ios => File%iosystem
    sofindex = size(index)

    ilen=1
    if(Debug) print *,"pionfget_mod.F90",93,index, ilen
    
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVAR1
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(sofindex,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(index,sofindex,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 103
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       if(103 == TYPETEXT) then
          call MPI_BCAST(ilen,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       end if
    endif


    if(File%iosystem%IOProc) then
       select case (iotype) 

       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",143)
    ilen=1

    call MPI_Bcast(ival, ilen, MPI_INTEGER , File%iosystem%IOMaster, File%iosystem%MY_comm, mpierr)
    call CheckMPIReturn(subName, mpierr)

  end function get_var1_int

!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param vardesc @ref var_desc_t
!! @param index :  a multidimensional index that specifies which value to get
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_var1_vdesc_text (File,vardesc, index, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    integer, intent(in) :: index(:)
    character(len=*), intent(out) :: ival

    character(len=*), parameter :: subName=modName//'::get_var1_vdesc_text'

    ierr = get_var1_text (File, vardesc%varid, index, ival)

  end function get_var1_vdesc_text
  integer function get_var1_vdesc_real (File,vardesc, index, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    integer, intent(in) :: index(:)
    real(r4), intent(out) :: ival

    character(len=*), parameter :: subName=modName//'::get_var1_vdesc_real'

    ierr = get_var1_real (File, vardesc%varid, index, ival)

  end function get_var1_vdesc_real
  integer function get_var1_vdesc_double (File,vardesc, index, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    integer, intent(in) :: index(:)
    real(r8), intent(out) :: ival

    character(len=*), parameter :: subName=modName//'::get_var1_vdesc_double'

    ierr = get_var1_double (File, vardesc%varid, index, ival)

  end function get_var1_vdesc_double
  integer function get_var1_vdesc_int (File,vardesc, index, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    integer, intent(in) :: index(:)
    integer(i4), intent(out) :: ival

    character(len=*), parameter :: subName=modName//'::get_var1_vdesc_int'

    ierr = get_var1_int (File, vardesc%varid, index, ival)

  end function get_var1_vdesc_int


! DIMS 1,2,3,4,5
!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param varid : The netcdf variable identifier
!! @param start : A vector of size_t integers specifying the index in
!!   the variable where the first of the data values will be read. The
!!   indices are relative to 0, so for example, the first data value of
!!   a variable would have index (0, 0, ... , 0). The length of start
!!   must be the same as the number of dimensions of the specified
!!   variable. The elements of start correspond, in order, to the
!!   variable's dimensions. Hence, if the variable is a record variable,
!!   the first index would correspond to the starting record number for
!!   reading the data values.
!! @param count : A vector of size_t integers specifying the edge
!!   lengths along each dimension of the block of data values to be
!!   read. To read a single value, for example, specify count as (1, 1,
!!   ... , 1). The length of count is the number of dimensions of the
!!   specified variable. The elements of count correspond, in order, to
!!   the variable's dimensions. Hence, if the variable is a record
!!   variable, the first element of count corresponds to a count of the
!!   number of records to read.
!! Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything. 
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_vara_1d_text (File,varid, start, count, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid, start(:), count(:)
    character(len=*), intent(out) :: ival(:)
         
    character(len=*), parameter :: subName=modName//'::get_vara_1d_text'

    integer :: dims(1)
    integer :: iotype, mpierr, i, msg, ilen, itype, slen
    integer(kind=PIO_OFFSET) :: isize
    type(iosystem_desc_t), pointer :: ios
    ierr=0
    iotype = File%iotype 
    isize=1
    do i=1,size(count)
       isize=isize*count(i)
    end do



    ios=>File%iosystem
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVARA_1d
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 100
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       slen = size(start)
       call MPI_BCAST(slen,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(start,slen,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(count,slen,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)

       do i=1,1
          dims(i)=size(ival,i)
       end do
       call MPI_BCAST(dims,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)


    endif






    if(File%iosystem%IOProc) then
       select case (iotype) 
       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",289)
    if(ios%async_interface .or. ios%num_tasks>ios%num_iotasks) then
       call MPI_Bcast(ival,int(isize), MPI_CHARACTER , ios%IOMaster, ios%My_comm, mpierr)
       call CheckMPIReturn(subName, mpierr)
    end if



  end function get_vara_1d_text
! DIMS 1,2,3,4,5
!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param varid : The netcdf variable identifier
!! @param start : A vector of size_t integers specifying the index in
!!   the variable where the first of the data values will be read. The
!!   indices are relative to 0, so for example, the first data value of
!!   a variable would have index (0, 0, ... , 0). The length of start
!!   must be the same as the number of dimensions of the specified
!!   variable. The elements of start correspond, in order, to the
!!   variable's dimensions. Hence, if the variable is a record variable,
!!   the first index would correspond to the starting record number for
!!   reading the data values.
!! @param count : A vector of size_t integers specifying the edge
!!   lengths along each dimension of the block of data values to be
!!   read. To read a single value, for example, specify count as (1, 1,
!!   ... , 1). The length of count is the number of dimensions of the
!!   specified variable. The elements of count correspond, in order, to
!!   the variable's dimensions. Hence, if the variable is a record
!!   variable, the first element of count corresponds to a count of the
!!   number of records to read.
!! Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything. 
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_vara_2d_text (File,varid, start, count, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid, start(:), count(:)
    character(len=*), intent(out) :: ival(:,:)
         
    character(len=*), parameter :: subName=modName//'::get_vara_2d_text'

    integer :: dims(2)
    integer :: iotype, mpierr, i, msg, ilen, itype, slen
    integer(kind=PIO_OFFSET) :: isize
    type(iosystem_desc_t), pointer :: ios
    ierr=0
    iotype = File%iotype 
    isize=1
    do i=1,size(count)
       isize=isize*count(i)
    end do



    ios=>File%iosystem
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVARA_2d
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 100
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       slen = size(start)
       call MPI_BCAST(slen,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(start,slen,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(count,slen,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)

       do i=1,2
          dims(i)=size(ival,i)
       end do
       call MPI_BCAST(dims,2,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)


    endif






    if(File%iosystem%IOProc) then
       select case (iotype) 
       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",289)
    if(ios%async_interface .or. ios%num_tasks>ios%num_iotasks) then
       call MPI_Bcast(ival,int(isize), MPI_CHARACTER , ios%IOMaster, ios%My_comm, mpierr)
       call CheckMPIReturn(subName, mpierr)
    end if



  end function get_vara_2d_text
! DIMS 1,2,3,4,5
!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param varid : The netcdf variable identifier
!! @param start : A vector of size_t integers specifying the index in
!!   the variable where the first of the data values will be read. The
!!   indices are relative to 0, so for example, the first data value of
!!   a variable would have index (0, 0, ... , 0). The length of start
!!   must be the same as the number of dimensions of the specified
!!   variable. The elements of start correspond, in order, to the
!!   variable's dimensions. Hence, if the variable is a record variable,
!!   the first index would correspond to the starting record number for
!!   reading the data values.
!! @param count : A vector of size_t integers specifying the edge
!!   lengths along each dimension of the block of data values to be
!!   read. To read a single value, for example, specify count as (1, 1,
!!   ... , 1). The length of count is the number of dimensions of the
!!   specified variable. The elements of count correspond, in order, to
!!   the variable's dimensions. Hence, if the variable is a record
!!   variable, the first element of count corresponds to a count of the
!!   number of records to read.
!! Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything. 
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_vara_3d_text (File,varid, start, count, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid, start(:), count(:)
    character(len=*), intent(out) :: ival(:,:,:)
         
    character(len=*), parameter :: subName=modName//'::get_vara_3d_text'

    integer :: dims(3)
    integer :: iotype, mpierr, i, msg, ilen, itype, slen
    integer(kind=PIO_OFFSET) :: isize
    type(iosystem_desc_t), pointer :: ios
    ierr=0
    iotype = File%iotype 
    isize=1
    do i=1,size(count)
       isize=isize*count(i)
    end do



    ios=>File%iosystem
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVARA_3d
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 100
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       slen = size(start)
       call MPI_BCAST(slen,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(start,slen,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(count,slen,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)

       do i=1,3
          dims(i)=size(ival,i)
       end do
       call MPI_BCAST(dims,3,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)


    endif






    if(File%iosystem%IOProc) then
       select case (iotype) 
       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",289)
    if(ios%async_interface .or. ios%num_tasks>ios%num_iotasks) then
       call MPI_Bcast(ival,int(isize), MPI_CHARACTER , ios%IOMaster, ios%My_comm, mpierr)
       call CheckMPIReturn(subName, mpierr)
    end if



  end function get_vara_3d_text
! DIMS 1,2,3,4,5
!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param varid : The netcdf variable identifier
!! @param start : A vector of size_t integers specifying the index in
!!   the variable where the first of the data values will be read. The
!!   indices are relative to 0, so for example, the first data value of
!!   a variable would have index (0, 0, ... , 0). The length of start
!!   must be the same as the number of dimensions of the specified
!!   variable. The elements of start correspond, in order, to the
!!   variable's dimensions. Hence, if the variable is a record variable,
!!   the first index would correspond to the starting record number for
!!   reading the data values.
!! @param count : A vector of size_t integers specifying the edge
!!   lengths along each dimension of the block of data values to be
!!   read. To read a single value, for example, specify count as (1, 1,
!!   ... , 1). The length of count is the number of dimensions of the
!!   specified variable. The elements of count correspond, in order, to
!!   the variable's dimensions. Hence, if the variable is a record
!!   variable, the first element of count corresponds to a count of the
!!   number of records to read.
!! Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything. 
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_vara_4d_text (File,varid, start, count, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid, start(:), count(:)
    character(len=*), intent(out) :: ival(:,:,:,:)
         
    character(len=*), parameter :: subName=modName//'::get_vara_4d_text'

    integer :: dims(4)
    integer :: iotype, mpierr, i, msg, ilen, itype, slen
    integer(kind=PIO_OFFSET) :: isize
    type(iosystem_desc_t), pointer :: ios
    ierr=0
    iotype = File%iotype 
    isize=1
    do i=1,size(count)
       isize=isize*count(i)
    end do



    ios=>File%iosystem
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVARA_4d
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 100
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       slen = size(start)
       call MPI_BCAST(slen,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(start,slen,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(count,slen,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)

       do i=1,4
          dims(i)=size(ival,i)
       end do
       call MPI_BCAST(dims,4,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)


    endif






    if(File%iosystem%IOProc) then
       select case (iotype) 
       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",289)
    if(ios%async_interface .or. ios%num_tasks>ios%num_iotasks) then
       call MPI_Bcast(ival,int(isize), MPI_CHARACTER , ios%IOMaster, ios%My_comm, mpierr)
       call CheckMPIReturn(subName, mpierr)
    end if



  end function get_vara_4d_text
! DIMS 1,2,3,4,5
!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param varid : The netcdf variable identifier
!! @param start : A vector of size_t integers specifying the index in
!!   the variable where the first of the data values will be read. The
!!   indices are relative to 0, so for example, the first data value of
!!   a variable would have index (0, 0, ... , 0). The length of start
!!   must be the same as the number of dimensions of the specified
!!   variable. The elements of start correspond, in order, to the
!!   variable's dimensions. Hence, if the variable is a record variable,
!!   the first index would correspond to the starting record number for
!!   reading the data values.
!! @param count : A vector of size_t integers specifying the edge
!!   lengths along each dimension of the block of data values to be
!!   read. To read a single value, for example, specify count as (1, 1,
!!   ... , 1). The length of count is the number of dimensions of the
!!   specified variable. The elements of count correspond, in order, to
!!   the variable's dimensions. Hence, if the variable is a record
!!   variable, the first element of count corresponds to a count of the
!!   number of records to read.
!! Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything. 
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_vara_5d_text (File,varid, start, count, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid, start(:), count(:)
    character(len=*), intent(out) :: ival(:,:,:,:,:)
         
    character(len=*), parameter :: subName=modName//'::get_vara_5d_text'

    integer :: dims(5)
    integer :: iotype, mpierr, i, msg, ilen, itype, slen
    integer(kind=PIO_OFFSET) :: isize
    type(iosystem_desc_t), pointer :: ios
    ierr=0
    iotype = File%iotype 
    isize=1
    do i=1,size(count)
       isize=isize*count(i)
    end do



    ios=>File%iosystem
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVARA_5d
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 100
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       slen = size(start)
       call MPI_BCAST(slen,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(start,slen,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(count,slen,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)

       do i=1,5
          dims(i)=size(ival,i)
       end do
       call MPI_BCAST(dims,5,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)


    endif






    if(File%iosystem%IOProc) then
       select case (iotype) 
       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",289)
    if(ios%async_interface .or. ios%num_tasks>ios%num_iotasks) then
       call MPI_Bcast(ival,int(isize), MPI_CHARACTER , ios%IOMaster, ios%My_comm, mpierr)
       call CheckMPIReturn(subName, mpierr)
    end if



  end function get_vara_5d_text
! DIMS 1,2,3,4,5
!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param varid : The netcdf variable identifier
!! @param start : A vector of size_t integers specifying the index in
!!   the variable where the first of the data values will be read. The
!!   indices are relative to 0, so for example, the first data value of
!!   a variable would have index (0, 0, ... , 0). The length of start
!!   must be the same as the number of dimensions of the specified
!!   variable. The elements of start correspond, in order, to the
!!   variable's dimensions. Hence, if the variable is a record variable,
!!   the first index would correspond to the starting record number for
!!   reading the data values.
!! @param count : A vector of size_t integers specifying the edge
!!   lengths along each dimension of the block of data values to be
!!   read. To read a single value, for example, specify count as (1, 1,
!!   ... , 1). The length of count is the number of dimensions of the
!!   specified variable. The elements of count correspond, in order, to
!!   the variable's dimensions. Hence, if the variable is a record
!!   variable, the first element of count corresponds to a count of the
!!   number of records to read.
!! Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything. 
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_vara_1d_real (File,varid, start, count, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid, start(:), count(:)
    real(r4), intent(out) :: ival(:)
         
    character(len=*), parameter :: subName=modName//'::get_vara_1d_real'

    integer :: dims(1)
    integer :: iotype, mpierr, i, msg, ilen, itype, slen
    integer(kind=PIO_OFFSET) :: isize
    type(iosystem_desc_t), pointer :: ios
    ierr=0
    iotype = File%iotype 
    isize=1
    do i=1,size(count)
       isize=isize*count(i)
    end do



    ios=>File%iosystem
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVARA_1d
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 101
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       slen = size(start)
       call MPI_BCAST(slen,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(start,slen,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(count,slen,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)

       do i=1,1
          dims(i)=size(ival,i)
       end do
       call MPI_BCAST(dims,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)


    endif






    if(File%iosystem%IOProc) then
       select case (iotype) 
       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",289)
    if(ios%async_interface .or. ios%num_tasks>ios%num_iotasks) then
       call MPI_Bcast(ival,int(isize), MPI_REAL4 , ios%IOMaster, ios%My_comm, mpierr)
       call CheckMPIReturn(subName, mpierr)
    end if



  end function get_vara_1d_real
! DIMS 1,2,3,4,5
!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param varid : The netcdf variable identifier
!! @param start : A vector of size_t integers specifying the index in
!!   the variable where the first of the data values will be read. The
!!   indices are relative to 0, so for example, the first data value of
!!   a variable would have index (0, 0, ... , 0). The length of start
!!   must be the same as the number of dimensions of the specified
!!   variable. The elements of start correspond, in order, to the
!!   variable's dimensions. Hence, if the variable is a record variable,
!!   the first index would correspond to the starting record number for
!!   reading the data values.
!! @param count : A vector of size_t integers specifying the edge
!!   lengths along each dimension of the block of data values to be
!!   read. To read a single value, for example, specify count as (1, 1,
!!   ... , 1). The length of count is the number of dimensions of the
!!   specified variable. The elements of count correspond, in order, to
!!   the variable's dimensions. Hence, if the variable is a record
!!   variable, the first element of count corresponds to a count of the
!!   number of records to read.
!! Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything. 
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_vara_2d_real (File,varid, start, count, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid, start(:), count(:)
    real(r4), intent(out) :: ival(:,:)
         
    character(len=*), parameter :: subName=modName//'::get_vara_2d_real'

    integer :: dims(2)
    integer :: iotype, mpierr, i, msg, ilen, itype, slen
    integer(kind=PIO_OFFSET) :: isize
    type(iosystem_desc_t), pointer :: ios
    ierr=0
    iotype = File%iotype 
    isize=1
    do i=1,size(count)
       isize=isize*count(i)
    end do



    ios=>File%iosystem
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVARA_2d
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 101
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       slen = size(start)
       call MPI_BCAST(slen,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(start,slen,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(count,slen,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)

       do i=1,2
          dims(i)=size(ival,i)
       end do
       call MPI_BCAST(dims,2,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)


    endif






    if(File%iosystem%IOProc) then
       select case (iotype) 
       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",289)
    if(ios%async_interface .or. ios%num_tasks>ios%num_iotasks) then
       call MPI_Bcast(ival,int(isize), MPI_REAL4 , ios%IOMaster, ios%My_comm, mpierr)
       call CheckMPIReturn(subName, mpierr)
    end if



  end function get_vara_2d_real
! DIMS 1,2,3,4,5
!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param varid : The netcdf variable identifier
!! @param start : A vector of size_t integers specifying the index in
!!   the variable where the first of the data values will be read. The
!!   indices are relative to 0, so for example, the first data value of
!!   a variable would have index (0, 0, ... , 0). The length of start
!!   must be the same as the number of dimensions of the specified
!!   variable. The elements of start correspond, in order, to the
!!   variable's dimensions. Hence, if the variable is a record variable,
!!   the first index would correspond to the starting record number for
!!   reading the data values.
!! @param count : A vector of size_t integers specifying the edge
!!   lengths along each dimension of the block of data values to be
!!   read. To read a single value, for example, specify count as (1, 1,
!!   ... , 1). The length of count is the number of dimensions of the
!!   specified variable. The elements of count correspond, in order, to
!!   the variable's dimensions. Hence, if the variable is a record
!!   variable, the first element of count corresponds to a count of the
!!   number of records to read.
!! Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything. 
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_vara_3d_real (File,varid, start, count, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid, start(:), count(:)
    real(r4), intent(out) :: ival(:,:,:)
         
    character(len=*), parameter :: subName=modName//'::get_vara_3d_real'

    integer :: dims(3)
    integer :: iotype, mpierr, i, msg, ilen, itype, slen
    integer(kind=PIO_OFFSET) :: isize
    type(iosystem_desc_t), pointer :: ios
    ierr=0
    iotype = File%iotype 
    isize=1
    do i=1,size(count)
       isize=isize*count(i)
    end do



    ios=>File%iosystem
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVARA_3d
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 101
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       slen = size(start)
       call MPI_BCAST(slen,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(start,slen,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(count,slen,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)

       do i=1,3
          dims(i)=size(ival,i)
       end do
       call MPI_BCAST(dims,3,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)


    endif






    if(File%iosystem%IOProc) then
       select case (iotype) 
       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",289)
    if(ios%async_interface .or. ios%num_tasks>ios%num_iotasks) then
       call MPI_Bcast(ival,int(isize), MPI_REAL4 , ios%IOMaster, ios%My_comm, mpierr)
       call CheckMPIReturn(subName, mpierr)
    end if



  end function get_vara_3d_real
! DIMS 1,2,3,4,5
!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param varid : The netcdf variable identifier
!! @param start : A vector of size_t integers specifying the index in
!!   the variable where the first of the data values will be read. The
!!   indices are relative to 0, so for example, the first data value of
!!   a variable would have index (0, 0, ... , 0). The length of start
!!   must be the same as the number of dimensions of the specified
!!   variable. The elements of start correspond, in order, to the
!!   variable's dimensions. Hence, if the variable is a record variable,
!!   the first index would correspond to the starting record number for
!!   reading the data values.
!! @param count : A vector of size_t integers specifying the edge
!!   lengths along each dimension of the block of data values to be
!!   read. To read a single value, for example, specify count as (1, 1,
!!   ... , 1). The length of count is the number of dimensions of the
!!   specified variable. The elements of count correspond, in order, to
!!   the variable's dimensions. Hence, if the variable is a record
!!   variable, the first element of count corresponds to a count of the
!!   number of records to read.
!! Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything. 
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_vara_4d_real (File,varid, start, count, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid, start(:), count(:)
    real(r4), intent(out) :: ival(:,:,:,:)
         
    character(len=*), parameter :: subName=modName//'::get_vara_4d_real'

    integer :: dims(4)
    integer :: iotype, mpierr, i, msg, ilen, itype, slen
    integer(kind=PIO_OFFSET) :: isize
    type(iosystem_desc_t), pointer :: ios
    ierr=0
    iotype = File%iotype 
    isize=1
    do i=1,size(count)
       isize=isize*count(i)
    end do



    ios=>File%iosystem
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVARA_4d
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 101
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       slen = size(start)
       call MPI_BCAST(slen,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(start,slen,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(count,slen,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)

       do i=1,4
          dims(i)=size(ival,i)
       end do
       call MPI_BCAST(dims,4,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)


    endif






    if(File%iosystem%IOProc) then
       select case (iotype) 
       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",289)
    if(ios%async_interface .or. ios%num_tasks>ios%num_iotasks) then
       call MPI_Bcast(ival,int(isize), MPI_REAL4 , ios%IOMaster, ios%My_comm, mpierr)
       call CheckMPIReturn(subName, mpierr)
    end if



  end function get_vara_4d_real
! DIMS 1,2,3,4,5
!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param varid : The netcdf variable identifier
!! @param start : A vector of size_t integers specifying the index in
!!   the variable where the first of the data values will be read. The
!!   indices are relative to 0, so for example, the first data value of
!!   a variable would have index (0, 0, ... , 0). The length of start
!!   must be the same as the number of dimensions of the specified
!!   variable. The elements of start correspond, in order, to the
!!   variable's dimensions. Hence, if the variable is a record variable,
!!   the first index would correspond to the starting record number for
!!   reading the data values.
!! @param count : A vector of size_t integers specifying the edge
!!   lengths along each dimension of the block of data values to be
!!   read. To read a single value, for example, specify count as (1, 1,
!!   ... , 1). The length of count is the number of dimensions of the
!!   specified variable. The elements of count correspond, in order, to
!!   the variable's dimensions. Hence, if the variable is a record
!!   variable, the first element of count corresponds to a count of the
!!   number of records to read.
!! Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything. 
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_vara_5d_real (File,varid, start, count, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid, start(:), count(:)
    real(r4), intent(out) :: ival(:,:,:,:,:)
         
    character(len=*), parameter :: subName=modName//'::get_vara_5d_real'

    integer :: dims(5)
    integer :: iotype, mpierr, i, msg, ilen, itype, slen
    integer(kind=PIO_OFFSET) :: isize
    type(iosystem_desc_t), pointer :: ios
    ierr=0
    iotype = File%iotype 
    isize=1
    do i=1,size(count)
       isize=isize*count(i)
    end do



    ios=>File%iosystem
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVARA_5d
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 101
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       slen = size(start)
       call MPI_BCAST(slen,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(start,slen,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(count,slen,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)

       do i=1,5
          dims(i)=size(ival,i)
       end do
       call MPI_BCAST(dims,5,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)


    endif






    if(File%iosystem%IOProc) then
       select case (iotype) 
       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",289)
    if(ios%async_interface .or. ios%num_tasks>ios%num_iotasks) then
       call MPI_Bcast(ival,int(isize), MPI_REAL4 , ios%IOMaster, ios%My_comm, mpierr)
       call CheckMPIReturn(subName, mpierr)
    end if



  end function get_vara_5d_real
! DIMS 1,2,3,4,5
!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param varid : The netcdf variable identifier
!! @param start : A vector of size_t integers specifying the index in
!!   the variable where the first of the data values will be read. The
!!   indices are relative to 0, so for example, the first data value of
!!   a variable would have index (0, 0, ... , 0). The length of start
!!   must be the same as the number of dimensions of the specified
!!   variable. The elements of start correspond, in order, to the
!!   variable's dimensions. Hence, if the variable is a record variable,
!!   the first index would correspond to the starting record number for
!!   reading the data values.
!! @param count : A vector of size_t integers specifying the edge
!!   lengths along each dimension of the block of data values to be
!!   read. To read a single value, for example, specify count as (1, 1,
!!   ... , 1). The length of count is the number of dimensions of the
!!   specified variable. The elements of count correspond, in order, to
!!   the variable's dimensions. Hence, if the variable is a record
!!   variable, the first element of count corresponds to a count of the
!!   number of records to read.
!! Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything. 
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_vara_1d_double (File,varid, start, count, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid, start(:), count(:)
    real(r8), intent(out) :: ival(:)
         
    character(len=*), parameter :: subName=modName//'::get_vara_1d_double'

    integer :: dims(1)
    integer :: iotype, mpierr, i, msg, ilen, itype, slen
    integer(kind=PIO_OFFSET) :: isize
    type(iosystem_desc_t), pointer :: ios
    ierr=0
    iotype = File%iotype 
    isize=1
    do i=1,size(count)
       isize=isize*count(i)
    end do



    ios=>File%iosystem
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVARA_1d
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 102
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       slen = size(start)
       call MPI_BCAST(slen,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(start,slen,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(count,slen,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)

       do i=1,1
          dims(i)=size(ival,i)
       end do
       call MPI_BCAST(dims,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)


    endif






    if(File%iosystem%IOProc) then
       select case (iotype) 
       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",289)
    if(ios%async_interface .or. ios%num_tasks>ios%num_iotasks) then
       call MPI_Bcast(ival,int(isize), MPI_REAL8 , ios%IOMaster, ios%My_comm, mpierr)
       call CheckMPIReturn(subName, mpierr)
    end if



  end function get_vara_1d_double
! DIMS 1,2,3,4,5
!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param varid : The netcdf variable identifier
!! @param start : A vector of size_t integers specifying the index in
!!   the variable where the first of the data values will be read. The
!!   indices are relative to 0, so for example, the first data value of
!!   a variable would have index (0, 0, ... , 0). The length of start
!!   must be the same as the number of dimensions of the specified
!!   variable. The elements of start correspond, in order, to the
!!   variable's dimensions. Hence, if the variable is a record variable,
!!   the first index would correspond to the starting record number for
!!   reading the data values.
!! @param count : A vector of size_t integers specifying the edge
!!   lengths along each dimension of the block of data values to be
!!   read. To read a single value, for example, specify count as (1, 1,
!!   ... , 1). The length of count is the number of dimensions of the
!!   specified variable. The elements of count correspond, in order, to
!!   the variable's dimensions. Hence, if the variable is a record
!!   variable, the first element of count corresponds to a count of the
!!   number of records to read.
!! Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything. 
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_vara_2d_double (File,varid, start, count, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid, start(:), count(:)
    real(r8), intent(out) :: ival(:,:)
         
    character(len=*), parameter :: subName=modName//'::get_vara_2d_double'

    integer :: dims(2)
    integer :: iotype, mpierr, i, msg, ilen, itype, slen
    integer(kind=PIO_OFFSET) :: isize
    type(iosystem_desc_t), pointer :: ios
    ierr=0
    iotype = File%iotype 
    isize=1
    do i=1,size(count)
       isize=isize*count(i)
    end do



    ios=>File%iosystem
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVARA_2d
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 102
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       slen = size(start)
       call MPI_BCAST(slen,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(start,slen,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(count,slen,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)

       do i=1,2
          dims(i)=size(ival,i)
       end do
       call MPI_BCAST(dims,2,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)


    endif






    if(File%iosystem%IOProc) then
       select case (iotype) 
       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",289)
    if(ios%async_interface .or. ios%num_tasks>ios%num_iotasks) then
       call MPI_Bcast(ival,int(isize), MPI_REAL8 , ios%IOMaster, ios%My_comm, mpierr)
       call CheckMPIReturn(subName, mpierr)
    end if



  end function get_vara_2d_double
! DIMS 1,2,3,4,5
!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param varid : The netcdf variable identifier
!! @param start : A vector of size_t integers specifying the index in
!!   the variable where the first of the data values will be read. The
!!   indices are relative to 0, so for example, the first data value of
!!   a variable would have index (0, 0, ... , 0). The length of start
!!   must be the same as the number of dimensions of the specified
!!   variable. The elements of start correspond, in order, to the
!!   variable's dimensions. Hence, if the variable is a record variable,
!!   the first index would correspond to the starting record number for
!!   reading the data values.
!! @param count : A vector of size_t integers specifying the edge
!!   lengths along each dimension of the block of data values to be
!!   read. To read a single value, for example, specify count as (1, 1,
!!   ... , 1). The length of count is the number of dimensions of the
!!   specified variable. The elements of count correspond, in order, to
!!   the variable's dimensions. Hence, if the variable is a record
!!   variable, the first element of count corresponds to a count of the
!!   number of records to read.
!! Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything. 
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_vara_3d_double (File,varid, start, count, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid, start(:), count(:)
    real(r8), intent(out) :: ival(:,:,:)
         
    character(len=*), parameter :: subName=modName//'::get_vara_3d_double'

    integer :: dims(3)
    integer :: iotype, mpierr, i, msg, ilen, itype, slen
    integer(kind=PIO_OFFSET) :: isize
    type(iosystem_desc_t), pointer :: ios
    ierr=0
    iotype = File%iotype 
    isize=1
    do i=1,size(count)
       isize=isize*count(i)
    end do



    ios=>File%iosystem
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVARA_3d
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 102
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       slen = size(start)
       call MPI_BCAST(slen,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(start,slen,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(count,slen,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)

       do i=1,3
          dims(i)=size(ival,i)
       end do
       call MPI_BCAST(dims,3,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)


    endif






    if(File%iosystem%IOProc) then
       select case (iotype) 
       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",289)
    if(ios%async_interface .or. ios%num_tasks>ios%num_iotasks) then
       call MPI_Bcast(ival,int(isize), MPI_REAL8 , ios%IOMaster, ios%My_comm, mpierr)
       call CheckMPIReturn(subName, mpierr)
    end if



  end function get_vara_3d_double
! DIMS 1,2,3,4,5
!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param varid : The netcdf variable identifier
!! @param start : A vector of size_t integers specifying the index in
!!   the variable where the first of the data values will be read. The
!!   indices are relative to 0, so for example, the first data value of
!!   a variable would have index (0, 0, ... , 0). The length of start
!!   must be the same as the number of dimensions of the specified
!!   variable. The elements of start correspond, in order, to the
!!   variable's dimensions. Hence, if the variable is a record variable,
!!   the first index would correspond to the starting record number for
!!   reading the data values.
!! @param count : A vector of size_t integers specifying the edge
!!   lengths along each dimension of the block of data values to be
!!   read. To read a single value, for example, specify count as (1, 1,
!!   ... , 1). The length of count is the number of dimensions of the
!!   specified variable. The elements of count correspond, in order, to
!!   the variable's dimensions. Hence, if the variable is a record
!!   variable, the first element of count corresponds to a count of the
!!   number of records to read.
!! Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything. 
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_vara_4d_double (File,varid, start, count, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid, start(:), count(:)
    real(r8), intent(out) :: ival(:,:,:,:)
         
    character(len=*), parameter :: subName=modName//'::get_vara_4d_double'

    integer :: dims(4)
    integer :: iotype, mpierr, i, msg, ilen, itype, slen
    integer(kind=PIO_OFFSET) :: isize
    type(iosystem_desc_t), pointer :: ios
    ierr=0
    iotype = File%iotype 
    isize=1
    do i=1,size(count)
       isize=isize*count(i)
    end do



    ios=>File%iosystem
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVARA_4d
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 102
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       slen = size(start)
       call MPI_BCAST(slen,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(start,slen,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(count,slen,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)

       do i=1,4
          dims(i)=size(ival,i)
       end do
       call MPI_BCAST(dims,4,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)


    endif






    if(File%iosystem%IOProc) then
       select case (iotype) 
       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",289)
    if(ios%async_interface .or. ios%num_tasks>ios%num_iotasks) then
       call MPI_Bcast(ival,int(isize), MPI_REAL8 , ios%IOMaster, ios%My_comm, mpierr)
       call CheckMPIReturn(subName, mpierr)
    end if



  end function get_vara_4d_double
! DIMS 1,2,3,4,5
!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param varid : The netcdf variable identifier
!! @param start : A vector of size_t integers specifying the index in
!!   the variable where the first of the data values will be read. The
!!   indices are relative to 0, so for example, the first data value of
!!   a variable would have index (0, 0, ... , 0). The length of start
!!   must be the same as the number of dimensions of the specified
!!   variable. The elements of start correspond, in order, to the
!!   variable's dimensions. Hence, if the variable is a record variable,
!!   the first index would correspond to the starting record number for
!!   reading the data values.
!! @param count : A vector of size_t integers specifying the edge
!!   lengths along each dimension of the block of data values to be
!!   read. To read a single value, for example, specify count as (1, 1,
!!   ... , 1). The length of count is the number of dimensions of the
!!   specified variable. The elements of count correspond, in order, to
!!   the variable's dimensions. Hence, if the variable is a record
!!   variable, the first element of count corresponds to a count of the
!!   number of records to read.
!! Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything. 
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_vara_5d_double (File,varid, start, count, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid, start(:), count(:)
    real(r8), intent(out) :: ival(:,:,:,:,:)
         
    character(len=*), parameter :: subName=modName//'::get_vara_5d_double'

    integer :: dims(5)
    integer :: iotype, mpierr, i, msg, ilen, itype, slen
    integer(kind=PIO_OFFSET) :: isize
    type(iosystem_desc_t), pointer :: ios
    ierr=0
    iotype = File%iotype 
    isize=1
    do i=1,size(count)
       isize=isize*count(i)
    end do



    ios=>File%iosystem
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVARA_5d
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 102
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       slen = size(start)
       call MPI_BCAST(slen,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(start,slen,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(count,slen,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)

       do i=1,5
          dims(i)=size(ival,i)
       end do
       call MPI_BCAST(dims,5,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)


    endif






    if(File%iosystem%IOProc) then
       select case (iotype) 
       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",289)
    if(ios%async_interface .or. ios%num_tasks>ios%num_iotasks) then
       call MPI_Bcast(ival,int(isize), MPI_REAL8 , ios%IOMaster, ios%My_comm, mpierr)
       call CheckMPIReturn(subName, mpierr)
    end if



  end function get_vara_5d_double
! DIMS 1,2,3,4,5
!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param varid : The netcdf variable identifier
!! @param start : A vector of size_t integers specifying the index in
!!   the variable where the first of the data values will be read. The
!!   indices are relative to 0, so for example, the first data value of
!!   a variable would have index (0, 0, ... , 0). The length of start
!!   must be the same as the number of dimensions of the specified
!!   variable. The elements of start correspond, in order, to the
!!   variable's dimensions. Hence, if the variable is a record variable,
!!   the first index would correspond to the starting record number for
!!   reading the data values.
!! @param count : A vector of size_t integers specifying the edge
!!   lengths along each dimension of the block of data values to be
!!   read. To read a single value, for example, specify count as (1, 1,
!!   ... , 1). The length of count is the number of dimensions of the
!!   specified variable. The elements of count correspond, in order, to
!!   the variable's dimensions. Hence, if the variable is a record
!!   variable, the first element of count corresponds to a count of the
!!   number of records to read.
!! Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything. 
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_vara_1d_int (File,varid, start, count, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid, start(:), count(:)
    integer(i4), intent(out) :: ival(:)
         
    character(len=*), parameter :: subName=modName//'::get_vara_1d_int'

    integer :: dims(1)
    integer :: iotype, mpierr, i, msg, ilen, itype, slen
    integer(kind=PIO_OFFSET) :: isize
    type(iosystem_desc_t), pointer :: ios
    ierr=0
    iotype = File%iotype 
    isize=1
    do i=1,size(count)
       isize=isize*count(i)
    end do



    ios=>File%iosystem
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVARA_1d
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 103
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       slen = size(start)
       call MPI_BCAST(slen,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(start,slen,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(count,slen,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)

       do i=1,1
          dims(i)=size(ival,i)
       end do
       call MPI_BCAST(dims,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)


    endif






    if(File%iosystem%IOProc) then
       select case (iotype) 
       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",289)
    if(ios%async_interface .or. ios%num_tasks>ios%num_iotasks) then
       call MPI_Bcast(ival,int(isize), MPI_INTEGER , ios%IOMaster, ios%My_comm, mpierr)
       call CheckMPIReturn(subName, mpierr)
    end if



  end function get_vara_1d_int
! DIMS 1,2,3,4,5
!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param varid : The netcdf variable identifier
!! @param start : A vector of size_t integers specifying the index in
!!   the variable where the first of the data values will be read. The
!!   indices are relative to 0, so for example, the first data value of
!!   a variable would have index (0, 0, ... , 0). The length of start
!!   must be the same as the number of dimensions of the specified
!!   variable. The elements of start correspond, in order, to the
!!   variable's dimensions. Hence, if the variable is a record variable,
!!   the first index would correspond to the starting record number for
!!   reading the data values.
!! @param count : A vector of size_t integers specifying the edge
!!   lengths along each dimension of the block of data values to be
!!   read. To read a single value, for example, specify count as (1, 1,
!!   ... , 1). The length of count is the number of dimensions of the
!!   specified variable. The elements of count correspond, in order, to
!!   the variable's dimensions. Hence, if the variable is a record
!!   variable, the first element of count corresponds to a count of the
!!   number of records to read.
!! Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything. 
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_vara_2d_int (File,varid, start, count, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid, start(:), count(:)
    integer(i4), intent(out) :: ival(:,:)
         
    character(len=*), parameter :: subName=modName//'::get_vara_2d_int'

    integer :: dims(2)
    integer :: iotype, mpierr, i, msg, ilen, itype, slen
    integer(kind=PIO_OFFSET) :: isize
    type(iosystem_desc_t), pointer :: ios
    ierr=0
    iotype = File%iotype 
    isize=1
    do i=1,size(count)
       isize=isize*count(i)
    end do



    ios=>File%iosystem
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVARA_2d
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 103
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       slen = size(start)
       call MPI_BCAST(slen,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(start,slen,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(count,slen,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)

       do i=1,2
          dims(i)=size(ival,i)
       end do
       call MPI_BCAST(dims,2,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)


    endif






    if(File%iosystem%IOProc) then
       select case (iotype) 
       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",289)
    if(ios%async_interface .or. ios%num_tasks>ios%num_iotasks) then
       call MPI_Bcast(ival,int(isize), MPI_INTEGER , ios%IOMaster, ios%My_comm, mpierr)
       call CheckMPIReturn(subName, mpierr)
    end if



  end function get_vara_2d_int
! DIMS 1,2,3,4,5
!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param varid : The netcdf variable identifier
!! @param start : A vector of size_t integers specifying the index in
!!   the variable where the first of the data values will be read. The
!!   indices are relative to 0, so for example, the first data value of
!!   a variable would have index (0, 0, ... , 0). The length of start
!!   must be the same as the number of dimensions of the specified
!!   variable. The elements of start correspond, in order, to the
!!   variable's dimensions. Hence, if the variable is a record variable,
!!   the first index would correspond to the starting record number for
!!   reading the data values.
!! @param count : A vector of size_t integers specifying the edge
!!   lengths along each dimension of the block of data values to be
!!   read. To read a single value, for example, specify count as (1, 1,
!!   ... , 1). The length of count is the number of dimensions of the
!!   specified variable. The elements of count correspond, in order, to
!!   the variable's dimensions. Hence, if the variable is a record
!!   variable, the first element of count corresponds to a count of the
!!   number of records to read.
!! Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything. 
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_vara_3d_int (File,varid, start, count, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid, start(:), count(:)
    integer(i4), intent(out) :: ival(:,:,:)
         
    character(len=*), parameter :: subName=modName//'::get_vara_3d_int'

    integer :: dims(3)
    integer :: iotype, mpierr, i, msg, ilen, itype, slen
    integer(kind=PIO_OFFSET) :: isize
    type(iosystem_desc_t), pointer :: ios
    ierr=0
    iotype = File%iotype 
    isize=1
    do i=1,size(count)
       isize=isize*count(i)
    end do



    ios=>File%iosystem
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVARA_3d
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 103
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       slen = size(start)
       call MPI_BCAST(slen,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(start,slen,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(count,slen,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)

       do i=1,3
          dims(i)=size(ival,i)
       end do
       call MPI_BCAST(dims,3,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)


    endif






    if(File%iosystem%IOProc) then
       select case (iotype) 
       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",289)
    if(ios%async_interface .or. ios%num_tasks>ios%num_iotasks) then
       call MPI_Bcast(ival,int(isize), MPI_INTEGER , ios%IOMaster, ios%My_comm, mpierr)
       call CheckMPIReturn(subName, mpierr)
    end if



  end function get_vara_3d_int
! DIMS 1,2,3,4,5
!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param varid : The netcdf variable identifier
!! @param start : A vector of size_t integers specifying the index in
!!   the variable where the first of the data values will be read. The
!!   indices are relative to 0, so for example, the first data value of
!!   a variable would have index (0, 0, ... , 0). The length of start
!!   must be the same as the number of dimensions of the specified
!!   variable. The elements of start correspond, in order, to the
!!   variable's dimensions. Hence, if the variable is a record variable,
!!   the first index would correspond to the starting record number for
!!   reading the data values.
!! @param count : A vector of size_t integers specifying the edge
!!   lengths along each dimension of the block of data values to be
!!   read. To read a single value, for example, specify count as (1, 1,
!!   ... , 1). The length of count is the number of dimensions of the
!!   specified variable. The elements of count correspond, in order, to
!!   the variable's dimensions. Hence, if the variable is a record
!!   variable, the first element of count corresponds to a count of the
!!   number of records to read.
!! Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything. 
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_vara_4d_int (File,varid, start, count, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid, start(:), count(:)
    integer(i4), intent(out) :: ival(:,:,:,:)
         
    character(len=*), parameter :: subName=modName//'::get_vara_4d_int'

    integer :: dims(4)
    integer :: iotype, mpierr, i, msg, ilen, itype, slen
    integer(kind=PIO_OFFSET) :: isize
    type(iosystem_desc_t), pointer :: ios
    ierr=0
    iotype = File%iotype 
    isize=1
    do i=1,size(count)
       isize=isize*count(i)
    end do



    ios=>File%iosystem
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVARA_4d
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 103
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       slen = size(start)
       call MPI_BCAST(slen,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(start,slen,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(count,slen,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)

       do i=1,4
          dims(i)=size(ival,i)
       end do
       call MPI_BCAST(dims,4,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)


    endif






    if(File%iosystem%IOProc) then
       select case (iotype) 
       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",289)
    if(ios%async_interface .or. ios%num_tasks>ios%num_iotasks) then
       call MPI_Bcast(ival,int(isize), MPI_INTEGER , ios%IOMaster, ios%My_comm, mpierr)
       call CheckMPIReturn(subName, mpierr)
    end if



  end function get_vara_4d_int
! DIMS 1,2,3,4,5
!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param varid : The netcdf variable identifier
!! @param start : A vector of size_t integers specifying the index in
!!   the variable where the first of the data values will be read. The
!!   indices are relative to 0, so for example, the first data value of
!!   a variable would have index (0, 0, ... , 0). The length of start
!!   must be the same as the number of dimensions of the specified
!!   variable. The elements of start correspond, in order, to the
!!   variable's dimensions. Hence, if the variable is a record variable,
!!   the first index would correspond to the starting record number for
!!   reading the data values.
!! @param count : A vector of size_t integers specifying the edge
!!   lengths along each dimension of the block of data values to be
!!   read. To read a single value, for example, specify count as (1, 1,
!!   ... , 1). The length of count is the number of dimensions of the
!!   specified variable. The elements of count correspond, in order, to
!!   the variable's dimensions. Hence, if the variable is a record
!!   variable, the first element of count corresponds to a count of the
!!   number of records to read.
!! Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything. 
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_vara_5d_int (File,varid, start, count, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid, start(:), count(:)
    integer(i4), intent(out) :: ival(:,:,:,:,:)
         
    character(len=*), parameter :: subName=modName//'::get_vara_5d_int'

    integer :: dims(5)
    integer :: iotype, mpierr, i, msg, ilen, itype, slen
    integer(kind=PIO_OFFSET) :: isize
    type(iosystem_desc_t), pointer :: ios
    ierr=0
    iotype = File%iotype 
    isize=1
    do i=1,size(count)
       isize=isize*count(i)
    end do



    ios=>File%iosystem
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVARA_5d
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 103
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       slen = size(start)
       call MPI_BCAST(slen,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(start,slen,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(count,slen,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)

       do i=1,5
          dims(i)=size(ival,i)
       end do
       call MPI_BCAST(dims,5,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)


    endif






    if(File%iosystem%IOProc) then
       select case (iotype) 
       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",289)
    if(ios%async_interface .or. ios%num_tasks>ios%num_iotasks) then
       call MPI_Bcast(ival,int(isize), MPI_INTEGER , ios%IOMaster, ios%My_comm, mpierr)
       call CheckMPIReturn(subName, mpierr)
    end if



  end function get_vara_5d_int

! DIMS 1,2,3,4,5
!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param vardesc @ref var_desc_t
!! @param start : A vector of size_t integers specifying the index in
!!   the variable where the first of the data values will be read. The
!!   indices are relative to 0, so for example, the first data value of
!!   a variable would have index (0, 0, ... , 0). The length of start
!!   must be the same as the number of dimensions of the specified
!!   variable. The elements of start correspond, in order, to the
!!   variable's dimensions. Hence, if the variable is a record variable,
!!   the first index would correspond to the starting record number for
!!   reading the data values.
!! @param count : A vector of size_t integers specifying the edge
!!   lengths along each dimension of the block of data values to be
!!   read. To read a single value, for example, specify count as (1, 1,
!!   ... , 1). The length of count is the number of dimensions of the
!!   specified variable. The elements of count correspond, in order, to
!!   the variable's dimensions. Hence, if the variable is a record
!!   variable, the first element of count corresponds to a count of the
!!   number of records to read.
!! Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything. 
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_vara_vdesc_1d_text (File,vardesc, start, count, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    integer, intent(in) :: start(:), count(:)
    character(len=*), intent(out) :: ival(:)

    character(len=*), parameter :: subName=modName//'::get_vara_vdesc_1d_text'

    ierr = get_vara_1d_text (File, vardesc%varid, start, count, ival)

  end function get_vara_vdesc_1d_text
! DIMS 1,2,3,4,5
!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param vardesc @ref var_desc_t
!! @param start : A vector of size_t integers specifying the index in
!!   the variable where the first of the data values will be read. The
!!   indices are relative to 0, so for example, the first data value of
!!   a variable would have index (0, 0, ... , 0). The length of start
!!   must be the same as the number of dimensions of the specified
!!   variable. The elements of start correspond, in order, to the
!!   variable's dimensions. Hence, if the variable is a record variable,
!!   the first index would correspond to the starting record number for
!!   reading the data values.
!! @param count : A vector of size_t integers specifying the edge
!!   lengths along each dimension of the block of data values to be
!!   read. To read a single value, for example, specify count as (1, 1,
!!   ... , 1). The length of count is the number of dimensions of the
!!   specified variable. The elements of count correspond, in order, to
!!   the variable's dimensions. Hence, if the variable is a record
!!   variable, the first element of count corresponds to a count of the
!!   number of records to read.
!! Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything. 
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_vara_vdesc_2d_text (File,vardesc, start, count, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    integer, intent(in) :: start(:), count(:)
    character(len=*), intent(out) :: ival(:,:)

    character(len=*), parameter :: subName=modName//'::get_vara_vdesc_2d_text'

    ierr = get_vara_2d_text (File, vardesc%varid, start, count, ival)

  end function get_vara_vdesc_2d_text
! DIMS 1,2,3,4,5
!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param vardesc @ref var_desc_t
!! @param start : A vector of size_t integers specifying the index in
!!   the variable where the first of the data values will be read. The
!!   indices are relative to 0, so for example, the first data value of
!!   a variable would have index (0, 0, ... , 0). The length of start
!!   must be the same as the number of dimensions of the specified
!!   variable. The elements of start correspond, in order, to the
!!   variable's dimensions. Hence, if the variable is a record variable,
!!   the first index would correspond to the starting record number for
!!   reading the data values.
!! @param count : A vector of size_t integers specifying the edge
!!   lengths along each dimension of the block of data values to be
!!   read. To read a single value, for example, specify count as (1, 1,
!!   ... , 1). The length of count is the number of dimensions of the
!!   specified variable. The elements of count correspond, in order, to
!!   the variable's dimensions. Hence, if the variable is a record
!!   variable, the first element of count corresponds to a count of the
!!   number of records to read.
!! Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything. 
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_vara_vdesc_3d_text (File,vardesc, start, count, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    integer, intent(in) :: start(:), count(:)
    character(len=*), intent(out) :: ival(:,:,:)

    character(len=*), parameter :: subName=modName//'::get_vara_vdesc_3d_text'

    ierr = get_vara_3d_text (File, vardesc%varid, start, count, ival)

  end function get_vara_vdesc_3d_text
! DIMS 1,2,3,4,5
!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param vardesc @ref var_desc_t
!! @param start : A vector of size_t integers specifying the index in
!!   the variable where the first of the data values will be read. The
!!   indices are relative to 0, so for example, the first data value of
!!   a variable would have index (0, 0, ... , 0). The length of start
!!   must be the same as the number of dimensions of the specified
!!   variable. The elements of start correspond, in order, to the
!!   variable's dimensions. Hence, if the variable is a record variable,
!!   the first index would correspond to the starting record number for
!!   reading the data values.
!! @param count : A vector of size_t integers specifying the edge
!!   lengths along each dimension of the block of data values to be
!!   read. To read a single value, for example, specify count as (1, 1,
!!   ... , 1). The length of count is the number of dimensions of the
!!   specified variable. The elements of count correspond, in order, to
!!   the variable's dimensions. Hence, if the variable is a record
!!   variable, the first element of count corresponds to a count of the
!!   number of records to read.
!! Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything. 
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_vara_vdesc_4d_text (File,vardesc, start, count, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    integer, intent(in) :: start(:), count(:)
    character(len=*), intent(out) :: ival(:,:,:,:)

    character(len=*), parameter :: subName=modName//'::get_vara_vdesc_4d_text'

    ierr = get_vara_4d_text (File, vardesc%varid, start, count, ival)

  end function get_vara_vdesc_4d_text
! DIMS 1,2,3,4,5
!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param vardesc @ref var_desc_t
!! @param start : A vector of size_t integers specifying the index in
!!   the variable where the first of the data values will be read. The
!!   indices are relative to 0, so for example, the first data value of
!!   a variable would have index (0, 0, ... , 0). The length of start
!!   must be the same as the number of dimensions of the specified
!!   variable. The elements of start correspond, in order, to the
!!   variable's dimensions. Hence, if the variable is a record variable,
!!   the first index would correspond to the starting record number for
!!   reading the data values.
!! @param count : A vector of size_t integers specifying the edge
!!   lengths along each dimension of the block of data values to be
!!   read. To read a single value, for example, specify count as (1, 1,
!!   ... , 1). The length of count is the number of dimensions of the
!!   specified variable. The elements of count correspond, in order, to
!!   the variable's dimensions. Hence, if the variable is a record
!!   variable, the first element of count corresponds to a count of the
!!   number of records to read.
!! Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything. 
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_vara_vdesc_5d_text (File,vardesc, start, count, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    integer, intent(in) :: start(:), count(:)
    character(len=*), intent(out) :: ival(:,:,:,:,:)

    character(len=*), parameter :: subName=modName//'::get_vara_vdesc_5d_text'

    ierr = get_vara_5d_text (File, vardesc%varid, start, count, ival)

  end function get_vara_vdesc_5d_text
! DIMS 1,2,3,4,5
!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param vardesc @ref var_desc_t
!! @param start : A vector of size_t integers specifying the index in
!!   the variable where the first of the data values will be read. The
!!   indices are relative to 0, so for example, the first data value of
!!   a variable would have index (0, 0, ... , 0). The length of start
!!   must be the same as the number of dimensions of the specified
!!   variable. The elements of start correspond, in order, to the
!!   variable's dimensions. Hence, if the variable is a record variable,
!!   the first index would correspond to the starting record number for
!!   reading the data values.
!! @param count : A vector of size_t integers specifying the edge
!!   lengths along each dimension of the block of data values to be
!!   read. To read a single value, for example, specify count as (1, 1,
!!   ... , 1). The length of count is the number of dimensions of the
!!   specified variable. The elements of count correspond, in order, to
!!   the variable's dimensions. Hence, if the variable is a record
!!   variable, the first element of count corresponds to a count of the
!!   number of records to read.
!! Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything. 
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_vara_vdesc_1d_real (File,vardesc, start, count, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    integer, intent(in) :: start(:), count(:)
    real(r4), intent(out) :: ival(:)

    character(len=*), parameter :: subName=modName//'::get_vara_vdesc_1d_real'

    ierr = get_vara_1d_real (File, vardesc%varid, start, count, ival)

  end function get_vara_vdesc_1d_real
! DIMS 1,2,3,4,5
!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param vardesc @ref var_desc_t
!! @param start : A vector of size_t integers specifying the index in
!!   the variable where the first of the data values will be read. The
!!   indices are relative to 0, so for example, the first data value of
!!   a variable would have index (0, 0, ... , 0). The length of start
!!   must be the same as the number of dimensions of the specified
!!   variable. The elements of start correspond, in order, to the
!!   variable's dimensions. Hence, if the variable is a record variable,
!!   the first index would correspond to the starting record number for
!!   reading the data values.
!! @param count : A vector of size_t integers specifying the edge
!!   lengths along each dimension of the block of data values to be
!!   read. To read a single value, for example, specify count as (1, 1,
!!   ... , 1). The length of count is the number of dimensions of the
!!   specified variable. The elements of count correspond, in order, to
!!   the variable's dimensions. Hence, if the variable is a record
!!   variable, the first element of count corresponds to a count of the
!!   number of records to read.
!! Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything. 
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_vara_vdesc_2d_real (File,vardesc, start, count, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    integer, intent(in) :: start(:), count(:)
    real(r4), intent(out) :: ival(:,:)

    character(len=*), parameter :: subName=modName//'::get_vara_vdesc_2d_real'

    ierr = get_vara_2d_real (File, vardesc%varid, start, count, ival)

  end function get_vara_vdesc_2d_real
! DIMS 1,2,3,4,5
!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param vardesc @ref var_desc_t
!! @param start : A vector of size_t integers specifying the index in
!!   the variable where the first of the data values will be read. The
!!   indices are relative to 0, so for example, the first data value of
!!   a variable would have index (0, 0, ... , 0). The length of start
!!   must be the same as the number of dimensions of the specified
!!   variable. The elements of start correspond, in order, to the
!!   variable's dimensions. Hence, if the variable is a record variable,
!!   the first index would correspond to the starting record number for
!!   reading the data values.
!! @param count : A vector of size_t integers specifying the edge
!!   lengths along each dimension of the block of data values to be
!!   read. To read a single value, for example, specify count as (1, 1,
!!   ... , 1). The length of count is the number of dimensions of the
!!   specified variable. The elements of count correspond, in order, to
!!   the variable's dimensions. Hence, if the variable is a record
!!   variable, the first element of count corresponds to a count of the
!!   number of records to read.
!! Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything. 
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_vara_vdesc_3d_real (File,vardesc, start, count, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    integer, intent(in) :: start(:), count(:)
    real(r4), intent(out) :: ival(:,:,:)

    character(len=*), parameter :: subName=modName//'::get_vara_vdesc_3d_real'

    ierr = get_vara_3d_real (File, vardesc%varid, start, count, ival)

  end function get_vara_vdesc_3d_real
! DIMS 1,2,3,4,5
!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param vardesc @ref var_desc_t
!! @param start : A vector of size_t integers specifying the index in
!!   the variable where the first of the data values will be read. The
!!   indices are relative to 0, so for example, the first data value of
!!   a variable would have index (0, 0, ... , 0). The length of start
!!   must be the same as the number of dimensions of the specified
!!   variable. The elements of start correspond, in order, to the
!!   variable's dimensions. Hence, if the variable is a record variable,
!!   the first index would correspond to the starting record number for
!!   reading the data values.
!! @param count : A vector of size_t integers specifying the edge
!!   lengths along each dimension of the block of data values to be
!!   read. To read a single value, for example, specify count as (1, 1,
!!   ... , 1). The length of count is the number of dimensions of the
!!   specified variable. The elements of count correspond, in order, to
!!   the variable's dimensions. Hence, if the variable is a record
!!   variable, the first element of count corresponds to a count of the
!!   number of records to read.
!! Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything. 
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_vara_vdesc_4d_real (File,vardesc, start, count, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    integer, intent(in) :: start(:), count(:)
    real(r4), intent(out) :: ival(:,:,:,:)

    character(len=*), parameter :: subName=modName//'::get_vara_vdesc_4d_real'

    ierr = get_vara_4d_real (File, vardesc%varid, start, count, ival)

  end function get_vara_vdesc_4d_real
! DIMS 1,2,3,4,5
!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param vardesc @ref var_desc_t
!! @param start : A vector of size_t integers specifying the index in
!!   the variable where the first of the data values will be read. The
!!   indices are relative to 0, so for example, the first data value of
!!   a variable would have index (0, 0, ... , 0). The length of start
!!   must be the same as the number of dimensions of the specified
!!   variable. The elements of start correspond, in order, to the
!!   variable's dimensions. Hence, if the variable is a record variable,
!!   the first index would correspond to the starting record number for
!!   reading the data values.
!! @param count : A vector of size_t integers specifying the edge
!!   lengths along each dimension of the block of data values to be
!!   read. To read a single value, for example, specify count as (1, 1,
!!   ... , 1). The length of count is the number of dimensions of the
!!   specified variable. The elements of count correspond, in order, to
!!   the variable's dimensions. Hence, if the variable is a record
!!   variable, the first element of count corresponds to a count of the
!!   number of records to read.
!! Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything. 
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_vara_vdesc_5d_real (File,vardesc, start, count, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    integer, intent(in) :: start(:), count(:)
    real(r4), intent(out) :: ival(:,:,:,:,:)

    character(len=*), parameter :: subName=modName//'::get_vara_vdesc_5d_real'

    ierr = get_vara_5d_real (File, vardesc%varid, start, count, ival)

  end function get_vara_vdesc_5d_real
! DIMS 1,2,3,4,5
!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param vardesc @ref var_desc_t
!! @param start : A vector of size_t integers specifying the index in
!!   the variable where the first of the data values will be read. The
!!   indices are relative to 0, so for example, the first data value of
!!   a variable would have index (0, 0, ... , 0). The length of start
!!   must be the same as the number of dimensions of the specified
!!   variable. The elements of start correspond, in order, to the
!!   variable's dimensions. Hence, if the variable is a record variable,
!!   the first index would correspond to the starting record number for
!!   reading the data values.
!! @param count : A vector of size_t integers specifying the edge
!!   lengths along each dimension of the block of data values to be
!!   read. To read a single value, for example, specify count as (1, 1,
!!   ... , 1). The length of count is the number of dimensions of the
!!   specified variable. The elements of count correspond, in order, to
!!   the variable's dimensions. Hence, if the variable is a record
!!   variable, the first element of count corresponds to a count of the
!!   number of records to read.
!! Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything. 
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_vara_vdesc_1d_double (File,vardesc, start, count, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    integer, intent(in) :: start(:), count(:)
    real(r8), intent(out) :: ival(:)

    character(len=*), parameter :: subName=modName//'::get_vara_vdesc_1d_double'

    ierr = get_vara_1d_double (File, vardesc%varid, start, count, ival)

  end function get_vara_vdesc_1d_double
! DIMS 1,2,3,4,5
!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param vardesc @ref var_desc_t
!! @param start : A vector of size_t integers specifying the index in
!!   the variable where the first of the data values will be read. The
!!   indices are relative to 0, so for example, the first data value of
!!   a variable would have index (0, 0, ... , 0). The length of start
!!   must be the same as the number of dimensions of the specified
!!   variable. The elements of start correspond, in order, to the
!!   variable's dimensions. Hence, if the variable is a record variable,
!!   the first index would correspond to the starting record number for
!!   reading the data values.
!! @param count : A vector of size_t integers specifying the edge
!!   lengths along each dimension of the block of data values to be
!!   read. To read a single value, for example, specify count as (1, 1,
!!   ... , 1). The length of count is the number of dimensions of the
!!   specified variable. The elements of count correspond, in order, to
!!   the variable's dimensions. Hence, if the variable is a record
!!   variable, the first element of count corresponds to a count of the
!!   number of records to read.
!! Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything. 
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_vara_vdesc_2d_double (File,vardesc, start, count, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    integer, intent(in) :: start(:), count(:)
    real(r8), intent(out) :: ival(:,:)

    character(len=*), parameter :: subName=modName//'::get_vara_vdesc_2d_double'

    ierr = get_vara_2d_double (File, vardesc%varid, start, count, ival)

  end function get_vara_vdesc_2d_double
! DIMS 1,2,3,4,5
!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param vardesc @ref var_desc_t
!! @param start : A vector of size_t integers specifying the index in
!!   the variable where the first of the data values will be read. The
!!   indices are relative to 0, so for example, the first data value of
!!   a variable would have index (0, 0, ... , 0). The length of start
!!   must be the same as the number of dimensions of the specified
!!   variable. The elements of start correspond, in order, to the
!!   variable's dimensions. Hence, if the variable is a record variable,
!!   the first index would correspond to the starting record number for
!!   reading the data values.
!! @param count : A vector of size_t integers specifying the edge
!!   lengths along each dimension of the block of data values to be
!!   read. To read a single value, for example, specify count as (1, 1,
!!   ... , 1). The length of count is the number of dimensions of the
!!   specified variable. The elements of count correspond, in order, to
!!   the variable's dimensions. Hence, if the variable is a record
!!   variable, the first element of count corresponds to a count of the
!!   number of records to read.
!! Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything. 
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_vara_vdesc_3d_double (File,vardesc, start, count, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    integer, intent(in) :: start(:), count(:)
    real(r8), intent(out) :: ival(:,:,:)

    character(len=*), parameter :: subName=modName//'::get_vara_vdesc_3d_double'

    ierr = get_vara_3d_double (File, vardesc%varid, start, count, ival)

  end function get_vara_vdesc_3d_double
! DIMS 1,2,3,4,5
!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param vardesc @ref var_desc_t
!! @param start : A vector of size_t integers specifying the index in
!!   the variable where the first of the data values will be read. The
!!   indices are relative to 0, so for example, the first data value of
!!   a variable would have index (0, 0, ... , 0). The length of start
!!   must be the same as the number of dimensions of the specified
!!   variable. The elements of start correspond, in order, to the
!!   variable's dimensions. Hence, if the variable is a record variable,
!!   the first index would correspond to the starting record number for
!!   reading the data values.
!! @param count : A vector of size_t integers specifying the edge
!!   lengths along each dimension of the block of data values to be
!!   read. To read a single value, for example, specify count as (1, 1,
!!   ... , 1). The length of count is the number of dimensions of the
!!   specified variable. The elements of count correspond, in order, to
!!   the variable's dimensions. Hence, if the variable is a record
!!   variable, the first element of count corresponds to a count of the
!!   number of records to read.
!! Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything. 
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_vara_vdesc_4d_double (File,vardesc, start, count, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    integer, intent(in) :: start(:), count(:)
    real(r8), intent(out) :: ival(:,:,:,:)

    character(len=*), parameter :: subName=modName//'::get_vara_vdesc_4d_double'

    ierr = get_vara_4d_double (File, vardesc%varid, start, count, ival)

  end function get_vara_vdesc_4d_double
! DIMS 1,2,3,4,5
!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param vardesc @ref var_desc_t
!! @param start : A vector of size_t integers specifying the index in
!!   the variable where the first of the data values will be read. The
!!   indices are relative to 0, so for example, the first data value of
!!   a variable would have index (0, 0, ... , 0). The length of start
!!   must be the same as the number of dimensions of the specified
!!   variable. The elements of start correspond, in order, to the
!!   variable's dimensions. Hence, if the variable is a record variable,
!!   the first index would correspond to the starting record number for
!!   reading the data values.
!! @param count : A vector of size_t integers specifying the edge
!!   lengths along each dimension of the block of data values to be
!!   read. To read a single value, for example, specify count as (1, 1,
!!   ... , 1). The length of count is the number of dimensions of the
!!   specified variable. The elements of count correspond, in order, to
!!   the variable's dimensions. Hence, if the variable is a record
!!   variable, the first element of count corresponds to a count of the
!!   number of records to read.
!! Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything. 
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_vara_vdesc_5d_double (File,vardesc, start, count, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    integer, intent(in) :: start(:), count(:)
    real(r8), intent(out) :: ival(:,:,:,:,:)

    character(len=*), parameter :: subName=modName//'::get_vara_vdesc_5d_double'

    ierr = get_vara_5d_double (File, vardesc%varid, start, count, ival)

  end function get_vara_vdesc_5d_double
! DIMS 1,2,3,4,5
!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param vardesc @ref var_desc_t
!! @param start : A vector of size_t integers specifying the index in
!!   the variable where the first of the data values will be read. The
!!   indices are relative to 0, so for example, the first data value of
!!   a variable would have index (0, 0, ... , 0). The length of start
!!   must be the same as the number of dimensions of the specified
!!   variable. The elements of start correspond, in order, to the
!!   variable's dimensions. Hence, if the variable is a record variable,
!!   the first index would correspond to the starting record number for
!!   reading the data values.
!! @param count : A vector of size_t integers specifying the edge
!!   lengths along each dimension of the block of data values to be
!!   read. To read a single value, for example, specify count as (1, 1,
!!   ... , 1). The length of count is the number of dimensions of the
!!   specified variable. The elements of count correspond, in order, to
!!   the variable's dimensions. Hence, if the variable is a record
!!   variable, the first element of count corresponds to a count of the
!!   number of records to read.
!! Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything. 
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_vara_vdesc_1d_int (File,vardesc, start, count, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    integer, intent(in) :: start(:), count(:)
    integer(i4), intent(out) :: ival(:)

    character(len=*), parameter :: subName=modName//'::get_vara_vdesc_1d_int'

    ierr = get_vara_1d_int (File, vardesc%varid, start, count, ival)

  end function get_vara_vdesc_1d_int
! DIMS 1,2,3,4,5
!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param vardesc @ref var_desc_t
!! @param start : A vector of size_t integers specifying the index in
!!   the variable where the first of the data values will be read. The
!!   indices are relative to 0, so for example, the first data value of
!!   a variable would have index (0, 0, ... , 0). The length of start
!!   must be the same as the number of dimensions of the specified
!!   variable. The elements of start correspond, in order, to the
!!   variable's dimensions. Hence, if the variable is a record variable,
!!   the first index would correspond to the starting record number for
!!   reading the data values.
!! @param count : A vector of size_t integers specifying the edge
!!   lengths along each dimension of the block of data values to be
!!   read. To read a single value, for example, specify count as (1, 1,
!!   ... , 1). The length of count is the number of dimensions of the
!!   specified variable. The elements of count correspond, in order, to
!!   the variable's dimensions. Hence, if the variable is a record
!!   variable, the first element of count corresponds to a count of the
!!   number of records to read.
!! Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything. 
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_vara_vdesc_2d_int (File,vardesc, start, count, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    integer, intent(in) :: start(:), count(:)
    integer(i4), intent(out) :: ival(:,:)

    character(len=*), parameter :: subName=modName//'::get_vara_vdesc_2d_int'

    ierr = get_vara_2d_int (File, vardesc%varid, start, count, ival)

  end function get_vara_vdesc_2d_int
! DIMS 1,2,3,4,5
!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param vardesc @ref var_desc_t
!! @param start : A vector of size_t integers specifying the index in
!!   the variable where the first of the data values will be read. The
!!   indices are relative to 0, so for example, the first data value of
!!   a variable would have index (0, 0, ... , 0). The length of start
!!   must be the same as the number of dimensions of the specified
!!   variable. The elements of start correspond, in order, to the
!!   variable's dimensions. Hence, if the variable is a record variable,
!!   the first index would correspond to the starting record number for
!!   reading the data values.
!! @param count : A vector of size_t integers specifying the edge
!!   lengths along each dimension of the block of data values to be
!!   read. To read a single value, for example, specify count as (1, 1,
!!   ... , 1). The length of count is the number of dimensions of the
!!   specified variable. The elements of count correspond, in order, to
!!   the variable's dimensions. Hence, if the variable is a record
!!   variable, the first element of count corresponds to a count of the
!!   number of records to read.
!! Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything. 
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_vara_vdesc_3d_int (File,vardesc, start, count, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    integer, intent(in) :: start(:), count(:)
    integer(i4), intent(out) :: ival(:,:,:)

    character(len=*), parameter :: subName=modName//'::get_vara_vdesc_3d_int'

    ierr = get_vara_3d_int (File, vardesc%varid, start, count, ival)

  end function get_vara_vdesc_3d_int
! DIMS 1,2,3,4,5
!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param vardesc @ref var_desc_t
!! @param start : A vector of size_t integers specifying the index in
!!   the variable where the first of the data values will be read. The
!!   indices are relative to 0, so for example, the first data value of
!!   a variable would have index (0, 0, ... , 0). The length of start
!!   must be the same as the number of dimensions of the specified
!!   variable. The elements of start correspond, in order, to the
!!   variable's dimensions. Hence, if the variable is a record variable,
!!   the first index would correspond to the starting record number for
!!   reading the data values.
!! @param count : A vector of size_t integers specifying the edge
!!   lengths along each dimension of the block of data values to be
!!   read. To read a single value, for example, specify count as (1, 1,
!!   ... , 1). The length of count is the number of dimensions of the
!!   specified variable. The elements of count correspond, in order, to
!!   the variable's dimensions. Hence, if the variable is a record
!!   variable, the first element of count corresponds to a count of the
!!   number of records to read.
!! Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything. 
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_vara_vdesc_4d_int (File,vardesc, start, count, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    integer, intent(in) :: start(:), count(:)
    integer(i4), intent(out) :: ival(:,:,:,:)

    character(len=*), parameter :: subName=modName//'::get_vara_vdesc_4d_int'

    ierr = get_vara_4d_int (File, vardesc%varid, start, count, ival)

  end function get_vara_vdesc_4d_int
! DIMS 1,2,3,4,5
!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param vardesc @ref var_desc_t
!! @param start : A vector of size_t integers specifying the index in
!!   the variable where the first of the data values will be read. The
!!   indices are relative to 0, so for example, the first data value of
!!   a variable would have index (0, 0, ... , 0). The length of start
!!   must be the same as the number of dimensions of the specified
!!   variable. The elements of start correspond, in order, to the
!!   variable's dimensions. Hence, if the variable is a record variable,
!!   the first index would correspond to the starting record number for
!!   reading the data values.
!! @param count : A vector of size_t integers specifying the edge
!!   lengths along each dimension of the block of data values to be
!!   read. To read a single value, for example, specify count as (1, 1,
!!   ... , 1). The length of count is the number of dimensions of the
!!   specified variable. The elements of count correspond, in order, to
!!   the variable's dimensions. Hence, if the variable is a record
!!   variable, the first element of count corresponds to a count of the
!!   number of records to read.
!! Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything. 
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_vara_vdesc_5d_int (File,vardesc, start, count, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    integer, intent(in) :: start(:), count(:)
    integer(i4), intent(out) :: ival(:,:,:,:,:)

    character(len=*), parameter :: subName=modName//'::get_vara_vdesc_5d_int'

    ierr = get_vara_5d_int (File, vardesc%varid, start, count, ival)

  end function get_vara_vdesc_5d_int

!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param varid : The netcdf variable identifier
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_var_0d_text (File,varid, ival) result(ierr)
    use pio_msg_mod, only : pio_msg_getvar_0d
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid
    character(len=*), intent(out) :: ival
    type(iosystem_desc_t), pointer :: ios
    character(len=*), parameter :: subName=modName//'::get_var_0d_text'
    integer :: iotype, mpierr, msg, ilen, itype
    integer(kind=PIO_OFFSET) :: isize

    ierr=0
    iotype = File%iotype 
    isize=1	
    ios=>File%iosystem
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVAR_0d
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 100
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)


    endif



    if(File%iosystem%IOProc) then
       select case (iotype) 
       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",426)
    if(ios%async_interface .or. ios%num_tasks>ios%num_iotasks) then
       call MPI_Bcast(ival,int(isize), MPI_CHARACTER , ios%IOMaster, ios%My_comm, mpierr)
       call CheckMPIReturn(subName, mpierr)
    end if
  end function get_var_0d_text
  integer function get_var_1d_text (File,varid, ival) result(ierr)
    use pio_msg_mod, only : pio_msg_getvar_1d
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid
    character(len=*), intent(out) :: ival(:)
    type(iosystem_desc_t), pointer :: ios
    character(len=*), parameter :: subName=modName//'::get_var_1d_text'
    integer :: iotype, mpierr, msg, ilen, itype
    integer :: dims(1)
    integer :: i
    integer(kind=PIO_OFFSET) :: isize

    ierr=0
    iotype = File%iotype 
    isize=1	
    isize= size(ival)
    ios=>File%iosystem
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVAR_1d
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 100
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       do i=1,1
          dims(i)=size(ival,i)
       end do
       call MPI_BCAST(dims,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)


    endif



    if(File%iosystem%IOProc) then
       select case (iotype) 
       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",426)
    if(ios%async_interface .or. ios%num_tasks>ios%num_iotasks) then
       call MPI_Bcast(ival,int(isize), MPI_CHARACTER , ios%IOMaster, ios%My_comm, mpierr)
       call CheckMPIReturn(subName, mpierr)
    end if
  end function get_var_1d_text
  integer function get_var_2d_text (File,varid, ival) result(ierr)
    use pio_msg_mod, only : pio_msg_getvar_2d
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid
    character(len=*), intent(out) :: ival(:,:)
    type(iosystem_desc_t), pointer :: ios
    character(len=*), parameter :: subName=modName//'::get_var_2d_text'
    integer :: iotype, mpierr, msg, ilen, itype
    integer :: dims(2)
    integer :: i
    integer(kind=PIO_OFFSET) :: isize

    ierr=0
    iotype = File%iotype 
    isize=1	
    isize= size(ival)
    ios=>File%iosystem
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVAR_2d
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 100
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       do i=1,2
          dims(i)=size(ival,i)
       end do
       call MPI_BCAST(dims,2,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)


    endif



    if(File%iosystem%IOProc) then
       select case (iotype) 
       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",426)
    if(ios%async_interface .or. ios%num_tasks>ios%num_iotasks) then
       call MPI_Bcast(ival,int(isize), MPI_CHARACTER , ios%IOMaster, ios%My_comm, mpierr)
       call CheckMPIReturn(subName, mpierr)
    end if
  end function get_var_2d_text
  integer function get_var_3d_text (File,varid, ival) result(ierr)
    use pio_msg_mod, only : pio_msg_getvar_3d
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid
    character(len=*), intent(out) :: ival(:,:,:)
    type(iosystem_desc_t), pointer :: ios
    character(len=*), parameter :: subName=modName//'::get_var_3d_text'
    integer :: iotype, mpierr, msg, ilen, itype
    integer :: dims(3)
    integer :: i
    integer(kind=PIO_OFFSET) :: isize

    ierr=0
    iotype = File%iotype 
    isize=1	
    isize= size(ival)
    ios=>File%iosystem
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVAR_3d
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 100
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       do i=1,3
          dims(i)=size(ival,i)
       end do
       call MPI_BCAST(dims,3,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)


    endif



    if(File%iosystem%IOProc) then
       select case (iotype) 
       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",426)
    if(ios%async_interface .or. ios%num_tasks>ios%num_iotasks) then
       call MPI_Bcast(ival,int(isize), MPI_CHARACTER , ios%IOMaster, ios%My_comm, mpierr)
       call CheckMPIReturn(subName, mpierr)
    end if
  end function get_var_3d_text
  integer function get_var_4d_text (File,varid, ival) result(ierr)
    use pio_msg_mod, only : pio_msg_getvar_4d
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid
    character(len=*), intent(out) :: ival(:,:,:,:)
    type(iosystem_desc_t), pointer :: ios
    character(len=*), parameter :: subName=modName//'::get_var_4d_text'
    integer :: iotype, mpierr, msg, ilen, itype
    integer :: dims(4)
    integer :: i
    integer(kind=PIO_OFFSET) :: isize

    ierr=0
    iotype = File%iotype 
    isize=1	
    isize= size(ival)
    ios=>File%iosystem
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVAR_4d
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 100
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       do i=1,4
          dims(i)=size(ival,i)
       end do
       call MPI_BCAST(dims,4,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)


    endif



    if(File%iosystem%IOProc) then
       select case (iotype) 
       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",426)
    if(ios%async_interface .or. ios%num_tasks>ios%num_iotasks) then
       call MPI_Bcast(ival,int(isize), MPI_CHARACTER , ios%IOMaster, ios%My_comm, mpierr)
       call CheckMPIReturn(subName, mpierr)
    end if
  end function get_var_4d_text
  integer function get_var_5d_text (File,varid, ival) result(ierr)
    use pio_msg_mod, only : pio_msg_getvar_5d
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid
    character(len=*), intent(out) :: ival(:,:,:,:,:)
    type(iosystem_desc_t), pointer :: ios
    character(len=*), parameter :: subName=modName//'::get_var_5d_text'
    integer :: iotype, mpierr, msg, ilen, itype
    integer :: dims(5)
    integer :: i
    integer(kind=PIO_OFFSET) :: isize

    ierr=0
    iotype = File%iotype 
    isize=1	
    isize= size(ival)
    ios=>File%iosystem
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVAR_5d
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 100
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       do i=1,5
          dims(i)=size(ival,i)
       end do
       call MPI_BCAST(dims,5,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)


    endif



    if(File%iosystem%IOProc) then
       select case (iotype) 
       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",426)
    if(ios%async_interface .or. ios%num_tasks>ios%num_iotasks) then
       call MPI_Bcast(ival,int(isize), MPI_CHARACTER , ios%IOMaster, ios%My_comm, mpierr)
       call CheckMPIReturn(subName, mpierr)
    end if
  end function get_var_5d_text
  integer function get_var_0d_real (File,varid, ival) result(ierr)
    use pio_msg_mod, only : pio_msg_getvar_0d
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid
    real(r4), intent(out) :: ival
    type(iosystem_desc_t), pointer :: ios
    character(len=*), parameter :: subName=modName//'::get_var_0d_real'
    integer :: iotype, mpierr, msg, ilen, itype
    integer(kind=PIO_OFFSET) :: isize

    ierr=0
    iotype = File%iotype 
    isize=1	
    ios=>File%iosystem
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVAR_0d
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 101
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)


    endif



    if(File%iosystem%IOProc) then
       select case (iotype) 
       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",426)
    if(ios%async_interface .or. ios%num_tasks>ios%num_iotasks) then
       call MPI_Bcast(ival,int(isize), MPI_REAL4 , ios%IOMaster, ios%My_comm, mpierr)
       call CheckMPIReturn(subName, mpierr)
    end if
  end function get_var_0d_real
  integer function get_var_1d_real (File,varid, ival) result(ierr)
    use pio_msg_mod, only : pio_msg_getvar_1d
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid
    real(r4), intent(out) :: ival(:)
    type(iosystem_desc_t), pointer :: ios
    character(len=*), parameter :: subName=modName//'::get_var_1d_real'
    integer :: iotype, mpierr, msg, ilen, itype
    integer :: dims(1)
    integer :: i
    integer(kind=PIO_OFFSET) :: isize

    ierr=0
    iotype = File%iotype 
    isize=1	
    isize= size(ival)
    ios=>File%iosystem
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVAR_1d
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 101
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       do i=1,1
          dims(i)=size(ival,i)
       end do
       call MPI_BCAST(dims,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)


    endif



    if(File%iosystem%IOProc) then
       select case (iotype) 
       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",426)
    if(ios%async_interface .or. ios%num_tasks>ios%num_iotasks) then
       call MPI_Bcast(ival,int(isize), MPI_REAL4 , ios%IOMaster, ios%My_comm, mpierr)
       call CheckMPIReturn(subName, mpierr)
    end if
  end function get_var_1d_real
  integer function get_var_2d_real (File,varid, ival) result(ierr)
    use pio_msg_mod, only : pio_msg_getvar_2d
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid
    real(r4), intent(out) :: ival(:,:)
    type(iosystem_desc_t), pointer :: ios
    character(len=*), parameter :: subName=modName//'::get_var_2d_real'
    integer :: iotype, mpierr, msg, ilen, itype
    integer :: dims(2)
    integer :: i
    integer(kind=PIO_OFFSET) :: isize

    ierr=0
    iotype = File%iotype 
    isize=1	
    isize= size(ival)
    ios=>File%iosystem
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVAR_2d
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 101
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       do i=1,2
          dims(i)=size(ival,i)
       end do
       call MPI_BCAST(dims,2,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)


    endif



    if(File%iosystem%IOProc) then
       select case (iotype) 
       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",426)
    if(ios%async_interface .or. ios%num_tasks>ios%num_iotasks) then
       call MPI_Bcast(ival,int(isize), MPI_REAL4 , ios%IOMaster, ios%My_comm, mpierr)
       call CheckMPIReturn(subName, mpierr)
    end if
  end function get_var_2d_real
  integer function get_var_3d_real (File,varid, ival) result(ierr)
    use pio_msg_mod, only : pio_msg_getvar_3d
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid
    real(r4), intent(out) :: ival(:,:,:)
    type(iosystem_desc_t), pointer :: ios
    character(len=*), parameter :: subName=modName//'::get_var_3d_real'
    integer :: iotype, mpierr, msg, ilen, itype
    integer :: dims(3)
    integer :: i
    integer(kind=PIO_OFFSET) :: isize

    ierr=0
    iotype = File%iotype 
    isize=1	
    isize= size(ival)
    ios=>File%iosystem
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVAR_3d
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 101
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       do i=1,3
          dims(i)=size(ival,i)
       end do
       call MPI_BCAST(dims,3,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)


    endif



    if(File%iosystem%IOProc) then
       select case (iotype) 
       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",426)
    if(ios%async_interface .or. ios%num_tasks>ios%num_iotasks) then
       call MPI_Bcast(ival,int(isize), MPI_REAL4 , ios%IOMaster, ios%My_comm, mpierr)
       call CheckMPIReturn(subName, mpierr)
    end if
  end function get_var_3d_real
  integer function get_var_4d_real (File,varid, ival) result(ierr)
    use pio_msg_mod, only : pio_msg_getvar_4d
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid
    real(r4), intent(out) :: ival(:,:,:,:)
    type(iosystem_desc_t), pointer :: ios
    character(len=*), parameter :: subName=modName//'::get_var_4d_real'
    integer :: iotype, mpierr, msg, ilen, itype
    integer :: dims(4)
    integer :: i
    integer(kind=PIO_OFFSET) :: isize

    ierr=0
    iotype = File%iotype 
    isize=1	
    isize= size(ival)
    ios=>File%iosystem
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVAR_4d
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 101
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       do i=1,4
          dims(i)=size(ival,i)
       end do
       call MPI_BCAST(dims,4,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)


    endif



    if(File%iosystem%IOProc) then
       select case (iotype) 
       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",426)
    if(ios%async_interface .or. ios%num_tasks>ios%num_iotasks) then
       call MPI_Bcast(ival,int(isize), MPI_REAL4 , ios%IOMaster, ios%My_comm, mpierr)
       call CheckMPIReturn(subName, mpierr)
    end if
  end function get_var_4d_real
  integer function get_var_5d_real (File,varid, ival) result(ierr)
    use pio_msg_mod, only : pio_msg_getvar_5d
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid
    real(r4), intent(out) :: ival(:,:,:,:,:)
    type(iosystem_desc_t), pointer :: ios
    character(len=*), parameter :: subName=modName//'::get_var_5d_real'
    integer :: iotype, mpierr, msg, ilen, itype
    integer :: dims(5)
    integer :: i
    integer(kind=PIO_OFFSET) :: isize

    ierr=0
    iotype = File%iotype 
    isize=1	
    isize= size(ival)
    ios=>File%iosystem
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVAR_5d
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 101
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       do i=1,5
          dims(i)=size(ival,i)
       end do
       call MPI_BCAST(dims,5,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)


    endif



    if(File%iosystem%IOProc) then
       select case (iotype) 
       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",426)
    if(ios%async_interface .or. ios%num_tasks>ios%num_iotasks) then
       call MPI_Bcast(ival,int(isize), MPI_REAL4 , ios%IOMaster, ios%My_comm, mpierr)
       call CheckMPIReturn(subName, mpierr)
    end if
  end function get_var_5d_real
  integer function get_var_0d_double (File,varid, ival) result(ierr)
    use pio_msg_mod, only : pio_msg_getvar_0d
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid
    real(r8), intent(out) :: ival
    type(iosystem_desc_t), pointer :: ios
    character(len=*), parameter :: subName=modName//'::get_var_0d_double'
    integer :: iotype, mpierr, msg, ilen, itype
    integer(kind=PIO_OFFSET) :: isize

    ierr=0
    iotype = File%iotype 
    isize=1	
    ios=>File%iosystem
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVAR_0d
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 102
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)


    endif



    if(File%iosystem%IOProc) then
       select case (iotype) 
       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",426)
    if(ios%async_interface .or. ios%num_tasks>ios%num_iotasks) then
       call MPI_Bcast(ival,int(isize), MPI_REAL8 , ios%IOMaster, ios%My_comm, mpierr)
       call CheckMPIReturn(subName, mpierr)
    end if
  end function get_var_0d_double
  integer function get_var_1d_double (File,varid, ival) result(ierr)
    use pio_msg_mod, only : pio_msg_getvar_1d
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid
    real(r8), intent(out) :: ival(:)
    type(iosystem_desc_t), pointer :: ios
    character(len=*), parameter :: subName=modName//'::get_var_1d_double'
    integer :: iotype, mpierr, msg, ilen, itype
    integer :: dims(1)
    integer :: i
    integer(kind=PIO_OFFSET) :: isize

    ierr=0
    iotype = File%iotype 
    isize=1	
    isize= size(ival)
    ios=>File%iosystem
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVAR_1d
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 102
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       do i=1,1
          dims(i)=size(ival,i)
       end do
       call MPI_BCAST(dims,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)


    endif



    if(File%iosystem%IOProc) then
       select case (iotype) 
       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",426)
    if(ios%async_interface .or. ios%num_tasks>ios%num_iotasks) then
       call MPI_Bcast(ival,int(isize), MPI_REAL8 , ios%IOMaster, ios%My_comm, mpierr)
       call CheckMPIReturn(subName, mpierr)
    end if
  end function get_var_1d_double
  integer function get_var_2d_double (File,varid, ival) result(ierr)
    use pio_msg_mod, only : pio_msg_getvar_2d
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid
    real(r8), intent(out) :: ival(:,:)
    type(iosystem_desc_t), pointer :: ios
    character(len=*), parameter :: subName=modName//'::get_var_2d_double'
    integer :: iotype, mpierr, msg, ilen, itype
    integer :: dims(2)
    integer :: i
    integer(kind=PIO_OFFSET) :: isize

    ierr=0
    iotype = File%iotype 
    isize=1	
    isize= size(ival)
    ios=>File%iosystem
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVAR_2d
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 102
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       do i=1,2
          dims(i)=size(ival,i)
       end do
       call MPI_BCAST(dims,2,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)


    endif



    if(File%iosystem%IOProc) then
       select case (iotype) 
       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",426)
    if(ios%async_interface .or. ios%num_tasks>ios%num_iotasks) then
       call MPI_Bcast(ival,int(isize), MPI_REAL8 , ios%IOMaster, ios%My_comm, mpierr)
       call CheckMPIReturn(subName, mpierr)
    end if
  end function get_var_2d_double
  integer function get_var_3d_double (File,varid, ival) result(ierr)
    use pio_msg_mod, only : pio_msg_getvar_3d
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid
    real(r8), intent(out) :: ival(:,:,:)
    type(iosystem_desc_t), pointer :: ios
    character(len=*), parameter :: subName=modName//'::get_var_3d_double'
    integer :: iotype, mpierr, msg, ilen, itype
    integer :: dims(3)
    integer :: i
    integer(kind=PIO_OFFSET) :: isize

    ierr=0
    iotype = File%iotype 
    isize=1	
    isize= size(ival)
    ios=>File%iosystem
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVAR_3d
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 102
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       do i=1,3
          dims(i)=size(ival,i)
       end do
       call MPI_BCAST(dims,3,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)


    endif



    if(File%iosystem%IOProc) then
       select case (iotype) 
       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",426)
    if(ios%async_interface .or. ios%num_tasks>ios%num_iotasks) then
       call MPI_Bcast(ival,int(isize), MPI_REAL8 , ios%IOMaster, ios%My_comm, mpierr)
       call CheckMPIReturn(subName, mpierr)
    end if
  end function get_var_3d_double
  integer function get_var_4d_double (File,varid, ival) result(ierr)
    use pio_msg_mod, only : pio_msg_getvar_4d
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid
    real(r8), intent(out) :: ival(:,:,:,:)
    type(iosystem_desc_t), pointer :: ios
    character(len=*), parameter :: subName=modName//'::get_var_4d_double'
    integer :: iotype, mpierr, msg, ilen, itype
    integer :: dims(4)
    integer :: i
    integer(kind=PIO_OFFSET) :: isize

    ierr=0
    iotype = File%iotype 
    isize=1	
    isize= size(ival)
    ios=>File%iosystem
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVAR_4d
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 102
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       do i=1,4
          dims(i)=size(ival,i)
       end do
       call MPI_BCAST(dims,4,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)


    endif



    if(File%iosystem%IOProc) then
       select case (iotype) 
       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",426)
    if(ios%async_interface .or. ios%num_tasks>ios%num_iotasks) then
       call MPI_Bcast(ival,int(isize), MPI_REAL8 , ios%IOMaster, ios%My_comm, mpierr)
       call CheckMPIReturn(subName, mpierr)
    end if
  end function get_var_4d_double
  integer function get_var_5d_double (File,varid, ival) result(ierr)
    use pio_msg_mod, only : pio_msg_getvar_5d
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid
    real(r8), intent(out) :: ival(:,:,:,:,:)
    type(iosystem_desc_t), pointer :: ios
    character(len=*), parameter :: subName=modName//'::get_var_5d_double'
    integer :: iotype, mpierr, msg, ilen, itype
    integer :: dims(5)
    integer :: i
    integer(kind=PIO_OFFSET) :: isize

    ierr=0
    iotype = File%iotype 
    isize=1	
    isize= size(ival)
    ios=>File%iosystem
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVAR_5d
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 102
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       do i=1,5
          dims(i)=size(ival,i)
       end do
       call MPI_BCAST(dims,5,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)


    endif



    if(File%iosystem%IOProc) then
       select case (iotype) 
       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",426)
    if(ios%async_interface .or. ios%num_tasks>ios%num_iotasks) then
       call MPI_Bcast(ival,int(isize), MPI_REAL8 , ios%IOMaster, ios%My_comm, mpierr)
       call CheckMPIReturn(subName, mpierr)
    end if
  end function get_var_5d_double
  integer function get_var_0d_int (File,varid, ival) result(ierr)
    use pio_msg_mod, only : pio_msg_getvar_0d
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid
    integer(i4), intent(out) :: ival
    type(iosystem_desc_t), pointer :: ios
    character(len=*), parameter :: subName=modName//'::get_var_0d_int'
    integer :: iotype, mpierr, msg, ilen, itype
    integer(kind=PIO_OFFSET) :: isize

    ierr=0
    iotype = File%iotype 
    isize=1	
    ios=>File%iosystem
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVAR_0d
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 103
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)


    endif



    if(File%iosystem%IOProc) then
       select case (iotype) 
       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",426)
    if(ios%async_interface .or. ios%num_tasks>ios%num_iotasks) then
       call MPI_Bcast(ival,int(isize), MPI_INTEGER , ios%IOMaster, ios%My_comm, mpierr)
       call CheckMPIReturn(subName, mpierr)
    end if
  end function get_var_0d_int
  integer function get_var_1d_int (File,varid, ival) result(ierr)
    use pio_msg_mod, only : pio_msg_getvar_1d
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid
    integer(i4), intent(out) :: ival(:)
    type(iosystem_desc_t), pointer :: ios
    character(len=*), parameter :: subName=modName//'::get_var_1d_int'
    integer :: iotype, mpierr, msg, ilen, itype
    integer :: dims(1)
    integer :: i
    integer(kind=PIO_OFFSET) :: isize

    ierr=0
    iotype = File%iotype 
    isize=1	
    isize= size(ival)
    ios=>File%iosystem
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVAR_1d
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 103
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       do i=1,1
          dims(i)=size(ival,i)
       end do
       call MPI_BCAST(dims,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)


    endif



    if(File%iosystem%IOProc) then
       select case (iotype) 
       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",426)
    if(ios%async_interface .or. ios%num_tasks>ios%num_iotasks) then
       call MPI_Bcast(ival,int(isize), MPI_INTEGER , ios%IOMaster, ios%My_comm, mpierr)
       call CheckMPIReturn(subName, mpierr)
    end if
  end function get_var_1d_int
  integer function get_var_2d_int (File,varid, ival) result(ierr)
    use pio_msg_mod, only : pio_msg_getvar_2d
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid
    integer(i4), intent(out) :: ival(:,:)
    type(iosystem_desc_t), pointer :: ios
    character(len=*), parameter :: subName=modName//'::get_var_2d_int'
    integer :: iotype, mpierr, msg, ilen, itype
    integer :: dims(2)
    integer :: i
    integer(kind=PIO_OFFSET) :: isize

    ierr=0
    iotype = File%iotype 
    isize=1	
    isize= size(ival)
    ios=>File%iosystem
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVAR_2d
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 103
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       do i=1,2
          dims(i)=size(ival,i)
       end do
       call MPI_BCAST(dims,2,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)


    endif



    if(File%iosystem%IOProc) then
       select case (iotype) 
       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",426)
    if(ios%async_interface .or. ios%num_tasks>ios%num_iotasks) then
       call MPI_Bcast(ival,int(isize), MPI_INTEGER , ios%IOMaster, ios%My_comm, mpierr)
       call CheckMPIReturn(subName, mpierr)
    end if
  end function get_var_2d_int
  integer function get_var_3d_int (File,varid, ival) result(ierr)
    use pio_msg_mod, only : pio_msg_getvar_3d
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid
    integer(i4), intent(out) :: ival(:,:,:)
    type(iosystem_desc_t), pointer :: ios
    character(len=*), parameter :: subName=modName//'::get_var_3d_int'
    integer :: iotype, mpierr, msg, ilen, itype
    integer :: dims(3)
    integer :: i
    integer(kind=PIO_OFFSET) :: isize

    ierr=0
    iotype = File%iotype 
    isize=1	
    isize= size(ival)
    ios=>File%iosystem
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVAR_3d
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 103
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       do i=1,3
          dims(i)=size(ival,i)
       end do
       call MPI_BCAST(dims,3,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)


    endif



    if(File%iosystem%IOProc) then
       select case (iotype) 
       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",426)
    if(ios%async_interface .or. ios%num_tasks>ios%num_iotasks) then
       call MPI_Bcast(ival,int(isize), MPI_INTEGER , ios%IOMaster, ios%My_comm, mpierr)
       call CheckMPIReturn(subName, mpierr)
    end if
  end function get_var_3d_int
  integer function get_var_4d_int (File,varid, ival) result(ierr)
    use pio_msg_mod, only : pio_msg_getvar_4d
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid
    integer(i4), intent(out) :: ival(:,:,:,:)
    type(iosystem_desc_t), pointer :: ios
    character(len=*), parameter :: subName=modName//'::get_var_4d_int'
    integer :: iotype, mpierr, msg, ilen, itype
    integer :: dims(4)
    integer :: i
    integer(kind=PIO_OFFSET) :: isize

    ierr=0
    iotype = File%iotype 
    isize=1	
    isize= size(ival)
    ios=>File%iosystem
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVAR_4d
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 103
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       do i=1,4
          dims(i)=size(ival,i)
       end do
       call MPI_BCAST(dims,4,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)


    endif



    if(File%iosystem%IOProc) then
       select case (iotype) 
       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",426)
    if(ios%async_interface .or. ios%num_tasks>ios%num_iotasks) then
       call MPI_Bcast(ival,int(isize), MPI_INTEGER , ios%IOMaster, ios%My_comm, mpierr)
       call CheckMPIReturn(subName, mpierr)
    end if
  end function get_var_4d_int
  integer function get_var_5d_int (File,varid, ival) result(ierr)
    use pio_msg_mod, only : pio_msg_getvar_5d
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid
    integer(i4), intent(out) :: ival(:,:,:,:,:)
    type(iosystem_desc_t), pointer :: ios
    character(len=*), parameter :: subName=modName//'::get_var_5d_int'
    integer :: iotype, mpierr, msg, ilen, itype
    integer :: dims(5)
    integer :: i
    integer(kind=PIO_OFFSET) :: isize

    ierr=0
    iotype = File%iotype 
    isize=1	
    isize= size(ival)
    ios=>File%iosystem
    if(ios%async_interface .and. .not. ios%ioproc ) then
       msg=PIO_MSG_GETVAR_5d
       if(ios%comp_rank==0) call mpi_send(msg, 1, mpi_integer, ios%ioroot, 1, ios%union_comm, ierr)
       call MPI_BCAST(file%fh,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       call MPI_BCAST(varid,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       itype = 103
       call MPI_BCAST(itype,1,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)
       do i=1,5
          dims(i)=size(ival,i)
       end do
       call MPI_BCAST(dims,5,MPI_INTEGER,ios%CompMaster, ios%my_comm , mpierr)


    endif



    if(File%iosystem%IOProc) then
       select case (iotype) 
       end select
    end if
    call check_netcdf(File,ierr,"pionfget_mod.F90",426)
    if(ios%async_interface .or. ios%num_tasks>ios%num_iotasks) then
       call MPI_Bcast(ival,int(isize), MPI_INTEGER , ios%IOMaster, ios%My_comm, mpierr)
       call CheckMPIReturn(subName, mpierr)
    end if
  end function get_var_5d_int

!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param vardesc @ref var_desc_t
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_var_vdesc_0d_text (File,vardesc, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    character(len=*), intent(out) :: ival

    character(len=*), parameter :: subName=modName//'::get_var_vdesc_0d_text'

    ierr = get_var_0d_text (File, vardesc%varid, ival)

  end function get_var_vdesc_0d_text
  integer function get_var_vdesc_1d_text (File,vardesc, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    character(len=*), intent(out) :: ival(:)

    character(len=*), parameter :: subName=modName//'::get_var_vdesc_1d_text'

    ierr = get_var_1d_text (File, vardesc%varid, ival)

  end function get_var_vdesc_1d_text
  integer function get_var_vdesc_2d_text (File,vardesc, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    character(len=*), intent(out) :: ival(:,:)

    character(len=*), parameter :: subName=modName//'::get_var_vdesc_2d_text'

    ierr = get_var_2d_text (File, vardesc%varid, ival)

  end function get_var_vdesc_2d_text
  integer function get_var_vdesc_3d_text (File,vardesc, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    character(len=*), intent(out) :: ival(:,:,:)

    character(len=*), parameter :: subName=modName//'::get_var_vdesc_3d_text'

    ierr = get_var_3d_text (File, vardesc%varid, ival)

  end function get_var_vdesc_3d_text
  integer function get_var_vdesc_4d_text (File,vardesc, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    character(len=*), intent(out) :: ival(:,:,:,:)

    character(len=*), parameter :: subName=modName//'::get_var_vdesc_4d_text'

    ierr = get_var_4d_text (File, vardesc%varid, ival)

  end function get_var_vdesc_4d_text
  integer function get_var_vdesc_5d_text (File,vardesc, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    character(len=*), intent(out) :: ival(:,:,:,:,:)

    character(len=*), parameter :: subName=modName//'::get_var_vdesc_5d_text'

    ierr = get_var_5d_text (File, vardesc%varid, ival)

  end function get_var_vdesc_5d_text
  integer function get_var_vdesc_0d_real (File,vardesc, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    real(r4), intent(out) :: ival

    character(len=*), parameter :: subName=modName//'::get_var_vdesc_0d_real'

    ierr = get_var_0d_real (File, vardesc%varid, ival)

  end function get_var_vdesc_0d_real
  integer function get_var_vdesc_1d_real (File,vardesc, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    real(r4), intent(out) :: ival(:)

    character(len=*), parameter :: subName=modName//'::get_var_vdesc_1d_real'

    ierr = get_var_1d_real (File, vardesc%varid, ival)

  end function get_var_vdesc_1d_real
  integer function get_var_vdesc_2d_real (File,vardesc, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    real(r4), intent(out) :: ival(:,:)

    character(len=*), parameter :: subName=modName//'::get_var_vdesc_2d_real'

    ierr = get_var_2d_real (File, vardesc%varid, ival)

  end function get_var_vdesc_2d_real
  integer function get_var_vdesc_3d_real (File,vardesc, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    real(r4), intent(out) :: ival(:,:,:)

    character(len=*), parameter :: subName=modName//'::get_var_vdesc_3d_real'

    ierr = get_var_3d_real (File, vardesc%varid, ival)

  end function get_var_vdesc_3d_real
  integer function get_var_vdesc_4d_real (File,vardesc, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    real(r4), intent(out) :: ival(:,:,:,:)

    character(len=*), parameter :: subName=modName//'::get_var_vdesc_4d_real'

    ierr = get_var_4d_real (File, vardesc%varid, ival)

  end function get_var_vdesc_4d_real
  integer function get_var_vdesc_5d_real (File,vardesc, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    real(r4), intent(out) :: ival(:,:,:,:,:)

    character(len=*), parameter :: subName=modName//'::get_var_vdesc_5d_real'

    ierr = get_var_5d_real (File, vardesc%varid, ival)

  end function get_var_vdesc_5d_real
  integer function get_var_vdesc_0d_double (File,vardesc, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    real(r8), intent(out) :: ival

    character(len=*), parameter :: subName=modName//'::get_var_vdesc_0d_double'

    ierr = get_var_0d_double (File, vardesc%varid, ival)

  end function get_var_vdesc_0d_double
  integer function get_var_vdesc_1d_double (File,vardesc, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    real(r8), intent(out) :: ival(:)

    character(len=*), parameter :: subName=modName//'::get_var_vdesc_1d_double'

    ierr = get_var_1d_double (File, vardesc%varid, ival)

  end function get_var_vdesc_1d_double
  integer function get_var_vdesc_2d_double (File,vardesc, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    real(r8), intent(out) :: ival(:,:)

    character(len=*), parameter :: subName=modName//'::get_var_vdesc_2d_double'

    ierr = get_var_2d_double (File, vardesc%varid, ival)

  end function get_var_vdesc_2d_double
  integer function get_var_vdesc_3d_double (File,vardesc, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    real(r8), intent(out) :: ival(:,:,:)

    character(len=*), parameter :: subName=modName//'::get_var_vdesc_3d_double'

    ierr = get_var_3d_double (File, vardesc%varid, ival)

  end function get_var_vdesc_3d_double
  integer function get_var_vdesc_4d_double (File,vardesc, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    real(r8), intent(out) :: ival(:,:,:,:)

    character(len=*), parameter :: subName=modName//'::get_var_vdesc_4d_double'

    ierr = get_var_4d_double (File, vardesc%varid, ival)

  end function get_var_vdesc_4d_double
  integer function get_var_vdesc_5d_double (File,vardesc, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    real(r8), intent(out) :: ival(:,:,:,:,:)

    character(len=*), parameter :: subName=modName//'::get_var_vdesc_5d_double'

    ierr = get_var_5d_double (File, vardesc%varid, ival)

  end function get_var_vdesc_5d_double
  integer function get_var_vdesc_0d_int (File,vardesc, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    integer(i4), intent(out) :: ival

    character(len=*), parameter :: subName=modName//'::get_var_vdesc_0d_int'

    ierr = get_var_0d_int (File, vardesc%varid, ival)

  end function get_var_vdesc_0d_int
  integer function get_var_vdesc_1d_int (File,vardesc, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    integer(i4), intent(out) :: ival(:)

    character(len=*), parameter :: subName=modName//'::get_var_vdesc_1d_int'

    ierr = get_var_1d_int (File, vardesc%varid, ival)

  end function get_var_vdesc_1d_int
  integer function get_var_vdesc_2d_int (File,vardesc, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    integer(i4), intent(out) :: ival(:,:)

    character(len=*), parameter :: subName=modName//'::get_var_vdesc_2d_int'

    ierr = get_var_2d_int (File, vardesc%varid, ival)

  end function get_var_vdesc_2d_int
  integer function get_var_vdesc_3d_int (File,vardesc, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    integer(i4), intent(out) :: ival(:,:,:)

    character(len=*), parameter :: subName=modName//'::get_var_vdesc_3d_int'

    ierr = get_var_3d_int (File, vardesc%varid, ival)

  end function get_var_vdesc_3d_int
  integer function get_var_vdesc_4d_int (File,vardesc, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    integer(i4), intent(out) :: ival(:,:,:,:)

    character(len=*), parameter :: subName=modName//'::get_var_vdesc_4d_int'

    ierr = get_var_4d_int (File, vardesc%varid, ival)

  end function get_var_vdesc_4d_int
  integer function get_var_vdesc_5d_int (File,vardesc, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    integer(i4), intent(out) :: ival(:,:,:,:,:)

    character(len=*), parameter :: subName=modName//'::get_var_vdesc_5d_int'

    ierr = get_var_5d_int (File, vardesc%varid, ival)

  end function get_var_vdesc_5d_int
end module pionfget_mod
